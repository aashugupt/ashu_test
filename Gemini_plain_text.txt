Only use the following nodes in your expressions: AccessSpecification, AliasDecl, AlignAsExpr, AlignAsType, AlignOfExpr, AnyAttribute, AnyCapture, AnyDeclarator, AnyDecl, AnyDesignator, AnyDirectDeclarator, AnyEnumerator, AnyExpr, AnyFuncBody, AnyInitDeclarator, AnyInitializer, AnyLabel, AnyMemberDecl, AnyName, AnyNameQualifier, AnyNames, AnyNameSpec, AnyNonPtrDeclarator, AnyParamName, AnyPropertyFunc, AnyPseudoDtor, AnyQualifiedName, AnyStmt, AnyTemplateArg, AnyTypeId, AnyTypeName, AnyTypeOf, AnyTypeParam, AnyUsing, ArrayDeclarator, AsmDef, AsmStmt, AttributedDeclarator, AttributeDeclSpec, Attribute, Attributes, AttributeSpec, AttributeSpecs, AttributeWithArgs, AutoType, BaseSpec, BaseSpecs, BinaryExpr, BitFieldDeclarator, BoolLiteralExpr, BreakStmt, BuiltinType, CallExpr, CaptureDefault, Capture, CaseLabel, CaseRangeLabel, CastExpr, ClassType, CommentStmt, CompoundStmt, ConditionalExpr, ConstExpr, ContinueStmt, ConvFunc, ConvTypeId, CopyInitializer, CtorInitializer, CVQualifier, Declarator, DeclEllipsis, Decl, DeclOrStmt, DeclOrStmts, DeclSpec, DeclSpecs, DefaultException, DefaultLabel, DeleteExpr, DenyThrowSpec, Designators, DirectDeclarator, DirectInitializer, DirectNewDeclarator, DoDeclStmt, DoStmt, Dtor, Enumerator, Enumerators, EnumType, ExceptHandler, Exception, ExceptionSpec, ExplicitInstantiation, ExprArg, Exprs, ExprStmt, ExprTypeIdExpr, FieldDesignator, FinallyHandler, ForEachStmt, ForRangeStmt, ForStmt, FuncBody, FuncDeclarator, FuncDef, FuncSpec, FuncTryBlock, GenericAttribute, GlobalScope, GotoStmt, Handler, Handlers, IdExpr, IfDeclStmt, IfStmt, IndexDesignator, IndexExpr, InitClause, InitDeclarator, InitDeclarators, InitializedCapture, InitializedDeclarator, InitializerExpr, Initializers, KRFuncDeclarator, LabeledStmt, Label, LambdaDeclarator, LambdaExpr, LambdaIntroducer, LeaveStmt, LinkageSpec, LiteralExpr, MaybeCtorInitializer, MaybeDeclarator, MaybeDirectNewDeclarator, MaybeException, MaybeExceptionSpec, MaybeLambdaDeclarator, MaybeNewDeclarator, MaybeNewInitializer, MaybeTypeId, MemberDeclarators, MemberDecl, MemberDecls, MemberDesignator, MemberExpr, MemberFunc, MemberInitializer, MemberInitializers, MemberTemplate, MemberUsingDecl, NameDeclarator, Name, NamespaceAlias, NamespaceDecl, NameSpec, NewDeclarator, NewExpr, NewInitializer, NewTypeId, Node, NullptrLiteralExpr, OpFunc, Op, Param, ParamName, ParamNames, ParensDeclarator, ParensExpr, PreprHash, PromisedFuncBody, PromisedMemberDecl, PropertyAttribute, PropertyFuncs, PropertyGetFunc, PropertyPutFunc, PseudoDtor, PtrDeclarator, Ptr, Ptrs, QualifiedName, QualifiedNames, QualifiedPseudoDtor, RangeDesignator, ReservedTypeSpec, ReturnStmt, SizeOfExpr, SpecialCastExpr, StaticAssertDecl, StmtExpr, StorageClass, StringLiteralExpr, SuffixFunc, SuperScope, SwitchDeclStmt, SwitchStmt, TemplateArgs, TemplateDecl, TemplateName, TemplateParam, TemplateParams, TemplateSpec, TemplateTypeArg, TemplateTypeParam, ThisExpr, ThrowExpr, TranslationUnit, TruncatedInitClause, TryExceptStmt, TryFinallyStmt, TryStmt, TypeAdjective, TypeArg, TypeConvExpr, TypeId, TypeName, TypeOfExpr, TypeOfSpec, TypeOfType, TypeParam, TypeTypeIdExpr, UnaryExpr, UnparsedDeclarator, UnparsedDecl, UnparsedDeclSpec, UnparsedDirectDeclarator, UnparsedEnumerator, UnparsedException, UnparsedExpr, UnparsedInitDeclarator, UnparsedInitializer, UnparsedLabel, UnparsedMemberDeclarator, UnparsedMemberDecl, UnparsedName, UnparsedNameQualifier, UnparsedParamName, UnparsedPropertyFunc, UnparsedPtr, UnparsedQualifiedName, UnparsedStmt, UnqualifiedName, UserLiteralExpr, UserStringLiteralExpr, UsingDecl, UsingDirective, WhileDeclStmt, WhileStmt

Nodes may have children. For example, BitFieldDeclarator has two children: a MaybeDeclarator called Declarator, and a Exprs called Bits. Children can be selected using the / operator. For example, //BitFieldDeclarator / Bits::LiteralExpr will select LiteralExpr that are used as Bits of a BitFieldDeclarator. Note that this would select the LiteralExpr. To select the BitFieldDeclarator, we could have used a predicate instead, like //BitFieldDeclarator [Bits::LiteralExpr]. That is, it should be the name of the child followed by :: followed by its expected type. Here is a list of nodes and their children (one child per line):

- `TranslationUnit` has a child of type `DeclOrStmts` named `Decls`
- `FuncDef` has a child of type `DeclSpecs` named `DeclSpecs`, which is an array
- `FuncDef` has a child of type `MaybeDeclarator` named `Declarator`
- `FuncDef` has a child of type `DeclOrStmts` named `KRParams`
- `FuncDef` has a child of type `AnyFuncBody` named `FuncBody`
- `Decl` has a child of type `DeclSpecs` named `DeclSpecs`
- `Decl` has a child of type `MaybeDeclarator` named `Declarators`
- `TemplateDecl` has a child of type `TemplateParams` named `Params`
- `TemplateDecl` has a child of type `DeclOrStmt` named `Decl`
- `LinkageSpec` has a child of type `DeclOrStmts` named `Decls`
- `ExplicitInstantiation` has a child of type `DeclSpecs` named `DeclSpecs`
- `ExplicitInstantiation` has a child of type `MaybeDeclarator` named `Declarator`
- `NamespaceDecl` has a child of type `DeclOrStmts` named `Decls`
- `NamespaceAlias` has a child of type `AnyName` named `Name`
- `AnyUsing` has a child of type `AnyName` named `Name`
- `AliasDecl` has a child of type `AnyName` named `Name`
- `AliasDecl` has a child of type `TypeId` named `Type`
- `StaticAssertDecl` has a child of type `AnyExpr` named `Expr`
- `LabeledStmt` has a child of type `AnyLabel` named `Label`
- `LabeledStmt` has a child of type `DeclOrStmts` named `Stmt`
- `ExprStmt` has a child of type `Exprs` named `Expr`
- `CompoundStmt` has a child of type `DeclOrStmts` named `Stmts`
- `IfStmt` has a child of type `Decl` named `Init`
- `IfStmt` has a child of type `AnyExpr` named `Cond`
- `IfStmt` has a child of type `DeclOrStmts` named `Then`
- `IfStmt` has a child of type `DeclOrStmts` named `Else`
- `IfDeclStmt` has a child of type `Decl` named `Init`
- `IfDeclStmt` has a child of type `Decl` named `Cond`
- `IfDeclStmt` has a child of type `DeclOrStmts` named `Then`
- `IfDeclStmt` has a child of type `DeclOrStmts` named `Else`
- `SwitchStmt` has a child of type `AnyExpr` named `Cond`
- `SwitchStmt` has a child of type `DeclOrStmts` named `Stmt`
- `SwitchDeclStmt` has a child of type `Decl` named `Cond`
- `SwitchDeclStmt` has a child of type `DeclOrStmts` named `Stmt`
- `WhileStmt` has a child of type `AnyExpr` named `Cond`
- `WhileStmt` has a child of type `DeclOrStmts` named `Stmt`
- `WhileDeclStmt` has a child of type `Decl` named `Cond`
- `WhileDeclStmt` has a child of type `DeclOrStmts` named `Stmt`
- `DoStmt` has a child of type `DeclOrStmts` named `Stmt`
- `DoStmt` has a child of type `AnyExpr` named `Cond`
- `DoDeclStmt` has a child of type `Decl` named `Cond`
- `DoDeclStmt` has a child of type `DeclOrStmts` named `Stmt`
- `ForStmt` has a child of type `DeclOrStmts` named `Init`
- `ForStmt` has a child of type `Exprs` named `Cond`
- `ForStmt` has a child of type `Exprs` named `Expr`
- `ForStmt` has a child of type `DeclOrStmts` named `Stmt`
- `ForEachStmt` has a child of type `DeclOrStmts` named `Init`
- `ForEachStmt` has a child of type `Exprs` named `Expr`
- `ForEachStmt` has a child of type `DeclOrStmts` named `Stmt`
- `ForRangeStmt` has a child of type `DeclOrStmts` named `Init`
- `ForRangeStmt` has a child of type `Exprs` named `Expr`
- `ForRangeStmt` has a child of type `DeclOrStmts` named `Stmt`
- `ReturnStmt` has a child of type `Exprs` named `Expr`
- `TryStmt` has a child of type `CompoundStmt` named `Stmt`
- `TryStmt` has a child of type `Handlers` named `Handlers`
- `TryExceptStmt` has a child of type `CompoundStmt` named `Stmt`
- `TryExceptStmt` has a child of type `ExceptHandler` named `Handler`
- `TryFinallyStmt` has a child of type `CompoundStmt` named `Stmt`
- `TryFinallyStmt` has a child of type `FinallyHandler` named `Handler`
- `FuncBody` has a child of type `MaybeCtorInitializer` named `CtorInit`
- `FuncBody` has a child of type `CompoundStmt` named `Stmt`
- `FuncTryBlock` has a child of type `MaybeCtorInitializer` named `CtorInit`
- `FuncTryBlock` has a child of type `CompoundStmt` named `Stmt`
- `FuncTryBlock` has a child of type `Handlers` named `Handlers`
- `Handler` has a child of type `MaybeException` named `Exception`
- `Handler` has a child of type `CompoundStmt` named `Stmt`
- `ExceptHandler` has a child of type `AnyExpr` named `Expr`
- `ExceptHandler` has a child of type `CompoundStmt` named `Stmt`
- `FinallyHandler` has a child of type `CompoundStmt` named `Stmt`
- `Exception` has a child of type `DeclSpecs` named `DeclSpecs`
- `Exception` has a child of type `MaybeDeclarator` named `Declarator`
- `TypeParam` has a child of type `AnyName` named `Name`
- `TypeParam` has a child of type `MaybeTypeId` named `Default`
- `TemplateTypeParam` has a child of type `TemplateParams` named `Params`
- `TemplateTypeParam` has a child of type `AnyName` named `Name`
- `TemplateTypeParam` has a child of type `AnyName` named `Default`
- `Param` has a child of type `Decl` named `Decl`
- `AlignAsExpr` has a child of type `AnyExpr` named `Expr`
- `AlignAsType` has a child of type `TypeId` named `Type`
- `TypeName` has a child of type `AnyName` named `Name`
- `EnumType` has a child of type `AttributeSpecs` named `AttributeSpec`
- `EnumType` has a child of type `AnyNames` named `Name`
- `EnumType` has a child of type `DeclSpecs` named `Base`
- `EnumType` has a child of type `Enumerators` named `Enumerators`
- `ClassType` has a child of type `AttributeSpecs` named `AttributeSpecs`
- `ClassType` has a child of type `AnyNames` named `Name`
- `ClassType` has a child of type `BaseSpecs` named `BaseSpecs`
- `ClassType` has a child of type `MemberDecls` named `MemberDecls`
- `TypeOfExpr` has a child of type `AnyExpr` named `Expr`
- `TypeOfType` has a child of type `TypeId` named `Type`
- `AttributeDeclSpec` has a child of type `AttributeSpec` named `AttributeSpec`
- `AttributeSpec` has a child of type `Attributes` named `Attributes`
- `AttributeWithArgs` has a child of type `Exprs` named `Args`
- `PropertyAttribute` has a child of type `PropertyFuncs` named `PropertyFuncs`
- `MemberDecl` has a child of type `DeclSpecs` named `DeclSpecs`
- `MemberDecl` has a child of type `MaybeDeclarator` named `Declarators`
- `MemberFunc` has a child of type `DeclSpecs` named `DeclSpecs`
- `MemberFunc` has a child of type `MaybeDeclarator` named `Declarator`
- `MemberFunc` has a child of type `AnyFuncBody` named `FuncBody`
- `MemberTemplate` has a child of type `TemplateParams` named `TemplateParams`
- `MemberTemplate` has a child of type `AnyMemberDecl` named `MemberDecl`
- `MemberUsingDecl` has a child of type `AnyName` named `Name`
- `Enumerator` has a child of type `Exprs` named `Expr`
- `NameDeclarator` has a child of type `AnyName` named `Name`
- `ParensDeclarator` has a child of type `MaybeDeclarator` named `Declarator`
- `ArrayDeclarator` has a child of type `AnyNonPtrDeclarator` named `Declarator`
- `ArrayDeclarator` has a child of type `Exprs` named `Size`
- `FuncDeclarator` has a child of type `AnyNonPtrDeclarator` named `Declarator`
- `FuncDeclarator` has a child of type `DeclOrStmts` named `Params`
- `FuncDeclarator` has a child of type `DeclSpecs` named `CVQualifiers`
- `FuncDeclarator` has a child of type `MaybeExceptionSpec` named `Throw`
- `FuncDeclarator` has a child of type `TypeId` named `TrailingReturnType`
- `KRFuncDeclarator` has a child of type `AnyNonPtrDeclarator` named `Declarator`
- `KRFuncDeclarator` has a child of type `ParamNames` named `Params`
- `PtrDeclarator` has a child of type `AnyNameQualifier` named `NameSpec`
- `PtrDeclarator` has a child of type `DeclSpecs` named `CVQualifiers`
- `PtrDeclarator` has a child of type `MaybeDeclarator` named `Declarator`
- `BitFieldDeclarator` has a child of type `MaybeDeclarator` named `Declarator`
- `BitFieldDeclarator` has a child of type `Exprs` named `Bits`
- `AttributedDeclarator` has a child of type `AttributeSpec` named `AttributeSpec`
- `AttributedDeclarator` has a child of type `MaybeDeclarator` named `Declarator`
- `InitializedDeclarator` has a child of type `MaybeDeclarator` named `Declarator`
- `InitializedDeclarator` has a child of type `Initializers` named `Init`
- `AnyInitializer` has a child of type `Designators` named `Designators`
- `CopyInitializer` has a child of type `AnyExpr` named `Expr`
- `InitClause` has a child of type `Initializers` named `Inits`
- `TruncatedInitClause` has a child of type `Initializers` named `Inits`
- `DirectInitializer` has a child of type `Exprs` named `Args`
- `IndexDesignator` has a child of type `AnyExpr` named `Index`
- `RangeDesignator` has a child of type `AnyExpr` named `Lower`
- `RangeDesignator` has a child of type `AnyExpr` named `Upper`
- `CaseLabel` has a child of type `AnyExpr` named `Expr`
- `CaseRangeLabel` has a child of type `AnyExpr` named `Lower`
- `CaseRangeLabel` has a child of type `AnyExpr` named `Upper`
- `IdExpr` has a child of type `AnyName` named `Name`
- `StringLiteralExpr` has a child of type `Exprs` named `Adjacent`
- `UserStringLiteralExpr` has a child of type `StringLiteralExpr` named `Literal`
- `MemberExpr` has a child of type `AnyExpr` named `Expr`
- `MemberExpr` has a child of type `AnyName` named `Name`
- `CallExpr` has a child of type `AnyExpr` named `Func`
- `CallExpr` has a child of type `Exprs` named `Args`
- `TypeConvExpr` has a child of type `AnyTypeName` named `Type`
- `TypeConvExpr` has a child of type `Exprs` named `Args`
- `IndexExpr` has a child of type `AnyExpr` named `Expr`
- `IndexExpr` has a child of type `AnyExpr` named `Index`
- `UnaryExpr` has a child of type `AnyExpr` named `Expr`
- `ThrowExpr` has a child of type `Exprs` named `Expr`
- `BinaryExpr` has a child of type `AnyExpr` named `Left`
- `BinaryExpr` has a child of type `AnyExpr` named `Right`
- `ConditionalExpr` has a child of type `AnyExpr` named `Cond`
- `ConditionalExpr` has a child of type `AnyExpr` named `Then`
- `ConditionalExpr` has a child of type `AnyExpr` named `Else`
- `SizeOfExpr` has a child of type `TypeId` named `Type`
- `AlignOfExpr` has a child of type `TypeId` named `Type`
- `CastExpr` has a child of type `TypeId` named `Type`
- `CastExpr` has a child of type `AnyExpr` named `Expr`
- `SpecialCastExpr` has a child of type `TypeId` named `Type`
- `SpecialCastExpr` has a child of type `AnyExpr` named `Expr`
- `ParensExpr` has a child of type `Exprs` named `Expr`
- `NewExpr` has a child of type `Exprs` named `Placement`
- `NewExpr` has a child of type `TypeId` named `Type`
- `NewExpr` has a child of type `MaybeNewInitializer` named `Initializer`
- `DeleteExpr` has a child of type `AnyExpr` named `Expr`
- `TypeTypeIdExpr` has a child of type `TypeId` named `Type`
- `ExprTypeIdExpr` has a child of type `AnyExpr` named `Expr`
- `StmtExpr` has a child of type `CompoundStmt` named `Stmt`
- `InitializerExpr` has a child of type `TypeId` named `Type`
- `InitializerExpr` has a child of type `InitClause` named `Init`
- `LambdaExpr` has a child of type `LambdaIntroducer` named `Introducer`
- `LambdaExpr` has a child of type `MaybeLambdaDeclarator` named `Declarator`
- `LambdaExpr` has a child of type `AnyFuncBody` named `FuncBody`
- `AnyNameSpec` has a child of type `AnyNameQualifier` named `Qualifier`
- `NameSpec` has a child of type `UnqualifiedName` named `Name`
- `TemplateSpec` has a child of type `TemplateName` named `TemplateName`
- `TypeOfSpec` has a child of type `AnyExpr` named `Expr`
- `QualifiedName` has a child of type `AnyNameQualifier` named `Qualifier`
- `QualifiedName` has a child of type `UnqualifiedName` named `Name`
- `Dtor` has a child of type `UnqualifiedName` named `Name`
- `SuffixFunc` has a child of type `UnqualifiedName` named `Name`
- `ConvFunc` has a child of type `TypeId` named `ConversionType`
- `TemplateName` has a child of type `AnyName` named `Name`
- `TemplateName` has a child of type `TemplateArgs` named `Args`
- `PseudoDtor` has a child of type `ReservedTypeSpec` named `Type`
- `QualifiedPseudoDtor` has a child of type `ReservedTypeSpec` named `Qualifier`
- `QualifiedPseudoDtor` has a child of type `ReservedTypeSpec` named `Type`
- `ExprArg` has a child of type `AnyExpr` named `Expr`
- `TypeArg` has a child of type `TypeId` named `Type`
- `TemplateTypeArg` has a child of type `Name` named `Name`
- `BaseSpec` has a child of type `AnyNameSpec` named `Name`
- `LambdaDeclarator` has a child of type `DeclOrStmts` named `Params`
- `LambdaDeclarator` has a child of type `DeclSpecs` named `DeclSpecs`
- `LambdaDeclarator` has a child of type `MaybeExceptionSpec` named `Throw`
- `LambdaDeclarator` has a child of type `TypeId` named `TrailingReturnType`
- `LambdaIntroducer` has a child of type `AnyCapture` named `LambdaCapture`
- `Capture` has a child of type `AnyExpr` named `Expr`
- `InitializedCapture` has a child of type `AnyExpr` named `Expr`
- `InitializedCapture` has a child of type `Initializers` named `Init`
- `TypeId` has a child of type `DeclSpecs` named `DeclSpecs`
- `TypeId` has a child of type `MaybeDeclarator` named `Declarator`
- `NewInitializer` has a child of type `Exprs` named `Args`
- `MemberInitializer` has a child of type `AnyName` named `Name`
- `MemberInitializer` has a child of type `Exprs` named `Args`
- `CtorInitializer` has a child of type `MemberInitializers` named `MemberInitializers`
- `ExceptionSpec` has a child of type `MaybeTypeId` named `TypeIds`
- `DenyThrowSpec` has a child of type `AnyExpr` named `Expr`

Each node only has the child mentioned in the above list. Do not create new child if it is not mentioned.

Following are the descriptions of each important node type -

-Node : The root of AST type hierarchy. Every other AST type inherits from Node.
-TranslationUnit : The source file (e.g. a .c or .cpp file). This node is always the top-most element of AST.
-DeclOrStmts : A sequence of declarations and statements. This type may also be used to represent optional declaration or statement (i.e. zero or one declaration or statement).
-AnyFuncBody : Abstract supertype for all types of function body.
-Handlers : A sequence of exception handlers.
-ExceptHandler : except handler in a try-except statement (Microsoft Visual C++ extension).
-FinallyHandler : finally handler in a try-finally statement (Microsoft Visual C++ extension).
-MaybeException : Abstract supertype for all types of exception declarations.
-TemplateParams : Comma-separated list of template parameters.
-DeclSpecs : A sequence of declaration specifiers. Also used to represent optional declaration specifier (i.e. zero or one declaration specifier). Type for representing declaration specifiers or absence of them
-AttributeSpecs : A sequence of attribute specifiers. Also used to represent optional attribute specifier (i.e. zero or one attribute specifier).
-Attributes : A sequence of attributes. (GCC / Micosoft Visual C++ extension).
-PropertyFuncs : Comma-separated list of property functions inside a property declspec. (Microsoft Visual C++ extension).
-MemberDecls : A sequence of member declarations inside class/struct/union type.
-Enumerators : Comma-separted list of enumerator definitions.
-MaybeDeclarator : Optional declarator.
-ParamNames : Comma-separated list of parameter names in old style (K&amp;R) function declarator.
-Initializers : Comma-separated list of initializers. Also used to represent optional initializer (i.e. zero or one initializer).
-Designators : A sequence of aggregate (array or struct) type element designators (GNU extension, C only). Also used to represent optional designator (i.e. zero or one designator).
-AnyLabel : Abstract supertype of all types of labels.
-Exprs : Comma-separated list of expressions. Also used to represent optional expression (i.e. zero or one expression).
-AnyNameQualifier : Abstract supertype for all types of name qualifiers.
-TemplateArgs : Type for representing template arguments or their absence
-BaseSpecs : Type for representing specifiers of class inheritance kind ('private', 'protected', 'public') or absence of such specifiers
-MaybeLambdaDeclarator : Type for representing specifications of lambda declarator
-LambdaIntroducer : Type for representing lambda captures
-AnyCapture : Type for representing different lambda captures
-MaybeTypeId : Type for representing type names with associated specifications or absence of those names
-MaybeNewInitializer : Type for representing initializers in "new" expressions or absence of such initializers
-MemberInitializers : Type for representing initializers of class members in constructors or absence of such initializers
-MaybeCtorInitializer : Type for representing initialization sections in constructors or absence of such sections
-MaybeExceptionSpec : Type for representing exception specifications in function declarations or absence of such specifications
-NoDeclOrStmt : Terminator node in a sequence of declarations and statements. This node may also be used to represent missing declaration or statement.
-DeclEllipsis : in a declaration of function with variable number of arguments. This node is always the last in a list of parameter declarations.
-DeclOrStmt : A declaration or a statement.
-AnyDecl : Abstract supertype for all types of declarations and definitions.
-AnyStmt : Abstract supertype for all types of statements.
-FuncDef : A function definition
-Decl : A declaration of variable(s), type or function.
-TemplateDecl : Template declaration. Note that both template declarations and partial specializations are represented as TemplateDecl nodes.
-LinkageSpec : Linkage specification.
-ExplicitInstantiation : Explicit template instantiation.
-NamespaceDecl : Namespace declaration.
-NamespaceAlias : Namespace alias declaration.
-AnyUsing : Abstract supertype for all types of using declarations.
-AliasDecl : C++0x template alias
-AsmDef : Assembler definition. Typically used to pass information through to an assembler.
-StaticAssertDecl : static_assert is used to trigger compiler errors with custom error messages.
-UnparsedDecl : A declaration that Klocwork analysis engine was not able to parse.
-UsingDecl : Using declaration.
-UsingDirective : Using directive.
-LabeledStmt : A labeled statement. The label is either an identifier that can be used as a target of goto statement, or case/default label inside a switch statement.
-ExprStmt : Expression statement. Note that empty statement (a semi-colon) is represented as expression statement with empty Expr child.
-CompoundStmt : Compound statement.
-IfStmt : An if statement.
-IfDeclStmt : An if statement with declaration in condition.
-SwitchStmt : A switch statement.
-SwitchDeclStmt : A switch statement with declaration in condition.
-WhileStmt : A while statement.
-WhileDeclStmt : A while statement with declaration in condition.
-DoStmt : A do-while statement.
-DoDeclStmt : A do-while statement with declaration in condition.
-ForStmt : A for statement.
-ForEachStmt : A for each statement.
-ForRangeStmt : c++0x for range statement.
-GotoStmt : goto statement.
-ContinueStmt : continue statement
-BreakStmt : break statement
-ReturnStmt : return statement
-TryStmt : A try block followed by a sequence of catch handlers.
-TryExceptStmt : try/except statement for handling structured exceptions (Microsoft Visual C++ extension).
-TryFinallyStmt : try/finally statement for handling structured exceptions (Microsoft Visual C++ extension).
-LeaveStmt : leave statement. Can only appear as inside guarded block of try/finally statement (Microsoft Visual C++ extension).
-AsmStmt : Assembler statement.
-UnparsedStmt : A statement Klocwork analysis engine was not able to parse.
-FuncBody : Function body.
-FuncTryBlock : Function try block. Only used when function is a constructor.
-PromisedFuncBody : Delayed parsing of function body.
-NoHandler : Terminator node in a sequence of exception handlers. Also used to represent missing exception handler.
-Handler : Exception handler.
-NoException : Empty exception declarator.
-Exception : Exception declaration.
-DefaultException : Exception declaration, that matches any exception.
-UnparsedException : Exception declaration Klocwork analysis engine was not able to parse.
-NoTemplateParam : Terminator node in a list of template parameters. Also used to represent missing template parameter.
-TemplateParam : Template parameter.
-AnyTypeParam : Root type for all types of template parameters.
-Param : Non-type template parameter.
-TypeParam : Type parameter of a template.
-TemplateTypeParam : Template type parameter of a template.
-NoDeclSpec : Terminator node in a sequence of declaration specifier. Also used to represent missing declaration specifier.
-DeclSpec : Root type for all types of declaration specifiers.
-AutoType : Decl specifier which means that the type will be computed from initializer expression
-ConstExpr : c++0x decl specifier to declare a constant-expression value
-StorageClass :
   Storage class specifier. One of:
    -typedef
    -extern
    -static
    -auto
    -register
    -mutable
    -thread_local
-AlignAsExpr : C++0x alignment specifier
-AlignAsType : C++0x alignment specifier
-AnyTypeName : Abstract supertype for all kinds of type names.
-FuncSpec : Function specifier. One of:
    -inline
    -virtual
    -explicit
    -friend
    
-AttributeDeclSpec : Attribute specifier as a declaration specifier. Used to represent GNU attrbutes (__attribute__), and Microsoft Visual C++ declspecs (declspec).
-UnparsedDeclSpec : A declaration specifier Klocwork analysis engine was not able to parse.
-CVQualifier : Type qualifier. One of:
    -const
    -volatile
    -restrict
     
-ReservedTypeSpec : Abstract supertype for all kinds of predefined types.
-TypeName : Name of user-defined (non-built-in) type as a declaration specifier.
-EnumType : Enumeration type.
-ClassType : struct/union/class declaration.
-AnyTypeOf : Abstract supertype of all kinds of typeof declaration specifiers (GCC extension).
-TypeAdjective : Signedness and range/size built-in type specifiers. One of:
     -short
     -long
     -signed
     -unsigned
-BuiltinType : Built-in type specifier. One of:
     -void
     -bool (C++ only)
     -char
     -wchar_t (C++ only)
     -int
     -float
     -double
     
-TypeOfExpr : typeof declaration specifier, applied to an expression (GCC extension).
-TypeOfType : typeof declaration specifier, applied to a type name (GCC extension).
-NoAttributeSpec : Terminator node in a sequence of attribute specifiers. Also used to represent missing attribute specifier.
-AttributeSpec : Attribute specifier. Used to represent GNU attrbutes (attribute), and Microsoft Visual C++ declspecs (declspec).
-NoAttribute : Terminator node in a sequence of attributes. Also used to represent missing attribute.
-AnyAttribute : Abstract supertype of all types of attributes.
-Attribute : A simple attribute (GCC / Microsoft Visual C++ extension).
-AttributeWithArgs : An attribute with arguments (GCC / Microsoft Visual C++ extension).
-PropertyAttribute : Property attrubute (Microsoft Visual C++ extension).
-GenericAttribute : Generic attrubute (clang extension).
-NoPropertyFunc : Terminator node in a list of property functions (Microsoft Visual C++ extension).
-AnyPropertyFunc : Abstract supertype for all types of property functions.
-PropertyPutFunc : Property put function (Microsoft Visual C++ extension.
-PropertyGetFunc : Property get function (Microsoft Visual C++ extension).
-UnparsedPropertyFunc : A property function Klocwork analysis engine was not able to parse.
-NoMemberDecl : Terminator node in a sequence of member declarations.
-AnyMemberDecl : Abstract supertype for all types of member declaration.
-MemberDecl : Member declaration inside class/struct/union type.
-MemberFunc : Definition of a member function.
-AccessSpecification : Access specification inside a class/struct/union. One of:
    -private
    -protected
    -public
    
-MemberTemplate : Member template declaration.
-MemberUsingDecl : Using declaration.
-UnparsedMemberDecl : A member declaration Klocwork analysis engine was not able to parse.
-PromisedMemberDecl : Delayed parsing of class body.
-NoEnumerator : Terminator node in a list of enumerator definitions.
-AnyEnumerator : Abstract supertype for all types of enumerator definition.
-Enumerator : Enumerator definition.
-UnparsedEnumerator : An enumerator Klocwork analysis engine was not able to parse.
-NoDeclarator : This node represents a missing declarator.
-AnyDeclarator : Abstract supertype for all types of declarators.
-AnyNonPtrDeclarator : Abstract supertype for all types of non-pointer declarators.
-PtrDeclarator : Declarator of a pointer or reference.
-BitFieldDeclarator : Declarator of a bit-field variable.
-AttributedDeclarator : Declarator with an attribute.
-InitializedDeclarator : Declarator with initializer.
-UnparsedDeclarator : A declarator that Klocwork analysis engine was not able to parse.
-NameDeclarator : Declarator for named variable/function/typedef.
-ParensDeclarator : Parenthesized declarator.
-ArrayDeclarator : Declarator of an array.
-FuncDeclarator : Declarator of a function. Specifies function name (optional in case of abstract function declarator), types of parameters, and affects function return type.
-KRFuncDeclarator : Old-style (Kernighan and Ritchie) function declaration.
-NoParamName : Terminator node in a list of function parameter names.
-AnyParamName : Abstract supertype for all types of function parameter names.
-ParamName : Parameter name in old-style (K&amp;R) function declarator.
-UnparsedParamName : Function parameter name Klocwork analysis engine was not able to parse.
-NoInitializer : Terminator in a list of initializer. Also used to represent missing initializer.
-AnyInitializer : Abstract supertype for all types of initializers.
-CopyInitializer : Simple initializer.
-InitClause : Aggregate type (array or struct/class) initializer.
-TruncatedInitClause : Node for aggregate type (array or struct/class) initializer exceeding TRUNCATE_INITS_THRESHOLD.
-DirectInitializer : Direct constructor call as an initializer.
-UnparsedInitializer : An initializer Klocwork analysis engine was not able to parse.
-NoDesignator : Terminator node in a sequence of aggregate type element designators. Also used to represent missing designator.
-AnyDesignator : Abstract supertype for all types of designators.
-FieldDesignator : struct field designator (GNU extension, C only).
-MemberDesignator : Old-style syntax for struct field designator (GNU extension, C only).
-IndexDesignator : Array element designator (GNU extension, C only).
-RangeDesignator : Designator of a range of array elements (GNU extension, C only).
-Label : A goto label.
-CaseLabel : case label in a switch statement.
-DefaultLabel : default label in a switch statement.
-CaseRangeLabel : case range label in a switch (GNU extension).
-UnparsedLabel : A label that the Klocwork analysis engine was not able to parse.
-NoExpr : Terminator node in a list of expressions. Also used to represent missing expression.
-AnyExpr : Abstract supertype for all types of expressions.
-IdExpr : A name as expression.
-BoolLiteralExpr : bool literal. One of: 
    -true
    -false
    
-LiteralExpr : Integer or character literal.
-UserLiteralExpr : Integer or character literal with user defined suffix.
-StringLiteralExpr : String literal. Note that several adjacent string literals form a single string.
-UserStringLiteralExpr : String literal with user defined suffix. Note that several adjacent string literals form a single string.
-NullptrLiteralExpr : nullptr literal.
-MemberExpr : Member access expression.
-CallExpr : Function call expression.
-TypeConvExpr : Explicit type conversion (functional notation). Constructs a value of specified type (typically through a call to constructor). If argument list is a single expression, type conversion expression is equivalent to the corresponding cast expression.
-IndexExpr : Subscript expression. The expression E1[E2] is identical to *((E1)+(E2)).
-UnaryExpr : Expression evaluated by applying one of the folowing unary (prefix or postfix) operators:
    -'+' (addition) 
    -'-' (negation)
    -'++' (preincrement)
    -'--' (predecrement)
    -'++' (postincrement)
    -'--' (postdecrement)
    -'!' (logical not)
    -'~' (bitwise not)
    -'&' (address of)
    -'*' (pointer dereference)
    -'sizeof' (sizeof operator)
    
-ThrowExpr : Throw expression.
-BinaryExpr : Expression evaluated by applying one of the following binary operators:
    
    -'+' (addition)
    -'-' (subtraction)
    -'*' (multiplication)
    -'/' (division)
    -'%' (remainder)
    -'==' (equal)
    -'!=' (not equal)
    -'lt' (less than)
    -'lt=' (less than or equal)
    -'gt' (greater than)
    -'gt=' (greater than or equal to)
    -'.*' dereference of pointer to member
    -'&' (bitwise and)
    -'|' (bitwise or)
    -'^' (bitwise xor)
    -'&&' (logical and)
    -'||' (logical or)
    -'=' (assignment)
    -'op=' assignment (op is one of: +, -, *, /, %, |, ^) 
    -',' (comma) sequence
    
-ConditionalExpr : Conditional expression.
-SizeOfExpr : sizeof operator applied to a type. Note, that sizeof applied to expression is represented as UnaryExpr.
-AlignOfExpr : The c++0x alignof expression yields the alignment requirement of its operand type. The operand shall be a type-id representing a complete object type.
-CastExpr : Explicit type conversion (cast notation).
-SpecialCastExpr : Explicit type convertion performed by one of the following operators:   
    -dynamic_cast
    -static_cast
    -reinterpret_cast
    -const_cast
    
-ParensExpr : Parenthesized expression.
-ThisExpr : this keyword.
-NewExpr : Expression evaluated by applying new operator. Creates a new object or array of specified type.
-DeleteExpr : delete operator. Destroys an object or array previously created by new operator.
-TypeTypeIdExpr : Type identification. typeid applied to a type.
-ExprTypeIdExpr : Type identification. typeid applied to an expression.
-StmtExpr : Compound statement enclosed in parentheses as an expression (GNU extension).
-InitializerExpr : Compound literals. A compound literal looks like a cast containing an initializer. Its value is an object of the type specified in the cast, containing the elements specified in the initializer
-LambdaExpr : An expression that specifies an anonymous function object
-UnparsedExpr : Expression Klocwork analysis engine was not able to parse.
-NoNameQualifier : Missing name qualifier.
-GlobalScope : Global scope resolution operator.
-SuperScope : Base class qualifier (Microsoft Visual C++ extension).
-AnyNameSpec : Abstract supertype for all types of name specifiers.
-NameSpec : Type for representing class names as scope qualifiers and base class specifications
-TemplateSpec : Type for representing template specifications as scope qualifiers and base class specification.
-TypeOfSpec : Type for representing decltype or typeof as scope qualifiers and base class specification.
-UnparsedNameQualifier : Type for storing information about errors in scope qualifiers
-NoName : Type for indicating absence of unqualified names
-AnyName : Type for representing unqualified names or their absence
-QualifiedName : Type for representing certain qualified names (with optional scope qualifiers)
-UnqualifiedName : Type for representing various unqualified names
-Name : Type for representing simple language names.
-Dtor : Type for representing names of class destructors.
-SuffixFunc : Type for representing names of user-defined literal suffixes.
-OpFunc : Type for representing names of functions assigned to substitute predefined operators.
-ConvFunc : Type for representing names of member functions assigned to convert class instances into built-in types values or instances of other classes.
-TemplateName : Type for representing template instantiations and specializations.
-AnyPseudoDtor : Type for representing names of built-in type "destructors".
-UnparsedName : Type for storing information about parse errors in unqualified identifiers
-PseudoDtor : Type for representing names of built-in type "destructors" without "base" specification.
-QualifiedPseudoDtor : Type for representing names of built-in type "destructors" together with "base" specification.
-NoTemplateArg : Type for representing absence of template arguments
-AnyTemplateArg : Type for representing arguments in template instantiations and specializations
-ExprArg : Type for representing expression arguments in template instantiations and specializations.
-TypeArg : Type for representing type names as arguments of template instantiations and specializations.
-TemplateTypeArg : Type for representing template names as arguments of other template instantiations and specializations.
-NoBaseSpec : Type for indicating absence of inheritance kind specifiers ('private', 'protected', 'public')
-BaseSpec : Type for representing specifiers of class inheritance kind ('private', 'protected', 'public')
-NoLambdaDeclarator : Type for indicating absence of lambda declarator
-LambdaDeclarator : Type for representing lamda declarator
-CaptureDefault : Type for representing default lambda capture
-Capture : Type for representing local variable captures
-nitializedCapture : Type for representing captures with an initializer
-NoCapture : Type for representing absence of capture
-NoTypeId : Type for indicating absence type names with associated specifications
-TypeId : Type for representing type names with associated specifications or absence of those names.
-NoNewInitializer : Type for indicating absence of initializers in "new" expressions
-NewInitializer : Type for representing initializers in "new" expressions.
-NoMemberInitializer : Type for indicating absence of member initializers in constructors
-MemberInitializer : Type for representing initializers of class members in constructors.
-NoCtorInitializer : Type for indicating absence of initialization sections in constructors
-CtorInitializer : Type for representing initialization sections in constructors.
-NoExceptionSpec : Type for indicating absence of exception specifications in function declarations
-ExceptionSpec : Type for representing exception specifications in function declarations.
-DenyThrowSpec : Type for representing c++0x noexcept specifications in function declarations.

KAST expression describes a location in AST. It is being defined in terms of elements of AST:

Klocwork analysis engine represents AST internally as a heterogeneous attributed tree, i.e. every tree node has a type, a number of attributes specific to this type and may reference other AST nodes, which are this node's children. Klocwork C/C++ AST defines over 200 types of nodes. Node types are organized into a hierarchy. The top of type hierarchy is Node - every other AST node type extends Node by adding attributes and/or children. The leaf types of the hierarchy represent concrete AST node types, created by Klocwork analysis engine. Non-leaf types are abstract, and used to group related AST types. 

A node can only be reached from one of its supertypes. The following list describes if the node is abstract or concrete and for abstract nodes, the subtypes. Concrete nodes are the leaves of the AST. So, they do not have any subtype.

Some of the node types have been deprecated and we should not use those types in the KAST expression.

-node AccessSpecification is a concrete node.
all supertypes of node type AccessSpecification are: AnyMemberDecl, MemberDecls, Node
-node AliasDecl is a concrete node.
all supertypes of node type AliasDecl are: AnyDecl, DeclOrStmt, DeclOrStmts, Node
-node AlignAsExpr is a concrete node.
all supertypes of node type AlignAsExpr are: DeclSpec, DeclSpecs, Node
-node AlignAsType is a concrete node.
all supertypes of node type AlignAsType are: DeclSpec, DeclSpecs, Node
-node AlignOfExpr is a concrete node.
all supertypes of node type AlignOfExpr are: AnyExpr, Exprs, Node
-node AnyAttribute is an abstract node.
all supertypes of node type AnyAttribute are: Attributes, Node
all subtypes of node type AnyAttribute are: Attribute, AttributeWithArgs, GenericAttribute, PropertyAttribute
-node AnyCapture is an abstract node.
all supertypes of node type AnyCapture are: Node
all subtypes of node type AnyCapture are: Capture, CaptureDefault, InitializedCapture
-node AnyDecl is an abstract node.
all supertypes of node type AnyDecl are: DeclOrStmt, DeclOrStmts, Node
all subtypes of node type AnyDecl are: AliasDecl, AnyUsing, AsmDef, Decl, ExplicitInstantiation, FuncDef, LinkageSpec, NamespaceAlias, NamespaceDecl, StaticAssertDecl, TemplateDecl, UnparsedDecl, UsingDecl, UsingDirective
-node AnyDeclarator is an abstract node.
all supertypes of node type AnyDeclarator are: MaybeDeclarator, Node
all subtypes of node type AnyDeclarator are: AnyNonPtrDeclarator, ArrayDeclarator, AttributedDeclarator, BitFieldDeclarator, FuncDeclarator, InitializedDeclarator, KRFuncDeclarator, NameDeclarator, ParensDeclarator, PtrDeclarator, UnparsedDeclarator
-node AnyDesignator is an abstract node.
all supertypes of node type AnyDesignator are: Designators, Node
all subtypes of node type AnyDesignator are: FieldDesignator, IndexDesignator, MemberDesignator, RangeDesignator
-node AnyDirectDeclarator is a deprecated node. Do not use it in the KAST expression
-node AnyEnumerator is an abstract node.
all supertypes of node type AnyEnumerator are: Enumerators, Node
all subtypes of node type AnyEnumerator are: Enumerator, UnparsedEnumerator
-node AnyExpr is an abstract node.
all supertypes of node type AnyExpr are: Exprs, Node
all subtypes of node type AnyExpr are: AlignOfExpr, BinaryExpr, BoolLiteralExpr, CallExpr, CastExpr, ConditionalExpr, DeleteExpr, ExprTypeIdExpr, IdExpr, IndexExpr, InitializerExpr, LambdaExpr, LiteralExpr, MemberExpr, NewExpr, NullptrLiteralExpr, ParensExpr, SizeOfExpr, SpecialCastExpr, StmtExpr, StringLiteralExpr, ThisExpr, ThrowExpr, TypeConvExpr, TypeTypeIdExpr, UnaryExpr, UnparsedExpr, UserLiteralExpr, UserStringLiteralExpr
-node AnyFuncBody is an abstract node.
all supertypes of node type AnyFuncBody are: Node
all subtypes of node type AnyFuncBody are: FuncBody, FuncTryBlock, PromisedFuncBody
-node AnyInitDeclarator is a deprecated node. Do not use it in the KAST expression
-node AnyInitializer is an abstract node.
all supertypes of node type AnyInitializer are: Initializers, Node
all subtypes of node type AnyInitializer are: CopyInitializer, DirectInitializer, InitClause, TruncatedInitClause, UnparsedInitializer
-node AnyLabel is an abstract node.
all supertypes of node type AnyLabel are: Node
all subtypes of node type AnyLabel are: CaseLabel, CaseRangeLabel, DefaultLabel, Label, UnparsedLabel
-node AnyMemberDecl is an abstract node.
all supertypes of node type AnyMemberDecl are: MemberDecls, Node
all subtypes of node type AnyMemberDecl are: AccessSpecification, MemberDecl, MemberFunc, MemberTemplate, MemberUsingDecl, PromisedMemberDecl, UnparsedMemberDecl
-node AnyMemberDeclarator is a deprecated node. Do not use it in the KAST expression
-node AnyName is an abstract node.
all supertypes of node type AnyName are: AnyNames, Node
all subtypes of node type AnyName are: AnyPseudoDtor, ConvFunc, Dtor, Name, OpFunc, PseudoDtor, QualifiedName, QualifiedPseudoDtor, SuffixFunc, TemplateName, UnparsedName, UnqualifiedName
-node AnyNameQualifier is an abstract node.
all supertypes of node type AnyNameQualifier are: Node
all subtypes of node type AnyNameQualifier are: AnyNameSpec, GlobalScope, NameSpec, SuperScope, TemplateSpec, TypeOfSpec, UnparsedNameQualifier
-node AnyNames is an abstract node.
all supertypes of node type AnyNames are: Node
all subtypes of node type AnyNames are: AnyName, AnyPseudoDtor, ConvFunc, Dtor, Name, OpFunc, PseudoDtor, QualifiedName, QualifiedPseudoDtor, SuffixFunc, TemplateName, UnparsedName, UnqualifiedName
-node AnyNameSpec is an abstract node.
all supertypes of node type AnyNameSpec are: AnyNameQualifier, Node
all subtypes of node type AnyNameSpec are: NameSpec, TemplateSpec, TypeOfSpec, UnparsedNameQualifier
-node AnyNonPtrDeclarator is an abstract node.
all supertypes of node type AnyNonPtrDeclarator are: AnyDeclarator, MaybeDeclarator, Node
all subtypes of node type AnyNonPtrDeclarator are: ArrayDeclarator, FuncDeclarator, KRFuncDeclarator, NameDeclarator, ParensDeclarator
-node AnyParamName is an abstract node.
all supertypes of node type AnyParamName are: Node, ParamNames
all subtypes of node type AnyParamName are: ParamName, UnparsedParamName
-node AnyPropertyFunc is an abstract node.
all supertypes of node type AnyPropertyFunc are: Node, PropertyFuncs
all subtypes of node type AnyPropertyFunc are: PropertyGetFunc, PropertyPutFunc, UnparsedPropertyFunc
-node AnyPseudoDtor is an abstract node.
all supertypes of node type AnyPseudoDtor are: AnyName, AnyNames, Node, UnqualifiedName
all subtypes of node type AnyPseudoDtor are: PseudoDtor, QualifiedPseudoDtor
-node AnyQualifiedName is a deprecated node. Do not use it in the KAST expression
-node AnyStmt is an abstract node.
all supertypes of node type AnyStmt are: DeclOrStmt, DeclOrStmts, Node
all subtypes of node type AnyStmt are: AsmStmt, BreakStmt, CompoundStmt, ContinueStmt, DoDeclStmt, DoStmt, ExprStmt, ForEachStmt, ForRangeStmt, ForStmt, GotoStmt, IfDeclStmt, IfStmt, LabeledStmt, LeaveStmt, ReturnStmt, SwitchDeclStmt, SwitchStmt, TryExceptStmt, TryFinallyStmt, TryStmt, UnparsedStmt, WhileDeclStmt, WhileStmt
-node AnyTemplateArg is an abstract node.
all supertypes of node type AnyTemplateArg are: Node, TemplateArgs
all subtypes of node type AnyTemplateArg are: ExprArg, TemplateTypeArg, TypeArg
-node AnyTypeId is a deprecated node. Do not use it in the KAST expression
-node AnyTypeName is an abstract node.
all supertypes of node type AnyTypeName are: DeclSpec, DeclSpecs, Node
all subtypes of node type AnyTypeName are: AnyTypeOf, BuiltinType, CVQualifier, ClassType, EnumType, ReservedTypeSpec, TypeAdjective, TypeName, TypeOfExpr, TypeOfType
-node AnyTypeOf is an abstract node.
all supertypes of node type AnyTypeOf are: AnyTypeName, DeclSpec, DeclSpecs, Node
all subtypes of node type AnyTypeOf are: TypeOfExpr, TypeOfType
-node AnyTypeParam is an abstract node.
all supertypes of node type AnyTypeParam are: Node, TemplateParam, TemplateParams
all subtypes of node type AnyTypeParam are: TemplateTypeParam, TypeParam
-node AnyUsing is an abstract node.
all supertypes of node type AnyUsing are: AnyDecl, DeclOrStmt, DeclOrStmts, Node
all subtypes of node type AnyUsing are: UsingDecl, UsingDirective
-node ArrayDeclarator is a concrete node.
all supertypes of node type ArrayDeclarator are: AnyDeclarator, AnyNonPtrDeclarator, MaybeDeclarator, Node
-node AsmDef is a concrete node.
all supertypes of node type AsmDef are: AnyDecl, DeclOrStmt, DeclOrStmts, Node
-node AsmStmt is a concrete node.
all supertypes of node type AsmStmt are: AnyStmt, DeclOrStmt, DeclOrStmts, Node
-node Attribute is a concrete node.
all supertypes of node type Attribute are: AnyAttribute, Attributes, Node
-node AttributedDeclarator is a concrete node.
all supertypes of node type AttributedDeclarator are: AnyDeclarator, MaybeDeclarator, Node
-node AttributeDeclSpec is a concrete node.
all supertypes of node type AttributeDeclSpec are: DeclSpec, DeclSpecs, Node
-node Attributes is an abstract node.
all supertypes of node type Attributes are: Node
all subtypes of node type Attributes are: AnyAttribute, Attribute, AttributeWithArgs, GenericAttribute, PropertyAttribute
-node AttributeSpec is a concrete node.
all supertypes of node type AttributeSpec are: AttributeSpecs, Node
-node AttributeSpecs is an abstract node.
all supertypes of node type AttributeSpecs are: Node
all subtypes of node type AttributeSpecs are: AttributeSpec
-node AttributeWithArgs is a concrete node.
all supertypes of node type AttributeWithArgs are: AnyAttribute, Attributes, Node
-node AutoType is a concrete node.
all supertypes of node type AutoType are: DeclSpec, DeclSpecs, Node
-node BaseSpec is a concrete node.
all supertypes of node type BaseSpec are: BaseSpecs, Node
-node BaseSpecs is an abstract node.
all supertypes of node type BaseSpecs are: Node
all subtypes of node type BaseSpecs are: BaseSpec
-node BinaryExpr is a concrete node.
all supertypes of node type BinaryExpr are: AnyExpr, Exprs, Node
-node BitFieldDeclarator is a concrete node.
all supertypes of node type BitFieldDeclarator are: AnyDeclarator, MaybeDeclarator, Node
-node BoolLiteralExpr is a concrete node.
all supertypes of node type BoolLiteralExpr are: AnyExpr, Exprs, Node
-node BreakStmt is a concrete node.
all supertypes of node type BreakStmt are: AnyStmt, DeclOrStmt, DeclOrStmts, Node
-node BuiltinType is a concrete node.
all supertypes of node type BuiltinType are: AnyTypeName, DeclSpec, DeclSpecs, Node, ReservedTypeSpec
-node CallExpr is a concrete node.
all supertypes of node type CallExpr are: AnyExpr, Exprs, Node
-node Capture is a concrete node.
all supertypes of node type Capture are: AnyCapture, Node
-node CaptureDefault is a concrete node.
all supertypes of node type CaptureDefault are: AnyCapture, Node
-node CaseLabel is a concrete node.
all supertypes of node type CaseLabel are: AnyLabel, Node
-node CaseRangeLabel is a concrete node.
all supertypes of node type CaseRangeLabel are: AnyLabel, Node
-node CastExpr is a concrete node.
all supertypes of node type CastExpr are: AnyExpr, Exprs, Node
-node ClassType is a concrete node.
all supertypes of node type ClassType are: AnyTypeName, DeclSpec, DeclSpecs, Node
-node CommentStmt is a concrete node.
all supertypes of node type CommentStmt are: Node
-node CompoundStmt is a concrete node.
all supertypes of node type CompoundStmt are: AnyStmt, DeclOrStmt, DeclOrStmts, Node
-node ConditionalExpr is a concrete node.
all supertypes of node type ConditionalExpr are: AnyExpr, Exprs, Node
-node ConstExpr is a concrete node.
all supertypes of node type ConstExpr are: DeclSpec, DeclSpecs, Node
-node ContinueStmt is a concrete node.
all supertypes of node type ContinueStmt are: AnyStmt, DeclOrStmt, DeclOrStmts, Node
-node ConvFunc is a concrete node.
all supertypes of node type ConvFunc are: AnyName, AnyNames, Node, UnqualifiedName
-node ConvTypeId is a deprecated node. Do not use it in the KAST expression
-node CopyInitializer is a concrete node.
all supertypes of node type CopyInitializer are: AnyInitializer, Initializers, Node
-node CtorInitializer is a concrete node.
all supertypes of node type CtorInitializer are: MaybeCtorInitializer, Node
-node CVQualifier is a concrete node.
all supertypes of node type CVQualifier are: AnyTypeName, DeclSpec, DeclSpecs, Node
-node Decl is a concrete node.
all supertypes of node type Decl are: AnyDecl, DeclOrStmt, DeclOrStmts, Node
-node Declarator is a deprecated node. Do not use it in the KAST expression
-node DeclEllipsis is a concrete node.
all supertypes of node type DeclEllipsis are: DeclOrStmts, Node
-node DeclOrStmt is an abstract node.
all supertypes of node type DeclOrStmt are: DeclOrStmts, Node
all subtypes of node type DeclOrStmt are: AliasDecl, AnyDecl, AnyStmt, AnyUsing, AsmDef, AsmStmt, BreakStmt, CompoundStmt, ContinueStmt, Decl, DoDeclStmt, DoStmt, ExplicitInstantiation, ExprStmt, ForEachStmt, ForRangeStmt, ForStmt, FuncDef, GotoStmt, IfDeclStmt, IfStmt, LabeledStmt, LeaveStmt, LinkageSpec, NamespaceAlias, NamespaceDecl, ReturnStmt, StaticAssertDecl, SwitchDeclStmt, SwitchStmt, TemplateDecl, TryExceptStmt, TryFinallyStmt, TryStmt, UnparsedDecl, UnparsedStmt, UsingDecl, UsingDirective, WhileDeclStmt, WhileStmt
-node DeclOrStmts is an abstract node.
all supertypes of node type DeclOrStmts are: Node
all subtypes of node type DeclOrStmts are: AliasDecl, AnyDecl, AnyStmt, AnyUsing, AsmDef, AsmStmt, BreakStmt, CompoundStmt, ContinueStmt, Decl, DeclEllipsis, DeclOrStmt, DoDeclStmt, DoStmt, ExplicitInstantiation, ExprStmt, ForEachStmt, ForRangeStmt, ForStmt, FuncDef, GotoStmt, IfDeclStmt, IfStmt, LabeledStmt, LeaveStmt, LinkageSpec, NamespaceAlias, NamespaceDecl, ReturnStmt, StaticAssertDecl, SwitchDeclStmt, SwitchStmt, TemplateDecl, TryExceptStmt, TryFinallyStmt, TryStmt, UnparsedDecl, UnparsedStmt, UsingDecl, UsingDirective, WhileDeclStmt, WhileStmt
-node DeclSpec is an abstract node.
all supertypes of node type DeclSpec are: DeclSpecs, Node
all subtypes of node type DeclSpec are: AlignAsExpr, AlignAsType, AnyTypeName, AnyTypeOf, AttributeDeclSpec, AutoType, BuiltinType, CVQualifier, ClassType, ConstExpr, EnumType, FuncSpec, ReservedTypeSpec, StorageClass, TypeAdjective, TypeName, TypeOfExpr, TypeOfType, UnparsedDeclSpec
-node DeclSpecs is an abstract node.
all supertypes of node type DeclSpecs are: Node
all subtypes of node type DeclSpecs are: AlignAsExpr, AlignAsType, AnyTypeName, AnyTypeOf, AttributeDeclSpec, AutoType, BuiltinType, CVQualifier, ClassType, ConstExpr, DeclSpec, EnumType, FuncSpec, ReservedTypeSpec, StorageClass, TypeAdjective, TypeName, TypeOfExpr, TypeOfType, UnparsedDeclSpec
-node DefaultException is a concrete node.
all supertypes of node type DefaultException are: MaybeException, Node
-node DefaultLabel is a concrete node.
all supertypes of node type DefaultLabel are: AnyLabel, Node
-node DeleteExpr is a concrete node.
all supertypes of node type DeleteExpr are: AnyExpr, Exprs, Node
-node DenyThrowSpec is a concrete node.
all supertypes of node type DenyThrowSpec are: MaybeExceptionSpec, Node
-node Designators is an abstract node.
all supertypes of node type Designators are: Node
all subtypes of node type Designators are: AnyDesignator, FieldDesignator, IndexDesignator, MemberDesignator, RangeDesignator
-node DirectDeclarator is a deprecated node. Do not use it in the KAST expression
-node DirectInitializer is a concrete node.
all supertypes of node type DirectInitializer are: AnyInitializer, Initializers, Node
-node DirectNewDeclarator is a deprecated node. Do not use it in the KAST expression
-node DoDeclStmt is a concrete node.
all supertypes of node type DoDeclStmt are: AnyStmt, DeclOrStmt, DeclOrStmts, Node
-node DoStmt is a concrete node.
all supertypes of node type DoStmt are: AnyStmt, DeclOrStmt, DeclOrStmts, Node
-node Dtor is a concrete node.
all supertypes of node type Dtor are: AnyName, AnyNames, Node, UnqualifiedName
-node Enumerator is a concrete node.
all supertypes of node type Enumerator are: AnyEnumerator, Enumerators, Node
-node Enumerators is an abstract node.
all supertypes of node type Enumerators are: Node
all subtypes of node type Enumerators are: AnyEnumerator, Enumerator, UnparsedEnumerator
-node EnumType is a concrete node.
all supertypes of node type EnumType are: AnyTypeName, DeclSpec, DeclSpecs, Node
-node ExceptHandler is a concrete node.
all supertypes of node type ExceptHandler are: Node
-node Exception is a concrete node.
all supertypes of node type Exception are: MaybeException, Node
-node ExceptionSpec is a concrete node.
all supertypes of node type ExceptionSpec are: MaybeExceptionSpec, Node
-node ExplicitInstantiation is a concrete node.
all supertypes of node type ExplicitInstantiation are: AnyDecl, DeclOrStmt, DeclOrStmts, Node
-node ExprArg is a concrete node.
all supertypes of node type ExprArg are: AnyTemplateArg, Node, TemplateArgs
-node Exprs is an abstract node.
all supertypes of node type Exprs are: Node
all subtypes of node type Exprs are: AlignOfExpr, AnyExpr, BinaryExpr, BoolLiteralExpr, CallExpr, CastExpr, ConditionalExpr, DeleteExpr, ExprTypeIdExpr, IdExpr, IndexExpr, InitializerExpr, LambdaExpr, LiteralExpr, MemberExpr, NewExpr, NullptrLiteralExpr, ParensExpr, SizeOfExpr, SpecialCastExpr, StmtExpr, StringLiteralExpr, ThisExpr, ThrowExpr, TypeConvExpr, TypeTypeIdExpr, UnaryExpr, UnparsedExpr, UserLiteralExpr, UserStringLiteralExpr
-node ExprStmt is a concrete node.
all supertypes of node type ExprStmt are: AnyStmt, DeclOrStmt, DeclOrStmts, Node
-node ExprTypeIdExpr is a concrete node.
all supertypes of node type ExprTypeIdExpr are: AnyExpr, Exprs, Node
-node FieldDesignator is a concrete node.
all supertypes of node type FieldDesignator are: AnyDesignator, Designators, Node
-node FinallyHandler is a concrete node.
all supertypes of node type FinallyHandler are: Node
-node ForEachStmt is a concrete node.
all supertypes of node type ForEachStmt are: AnyStmt, DeclOrStmt, DeclOrStmts, Node
-node ForRangeStmt is a concrete node.
all supertypes of node type ForRangeStmt are: AnyStmt, DeclOrStmt, DeclOrStmts, Node
-node ForStmt is a concrete node.
all supertypes of node type ForStmt are: AnyStmt, DeclOrStmt, DeclOrStmts, Node
-node FuncBody is a concrete node.
all supertypes of node type FuncBody are: AnyFuncBody, Node
-node FuncDeclarator is a concrete node.
all supertypes of node type FuncDeclarator are: AnyDeclarator, AnyNonPtrDeclarator, MaybeDeclarator, Node
-node FuncDef is a concrete node.
all supertypes of node type FuncDef are: AnyDecl, DeclOrStmt, DeclOrStmts, Node
-node FuncSpec is a concrete node.
all supertypes of node type FuncSpec are: DeclSpec, DeclSpecs, Node
-node FuncTryBlock is a concrete node.
all supertypes of node type FuncTryBlock are: AnyFuncBody, Node
-node GenericAttribute is a concrete node.
all supertypes of node type GenericAttribute are: AnyAttribute, Attributes, Node
-node GlobalScope is a concrete node.
all supertypes of node type GlobalScope are: AnyNameQualifier, Node
-node GotoStmt is a concrete node.
all supertypes of node type GotoStmt are: AnyStmt, DeclOrStmt, DeclOrStmts, Node
-node Handler is a concrete node.
all supertypes of node type Handler are: Handlers, Node
-node Handlers is an abstract node.
all supertypes of node type Handlers are: Node
all subtypes of node type Handlers are: Handler
-node IdExpr is a concrete node.
all supertypes of node type IdExpr are: AnyExpr, Exprs, Node
-node IfDeclStmt is a concrete node.
all supertypes of node type IfDeclStmt are: AnyStmt, DeclOrStmt, DeclOrStmts, Node
-node IfStmt is a concrete node.
all supertypes of node type IfStmt are: AnyStmt, DeclOrStmt, DeclOrStmts, Node
-node IndexDesignator is a concrete node.
all supertypes of node type IndexDesignator are: AnyDesignator, Designators, Node
-node IndexExpr is a concrete node.
all supertypes of node type IndexExpr are: AnyExpr, Exprs, Node
-node InitClause is a concrete node.
all supertypes of node type InitClause are: AnyInitializer, Initializers, Node
-node InitDeclarator is a deprecated node. Do not use it in the KAST expression
-node InitDeclarators is a deprecated node. Do not use it in the KAST expression
-node InitializedCapture is a concrete node.
all supertypes of node type InitializedCapture are: AnyCapture, Node
-node InitializedDeclarator is a concrete node.
all supertypes of node type InitializedDeclarator are: AnyDeclarator, MaybeDeclarator, Node
-node InitializerExpr is a concrete node.
all supertypes of node type InitializerExpr are: AnyExpr, Exprs, Node
-node Initializers is an abstract node.
all supertypes of node type Initializers are: Node
all subtypes of node type Initializers are: AnyInitializer, CopyInitializer, DirectInitializer, InitClause, TruncatedInitClause, UnparsedInitializer
-node KRFuncDeclarator is a concrete node.
all supertypes of node type KRFuncDeclarator are: AnyDeclarator, AnyNonPtrDeclarator, MaybeDeclarator, Node
-node Label is a concrete node.
all supertypes of node type Label are: AnyLabel, Node
-node LabeledStmt is a concrete node.
all supertypes of node type LabeledStmt are: AnyStmt, DeclOrStmt, DeclOrStmts, Node
-node LambdaDeclarator is a concrete node.
all supertypes of node type LambdaDeclarator are: MaybeLambdaDeclarator, Node
-node LambdaExpr is a concrete node.
all supertypes of node type LambdaExpr are: AnyExpr, Exprs, Node
-node LambdaIntroducer is a concrete node.
all supertypes of node type LambdaIntroducer are: Node
-node LeaveStmt is a concrete node.
all supertypes of node type LeaveStmt are: AnyStmt, DeclOrStmt, DeclOrStmts, Node
-node LinkageSpec is a concrete node.
all supertypes of node type LinkageSpec are: AnyDecl, DeclOrStmt, DeclOrStmts, Node
-node LiteralExpr is a concrete node.
all supertypes of node type LiteralExpr are: AnyExpr, Exprs, Node
-node MaybeCtorInitializer is an abstract node.
all supertypes of node type MaybeCtorInitializer are: Node
all subtypes of node type MaybeCtorInitializer are: CtorInitializer
-node MaybeDeclarator is an abstract node.
all supertypes of node type MaybeDeclarator are: Node
all subtypes of node type MaybeDeclarator are: AnyDeclarator, AnyNonPtrDeclarator, ArrayDeclarator, AttributedDeclarator, BitFieldDeclarator, FuncDeclarator, InitializedDeclarator, KRFuncDeclarator, NameDeclarator, ParensDeclarator, PtrDeclarator, UnparsedDeclarator
-node MaybeDirectNewDeclarator is a deprecated node. Do not use it in the KAST expression
-node MaybeException is an abstract node.
all supertypes of node type MaybeException are: Node
all subtypes of node type MaybeException are: DefaultException, Exception, UnparsedException
-node MaybeExceptionSpec is an abstract node.
all supertypes of node type MaybeExceptionSpec are: Node
all subtypes of node type MaybeExceptionSpec are: DenyThrowSpec, ExceptionSpec
-node MaybeLambdaDeclarator is an abstract node.
all supertypes of node type MaybeLambdaDeclarator are: Node
all subtypes of node type MaybeLambdaDeclarator are: LambdaDeclarator
-node MaybeNewDeclarator is a deprecated node. Do not use it in the KAST expression
-node MaybeNewInitializer is an abstract node.
all supertypes of node type MaybeNewInitializer are: Node
all subtypes of node type MaybeNewInitializer are: NewInitializer
-node MaybeTypeId is an abstract node.
all supertypes of node type MaybeTypeId are: Node
all subtypes of node type MaybeTypeId are: TypeId
-node MemberDecl is a concrete node.
all supertypes of node type MemberDecl are: AnyMemberDecl, MemberDecls, Node
-node MemberDeclarator is a deprecated node. Do not use it in the KAST expression
-node MemberDeclarators is a deprecated node. Do not use it in the KAST expression
-node MemberDecls is an abstract node.
all supertypes of node type MemberDecls are: Node
all subtypes of node type MemberDecls are: AccessSpecification, AnyMemberDecl, MemberDecl, MemberFunc, MemberTemplate, MemberUsingDecl, PromisedMemberDecl, UnparsedMemberDecl
-node MemberDesignator is a concrete node.
all supertypes of node type MemberDesignator are: AnyDesignator, Designators, Node
-node MemberExpr is a concrete node.
all supertypes of node type MemberExpr are: AnyExpr, Exprs, Node
-node MemberFunc is a concrete node.
all supertypes of node type MemberFunc are: AnyMemberDecl, MemberDecls, Node
-node MemberInitializer is a concrete node.
all supertypes of node type MemberInitializer are: MemberInitializers, Node
-node MemberInitializers is an abstract node.
all supertypes of node type MemberInitializers are: Node
all subtypes of node type MemberInitializers are: MemberInitializer
-node MemberTemplate is a concrete node.
all supertypes of node type MemberTemplate are: AnyMemberDecl, MemberDecls, Node
-node MemberUsingDecl is a concrete node.
all supertypes of node type MemberUsingDecl are: AnyMemberDecl, MemberDecls, Node
-node Name is a concrete node.
all supertypes of node type Name are: AnyName, AnyNames, Node, UnqualifiedName
-node NameDeclarator is a concrete node.
all supertypes of node type NameDeclarator are: AnyDeclarator, AnyNonPtrDeclarator, MaybeDeclarator, Node
-node NamespaceAlias is a concrete node.
all supertypes of node type NamespaceAlias are: AnyDecl, DeclOrStmt, DeclOrStmts, Node
-node NamespaceDecl is a concrete node.
all supertypes of node type NamespaceDecl are: AnyDecl, DeclOrStmt, DeclOrStmts, Node
-node NameSpec is a concrete node.
all supertypes of node type NameSpec are: AnyNameQualifier, AnyNameSpec, Node
-node NewDeclarator is a concrete node.
all supertypes of node type NewDeclarator are: MaybeNewDeclarator, Node
-node NewExpr is a concrete node.
all supertypes of node type NewExpr are: AnyExpr, Exprs, Node
-node NewInitializer is a concrete node.
all supertypes of node type NewInitializer are: MaybeNewInitializer, Node
-node NewTypeId is a deprecated node. Do not use it in the KAST expression
-node Node is an abstract node.
all subtypes of node type Node are: AccessSpecification, AliasDecl, AlignAsExpr, AlignAsType, AlignOfExpr, AnyAttribute, AnyCapture, AnyDecl, AnyDeclarator, AnyDesignator, AnyEnumerator, AnyExpr, AnyFuncBody, AnyInitializer, AnyLabel, AnyMemberDecl, AnyName, AnyNameQualifier, AnyNameSpec, AnyNames, AnyNonPtrDeclarator, AnyParamName, AnyPropertyFunc, AnyPseudoDtor, AnyStmt, AnyTemplateArg, AnyTypeName, AnyTypeOf, AnyTypeParam, AnyUsing, ArrayDeclarator, AsmDef, AsmStmt, Attribute, AttributeDeclSpec, AttributeSpec, AttributeSpecs, AttributeWithArgs, AttributedDeclarator, Attributes, AutoType, BaseSpec, BaseSpecs, BinaryExpr, BitFieldDeclarator, BoolLiteralExpr, BreakStmt, BuiltinType, CVQualifier, CallExpr, Capture, CaptureDefault, CaseLabel, CaseRangeLabel, CastExpr, ClassType, CompoundStmt, ConditionalExpr, ConstExpr, ContinueStmt, ConvFunc, CopyInitializer, CtorInitializer, Decl, DeclEllipsis, DeclOrStmt, DeclOrStmts, DeclSpec, DeclSpecs, DefaultException, DefaultLabel, DeleteExpr, DenyThrowSpec, Designators, DirectInitializer, DoDeclStmt, DoStmt, Dtor, EnumType, Enumerator, Enumerators, ExceptHandler, Exception, ExceptionSpec, ExplicitInstantiation, ExprArg, ExprStmt, ExprTypeIdExpr, Exprs, FieldDesignator, FinallyHandler, ForEachStmt, ForRangeStmt, ForStmt, FuncBody, FuncDeclarator, FuncDef, FuncSpec, FuncTryBlock, GenericAttribute, GlobalScope, GotoStmt, Handler, Handlers, IdExpr, IfDeclStmt, IfStmt, IndexDesignator, IndexExpr, InitClause, InitializedCapture, InitializedDeclarator, InitializerExpr, Initializers, KRFuncDeclarator, Label, LabeledStmt, LambdaDeclarator, LambdaExpr, LambdaIntroducer, LeaveStmt, LinkageSpec, LiteralExpr, MaybeCtorInitializer, MaybeDeclarator, MaybeException, MaybeExceptionSpec, MaybeLambdaDeclarator, MaybeNewInitializer, MaybeTypeId, MemberDecl, MemberDecls, MemberDesignator, MemberExpr, MemberFunc, MemberInitializer, MemberInitializers, MemberTemplate, MemberUsingDecl, Name, NameDeclarator, NameSpec, NamespaceAlias, NamespaceDecl, NewExpr, NewInitializer, NullptrLiteralExpr, OpFunc, Param, ParamName, ParamNames, ParensDeclarator, ParensExpr, PromisedFuncBody, PromisedMemberDecl, PropertyAttribute, PropertyFuncs, PropertyGetFunc, PropertyPutFunc, PseudoDtor, PtrDeclarator, QualifiedName, QualifiedPseudoDtor, RangeDesignator, ReservedTypeSpec, ReturnStmt, SizeOfExpr, SpecialCastExpr, StaticAssertDecl, StmtExpr, StorageClass, StringLiteralExpr, SuffixFunc, SuperScope, SwitchDeclStmt, SwitchStmt, TemplateArgs, TemplateDecl, TemplateName, TemplateParam, TemplateParams, TemplateSpec, TemplateTypeArg, TemplateTypeParam, ThisExpr, ThrowExpr, TranslationUnit, TruncatedInitClause, TryExceptStmt, TryFinallyStmt, TryStmt, TypeAdjective, TypeArg, TypeConvExpr, TypeId, TypeName, TypeOfExpr, TypeOfSpec, TypeOfType, TypeParam, TypeTypeIdExpr, UnaryExpr, UnparsedDecl, UnparsedDeclSpec, UnparsedDeclarator, UnparsedEnumerator, UnparsedException, UnparsedExpr, UnparsedInitializer, UnparsedLabel, UnparsedMemberDecl, UnparsedName, UnparsedNameQualifier, UnparsedParamName, UnparsedPropertyFunc, UnparsedStmt, UnqualifiedName, UserLiteralExpr, UserStringLiteralExpr, UsingDecl, UsingDirective, WhileDeclStmt, WhileStmt
-node NullptrLiteralExpr is a concrete node.
all supertypes of node type NullptrLiteralExpr are: AnyExpr, Exprs, Node
-node Op is a deprecated node. Do not use it in the KAST expression
-node OpFunc is a concrete node.
all supertypes of node type OpFunc are: AnyName, AnyNames, Node, UnqualifiedName
-node Param is a concrete node.
all supertypes of node type Param are: Node, TemplateParam, TemplateParams
-node ParamName is a concrete node.
all supertypes of node type ParamName are: AnyParamName, Node, ParamNames
-node ParamNames is an abstract node.
all supertypes of node type ParamNames are: Node
all subtypes of node type ParamNames are: AnyParamName, ParamName, UnparsedParamName
-node ParensDeclarator is a concrete node.
all supertypes of node type ParensDeclarator are: AnyDeclarator, AnyNonPtrDeclarator, MaybeDeclarator, Node
-node ParensExpr is a concrete node.
all supertypes of node type ParensExpr are: AnyExpr, Exprs, Node
-node PreprHash is a concrete node.
all supertypes of node type PreprHash are: Node
-node PromisedFuncBody is a concrete node.
all supertypes of node type PromisedFuncBody are: AnyFuncBody, Node
-node PromisedMemberDecl is a concrete node.
all supertypes of node type PromisedMemberDecl are: AnyMemberDecl, MemberDecls, Node
-node PropertyAttribute is a concrete node.
all supertypes of node type PropertyAttribute are: AnyAttribute, Attributes, Node
-node PropertyFuncs is an abstract node.
all supertypes of node type PropertyFuncs are: Node
all subtypes of node type PropertyFuncs are: AnyPropertyFunc, PropertyGetFunc, PropertyPutFunc, UnparsedPropertyFunc
-node PropertyGetFunc is a concrete node.
all supertypes of node type PropertyGetFunc are: AnyPropertyFunc, Node, PropertyFuncs
-node PropertyPutFunc is a concrete node.
all supertypes of node type PropertyPutFunc are: AnyPropertyFunc, Node, PropertyFuncs
-node PseudoDtor is a concrete node.
all supertypes of node type PseudoDtor are: AnyName, AnyNames, AnyPseudoDtor, Node, UnqualifiedName
-node Ptr is a deprecated node. Do not use it in the KAST expression
-node PtrDeclarator is a concrete node.
all supertypes of node type PtrDeclarator are: AnyDeclarator, MaybeDeclarator, Node
-node Ptrs is a deprecated node. Do not use it in the KAST expression
-node QualifiedName is a concrete node.
all supertypes of node type QualifiedName are: AnyName, AnyNames, Node
-node QualifiedNames is a deprecated node. Do not use it in the KAST expression
-node QualifiedPseudoDtor is a concrete node.
all supertypes of node type QualifiedPseudoDtor are: AnyName, AnyNames, AnyPseudoDtor, Node, UnqualifiedName
-node RangeDesignator is a concrete node.
all supertypes of node type RangeDesignator are: AnyDesignator, Designators, Node
-node ReservedTypeSpec is an abstract node.
all supertypes of node type ReservedTypeSpec are: AnyTypeName, DeclSpec, DeclSpecs, Node
all subtypes of node type ReservedTypeSpec are: BuiltinType, TypeAdjective
-node ReturnStmt is a concrete node.
all supertypes of node type ReturnStmt are: AnyStmt, DeclOrStmt, DeclOrStmts, Node
-node SizeOfExpr is a concrete node.
all supertypes of node type SizeOfExpr are: AnyExpr, Exprs, Node
-node SpecialCastExpr is a concrete node.
all supertypes of node type SpecialCastExpr are: AnyExpr, Exprs, Node
-node StaticAssertDecl is a concrete node.
all supertypes of node type StaticAssertDecl are: AnyDecl, DeclOrStmt, DeclOrStmts, Node
-node StmtExpr is a concrete node.
all supertypes of node type StmtExpr are: AnyExpr, Exprs, Node
-node StorageClass is a concrete node.
all supertypes of node type StorageClass are: DeclSpec, DeclSpecs, Node
-node StringLiteralExpr is a concrete node.
all supertypes of node type StringLiteralExpr are: AnyExpr, Exprs, Node
-node SuffixFunc is a concrete node.
all supertypes of node type SuffixFunc are: AnyName, AnyNames, Node, UnqualifiedName
-node SuperScope is a concrete node.
all supertypes of node type SuperScope are: AnyNameQualifier, Node
-node SwitchDeclStmt is a concrete node.
all supertypes of node type SwitchDeclStmt are: AnyStmt, DeclOrStmt, DeclOrStmts, Node
-node SwitchStmt is a concrete node.
all supertypes of node type SwitchStmt are: AnyStmt, DeclOrStmt, DeclOrStmts, Node
-node teAccessSpecifier_attr is a concrete node.
-node teArrayDeclaratorSizeKind_attr is a concrete node.
-node teAttribute_attr is a concrete node.
-node teBoolValue_attr is a concrete node.
-node teBuiltin_attr is a concrete node.
-node teCastSpecifier_attr is a concrete node.
-node teClass_attr is a concrete node.
-node teDeclarationOrDefinitionFlag_attr is a concrete node.
-node teDefaultedFunction_attr is a concrete node.
-node teEnum_attr is a concrete node.
-node teFinalClass_attr is a concrete node.
-node teFunctionSpecifier_attr is a concrete node.
-node teLambdaCaptureType_attr is a concrete node.
-node TemplateArgs is an abstract node.
all supertypes of node type TemplateArgs are: Node
all subtypes of node type TemplateArgs are: AnyTemplateArg, ExprArg, TemplateTypeArg, TypeArg
-node TemplateDecl is a concrete node.
all supertypes of node type TemplateDecl are: AnyDecl, DeclOrStmt, DeclOrStmts, Node
-node TemplateName is a concrete node.
all supertypes of node type TemplateName are: AnyName, AnyNames, Node, UnqualifiedName
-node TemplateParam is an abstract node.
all supertypes of node type TemplateParam are: Node, TemplateParams
all subtypes of node type TemplateParam are: AnyTypeParam, Param, TemplateTypeParam, TypeParam
-node TemplateParams is an abstract node.
all supertypes of node type TemplateParams are: Node
all subtypes of node type TemplateParams are: AnyTypeParam, Param, TemplateParam, TemplateTypeParam, TypeParam
-node TemplateSpec is a concrete node.
all supertypes of node type TemplateSpec are: AnyNameQualifier, AnyNameSpec, Node
-node TemplateTypeArg is a concrete node.
all supertypes of node type TemplateTypeArg are: AnyTemplateArg, Node, TemplateArgs
-node TemplateTypeParam is a concrete node.
all supertypes of node type TemplateTypeParam are: AnyTypeParam, Node, TemplateParam, TemplateParams
-node teOperation_attr is a concrete node.
-node tePointerOperator_attr is a concrete node.
-node teStorClass_attr is a concrete node.
-node teTypeAdj_attr is a concrete node.
-node teTypeParamSpec_attr is a concrete node.
-node teTypeQual_attr is a concrete node.
-node teVirtualSpecifier_attr is a concrete node.
-node ThisExpr is a concrete node.
all supertypes of node type ThisExpr are: AnyExpr, Exprs, Node
-node ThrowExpr is a concrete node.
all supertypes of node type ThrowExpr are: AnyExpr, Exprs, Node
-node TranslationUnit is a concrete node.
all supertypes of node type TranslationUnit are: Node
-node TruncatedInitClause is a concrete node.
all supertypes of node type TruncatedInitClause are: AnyInitializer, Initializers, Node
-node TryExceptStmt is a concrete node.
all supertypes of node type TryExceptStmt are: AnyStmt, DeclOrStmt, DeclOrStmts, Node
-node TryFinallyStmt is a concrete node.
all supertypes of node type TryFinallyStmt are: AnyStmt, DeclOrStmt, DeclOrStmts, Node
-node TryStmt is a concrete node.
all supertypes of node type TryStmt are: AnyStmt, DeclOrStmt, DeclOrStmts, Node
-node TypeAdjective is a concrete node.
all supertypes of node type TypeAdjective are: AnyTypeName, DeclSpec, DeclSpecs, Node, ReservedTypeSpec
-node TypeArg is a concrete node.
all supertypes of node type TypeArg are: AnyTemplateArg, Node, TemplateArgs
-node TypeConvExpr is a concrete node.
all supertypes of node type TypeConvExpr are: AnyExpr, Exprs, Node
-node TypeId is a concrete node.
all supertypes of node type TypeId are: MaybeTypeId, Node
-node TypeName is a concrete node.
all supertypes of node type TypeName are: AnyTypeName, DeclSpec, DeclSpecs, Node
-node TypeOfExpr is a concrete node.
all supertypes of node type TypeOfExpr are: AnyTypeName, AnyTypeOf, DeclSpec, DeclSpecs, Node
-node TypeOfSpec is a concrete node.
all supertypes of node type TypeOfSpec are: AnyNameQualifier, AnyNameSpec, Node
-node TypeOfType is a concrete node.
all supertypes of node type TypeOfType are: AnyTypeName, AnyTypeOf, DeclSpec, DeclSpecs, Node
-node TypeParam is a concrete node.
all supertypes of node type TypeParam are: AnyTypeParam, Node, TemplateParam, TemplateParams
-node TypeTypeIdExpr is a concrete node.
all supertypes of node type TypeTypeIdExpr are: AnyExpr, Exprs, Node
-node UnaryExpr is a concrete node.
all supertypes of node type UnaryExpr are: AnyExpr, Exprs, Node
-node UnparsedDecl is a concrete node.
all supertypes of node type UnparsedDecl are: AnyDecl, DeclOrStmt, DeclOrStmts, Node
-node UnparsedDeclarator is a concrete node.
all supertypes of node type UnparsedDeclarator are: AnyDeclarator, MaybeDeclarator, Node
-node UnparsedDeclSpec is a concrete node.
all supertypes of node type UnparsedDeclSpec are: DeclSpec, DeclSpecs, Node
-node UnparsedDirectDeclarator is a deprecated node. Do not use it in the KAST expression
-node UnparsedEnumerator is a concrete node.
all supertypes of node type UnparsedEnumerator are: AnyEnumerator, Enumerators, Node
-node UnparsedException is a concrete node.
all supertypes of node type UnparsedException are: MaybeException, Node
-node UnparsedExpr is a concrete node.
all supertypes of node type UnparsedExpr are: AnyExpr, Exprs, Node
-node UnparsedInitDeclarator is a deprecated node. Do not use it in the KAST expression
-node UnparsedInitializer is a concrete node.
all supertypes of node type UnparsedInitializer are: AnyInitializer, Initializers, Node
-node UnparsedLabel is a concrete node.
all supertypes of node type UnparsedLabel are: AnyLabel, Node
-node UnparsedMemberDecl is a concrete node.
all supertypes of node type UnparsedMemberDecl are: AnyMemberDecl, MemberDecls, Node
-node UnparsedMemberDeclarator is a deprecated node. Do not use it in the KAST expression
-node UnparsedName is a concrete node.
all supertypes of node type UnparsedName are: AnyName, AnyNames, Node, UnqualifiedName
-node UnparsedNameQualifier is a concrete node.
all supertypes of node type UnparsedNameQualifier are: AnyNameQualifier, AnyNameSpec, Node
-node UnparsedParamName is a concrete node.
all supertypes of node type UnparsedParamName are: AnyParamName, Node, ParamNames
-node UnparsedPropertyFunc is a concrete node.
all supertypes of node type UnparsedPropertyFunc are: AnyPropertyFunc, Node, PropertyFuncs
-node UnparsedPtr is a deprecated node. Do not use it in the KAST expression
-node UnparsedQualifiedName is a deprecated node. Do not use it in the KAST expression
-node UnparsedStmt is a concrete node.
all supertypes of node type UnparsedStmt are: AnyStmt, DeclOrStmt, DeclOrStmts, Node
-node UnqualifiedName is an abstract node.
all supertypes of node type UnqualifiedName are: AnyName, AnyNames, Node
all subtypes of node type UnqualifiedName are: AnyPseudoDtor, ConvFunc, Dtor, Name, OpFunc, PseudoDtor, QualifiedPseudoDtor, SuffixFunc, TemplateName, UnparsedName
-node UserLiteralExpr is a concrete node.
all supertypes of node type UserLiteralExpr are: AnyExpr, Exprs, Node
-node UserStringLiteralExpr is a concrete node.
all supertypes of node type UserStringLiteralExpr are: AnyExpr, Exprs, Node
-node UsingDecl is a concrete node.
all supertypes of node type UsingDecl are: AnyDecl, AnyUsing, DeclOrStmt, DeclOrStmts, Node
-node UsingDirective is a concrete node.
all supertypes of node type UsingDirective are: AnyDecl, AnyUsing, DeclOrStmt, DeclOrStmts, Node
-node WhileDeclStmt is a concrete node.
all supertypes of node type WhileDeclStmt are: AnyStmt, DeclOrStmt, DeclOrStmts, Node
-node WhileStmt is a concrete node.
all supertypes of node type WhileStmt are: AnyStmt, DeclOrStmt, DeclOrStmts, Node


Two types of children are used in C/C++ AST:
	-normal child - a reference to a single AST node
	-compound child - references a sequence of AST nodes
Empty compound child is valid element of AST and is used to represent empty or optional sequence of nodes. There is one special AST node type - Null - to represent (optional) normal child, which is missing. If node 'x' is a compound child that references a sequence of AST nodes and we are trying to match a particular type from that sequence, namely - 'y', then the expression should be -
"x[*]::y".

Following list identifies the "compound" and "normal" nodes.

-node AccessSpecification is not a compound node.
-node AliasDecl is not a compound node.
-node AlignAsExpr is not a compound node.
-node AlignAsType is not a compound node.
-node AlignOfExpr is not a compound node.
-node AnyAttribute is not a compound node.
-node AnyCapture is not a compound node.
-node AnyDecl is not a compound node.
-node AnyDeclarator is not a compound node.
-node AnyDesignator is not a compound node.
-node AnyEnumerator is not a compound node.
-node AnyExpr is not a compound node.
-node AnyFuncBody is not a compound node.
-node AnyInitializer is not a compound node.
-node AnyLabel is not a compound node.
-node AnyMemberDecl is not a compound node.
-node AnyName is not a compound node.
-node AnyNameQualifier is not a compound node.
-node AnyNames is a compound node.
-node AnyNameSpec is not a compound node.
-node AnyNonPtrDeclarator is not a compound node.
-node AnyParamName is not a compound node.
-node AnyPropertyFunc is not a compound node.
-node AnyPseudoDtor is not a compound node.
-node AnyStmt is not a compound node.
-node AnyTemplateArg is not a compound node.
-node AnyTypeName is not a compound node.
-node AnyTypeOf is not a compound node.
-node AnyTypeParam is not a compound node.
-node AnyUsing is not a compound node.
-node ArrayDeclarator is not a compound node.
-node AsmDef is not a compound node.
-node AsmStmt is not a compound node.
-node Attribute is not a compound node.
-node AttributedDeclarator is not a compound node.
-node AttributeDeclSpec is not a compound node.
-node Attributes is a compound node.
-node AttributeSpec is not a compound node.
-node AttributeSpecs is a compound node.
-node AttributeWithArgs is not a compound node.
-node AutoType is not a compound node.
-node BaseSpec is not a compound node.
-node BaseSpecs is a compound node.
-node BinaryExpr is not a compound node.
-node BitFieldDeclarator is not a compound node.
-node BoolLiteralExpr is not a compound node.
-node BreakStmt is not a compound node.
-node BuiltinType is not a compound node.
-node CallExpr is not a compound node.
-node Capture is not a compound node.
-node CaptureDefault is not a compound node.
-node CaseLabel is not a compound node.
-node CaseRangeLabel is not a compound node.
-node CastExpr is not a compound node.
-node ClassType is not a compound node.
-node CommentStmt is not a compound node.
-node CompoundStmt is not a compound node.
-node ConditionalExpr is not a compound node.
-node ConstExpr is not a compound node.
-node ContinueStmt is not a compound node.
-node ConvFunc is not a compound node.
-node CopyInitializer is not a compound node.
-node CtorInitializer is not a compound node.
-node CVQualifier is not a compound node.
-node Decl is not a compound node.
-node DeclEllipsis is not a compound node.
-node DeclOrStmt is not a compound node.
-node DeclOrStmts is a compound node.
-node DeclSpec is not a compound node.
-node DeclSpecs is a compound node.
-node DefaultException is not a compound node.
-node DefaultLabel is not a compound node.
-node DeleteExpr is not a compound node.
-node DenyThrowSpec is not a compound node.
-node Designators is a compound node.
-node DirectInitializer is not a compound node.
-node DoDeclStmt is not a compound node.
-node DoStmt is not a compound node.
-node Dtor is not a compound node.
-node Enumerator is not a compound node.
-node Enumerators is a compound node.
-node EnumType is not a compound node.
-node ExceptHandler is not a compound node.
-node Exception is not a compound node.
-node ExceptionSpec is not a compound node.
-node ExplicitInstantiation is not a compound node.
-node ExprArg is not a compound node.
-node Exprs is a compound node.
-node ExprStmt is not a compound node.
-node ExprTypeIdExpr is not a compound node.
-node FieldDesignator is not a compound node.
-node FinallyHandler is not a compound node.
-node ForEachStmt is not a compound node.
-node ForRangeStmt is not a compound node.
-node ForStmt is not a compound node.
-node FuncBody is not a compound node.
-node FuncDeclarator is not a compound node.
-node FuncDef is not a compound node.
-node FuncSpec is not a compound node.
-node FuncTryBlock is not a compound node.
-node GenericAttribute is not a compound node.
-node GlobalScope is not a compound node.
-node GotoStmt is not a compound node.
-node Handler is not a compound node.
-node Handlers is a compound node.
-node IdExpr is not a compound node.
-node IfDeclStmt is not a compound node.
-node IfStmt is not a compound node.
-node IndexDesignator is not a compound node.
-node IndexExpr is not a compound node.
-node InitClause is not a compound node.
-node InitializedCapture is not a compound node.
-node InitializedDeclarator is not a compound node.
-node InitializerExpr is not a compound node.
-node Initializers is a compound node.
-node KRFuncDeclarator is not a compound node.
-node Label is not a compound node.
-node LabeledStmt is not a compound node.
-node LambdaDeclarator is not a compound node.
-node LambdaExpr is not a compound node.
-node LambdaIntroducer is not a compound node.
-node LeaveStmt is not a compound node.
-node LinkageSpec is not a compound node.
-node LiteralExpr is not a compound node.
-node MaybeCtorInitializer is not a compound node.
-node MaybeDeclarator is not a compound node.
-node MaybeException is not a compound node.
-node MaybeExceptionSpec is not a compound node.
-node MaybeLambdaDeclarator is not a compound node.
-node MaybeNewInitializer is not a compound node.
-node MaybeTypeId is not a compound node.
-node MemberDecl is not a compound node.
-node MemberDecls is a compound node.
-node MemberDesignator is not a compound node.
-node MemberExpr is not a compound node.
-node MemberFunc is not a compound node.
-node MemberInitializer is not a compound node.
-node MemberInitializers is a compound node.
-node MemberTemplate is not a compound node.
-node MemberUsingDecl is not a compound node.
-node Name is not a compound node.
-node NameDeclarator is not a compound node.
-node NamespaceAlias is not a compound node.
-node NamespaceDecl is not a compound node.
-node NameSpec is not a compound node.
-node NewDeclarator is not a compound node.
-node NewExpr is not a compound node.
-node NewInitializer is not a compound node.
-node Node is not a compound node.
-node NullptrLiteralExpr is not a compound node.
-node OpFunc is not a compound node.
-node Param is not a compound node.
-node ParamName is not a compound node.
-node ParamNames is a compound node.
-node ParensDeclarator is not a compound node.
-node ParensExpr is not a compound node.
-node PreprHash is not a compound node.
-node PromisedFuncBody is not a compound node.
-node PromisedMemberDecl is not a compound node.
-node PropertyAttribute is not a compound node.
-node PropertyFuncs is a compound node.
-node PropertyGetFunc is not a compound node.
-node PropertyPutFunc is not a compound node.
-node PseudoDtor is not a compound node.
-node PtrDeclarator is not a compound node.
-node QualifiedName is not a compound node.
-node QualifiedPseudoDtor is not a compound node.
-node RangeDesignator is not a compound node.
-node ReservedTypeSpec is not a compound node.
-node ReturnStmt is not a compound node.
-node SizeOfExpr is not a compound node.
-node SpecialCastExpr is not a compound node.
-node StaticAssertDecl is not a compound node.
-node StmtExpr is not a compound node.
-node StorageClass is not a compound node.
-node StringLiteralExpr is not a compound node.
-node SuffixFunc is not a compound node.
-node SuperScope is not a compound node.
-node SwitchDeclStmt is not a compound node.
-node SwitchStmt is not a compound node.
-node teAccessSpecifier_attr is not a compound node.
-node teArrayDeclaratorSizeKind_attr is not a compound node.
-node teAttribute_attr is not a compound node.
-node teBoolValue_attr is not a compound node.
-node teBuiltin_attr is not a compound node.
-node teCastSpecifier_attr is not a compound node.
-node teClass_attr is not a compound node.
-node teDeclarationOrDefinitionFlag_attr is not a compound node.
-node teDefaultedFunction_attr is not a compound node.
-node teEnum_attr is not a compound node.
-node teFinalClass_attr is not a compound node.
-node teFunctionSpecifier_attr is not a compound node.
-node teLambdaCaptureType_attr is not a compound node.
-node TemplateArgs is a compound node.
-node TemplateDecl is not a compound node.
-node TemplateName is not a compound node.
-node TemplateParam is not a compound node.
-node TemplateParams is a compound node.
-node TemplateSpec is not a compound node.
-node TemplateTypeArg is not a compound node.
-node TemplateTypeParam is not a compound node.
-node teOperation_attr is not a compound node.
-node tePointerOperator_attr is not a compound node.
-node teStorClass_attr is not a compound node.
-node teTypeAdj_attr is not a compound node.
-node teTypeParamSpec_attr is not a compound node.
-node teTypeQual_attr is not a compound node.
-node teVirtualSpecifier_attr is not a compound node.
-node ThisExpr is not a compound node.
-node ThrowExpr is not a compound node.
-node TranslationUnit is not a compound node.
-node TruncatedInitClause is not a compound node.
-node TryExceptStmt is not a compound node.
-node TryFinallyStmt is not a compound node.
-node TryStmt is not a compound node.
-node TypeAdjective is not a compound node.
-node TypeArg is not a compound node.
-node TypeConvExpr is not a compound node.
-node TypeId is not a compound node.
-node TypeName is not a compound node.
-node TypeOfExpr is not a compound node.
-node TypeOfSpec is not a compound node.
-node TypeOfType is not a compound node.
-node TypeParam is not a compound node.
-node TypeTypeIdExpr is not a compound node.
-node UnaryExpr is not a compound node.
-node UnparsedDecl is not a compound node.
-node UnparsedDeclarator is not a compound node.
-node UnparsedDeclSpec is not a compound node.
-node UnparsedEnumerator is not a compound node.
-node UnparsedException is not a compound node.
-node UnparsedExpr is not a compound node.
-node UnparsedInitializer is not a compound node.
-node UnparsedLabel is not a compound node.
-node UnparsedMemberDecl is not a compound node.
-node UnparsedName is not a compound node.
-node UnparsedNameQualifier is not a compound node.
-node UnparsedParamName is not a compound node.
-node UnparsedPropertyFunc is not a compound node.
-node UnparsedStmt is not a compound node.
-node UnqualifiedName is not a compound node.
-node UserLiteralExpr is not a compound node.
-node UserStringLiteralExpr is not a compound node.
-node UsingDecl is not a compound node.
-node UsingDirective is not a compound node.
-node WhileDeclStmt is not a compound node.
-node WhileStmt is not a compound node.

When a KAST expression contains more than one step, every subsequent step has to specify a child name. Why type of the AST node is not enough? Because a single AST node may have multiple children of the same type (e.g. an if statement both branches of which are compound statements), and the type of child node can not be used to uniquely identify the path to follow. Child names are unique and unambiguously specify direction of traversal.

If node 'a' has child of type 'b' named 'c' and node 'c' has child of type 'd' named 'e', then following expressions are valid:
- //a[b::c]
- //a[descendant::e]
- //e[ancestor::a]
- //c[d::e]

But following expression is invalid:
- //a[d::e]

Certain nodes have attributes, which can be accessed using the @ operator followed by the attribute's name. Here is a list of nodes and their attributes (one attribute per line):

- `LinkageSpec` has an attribute of type `tStringRef` named `String`
- `NamespaceDecl` has an attribute of type `ident_t` named `Id`
- `NamespaceAlias` has an attribute of type `ident_t` named `Id`
- `StaticAssertDecl` has an attribute of type `tStringRef` named `String`
- `GotoStmt` has an attribute of type `ident_t` named `Label`
- `PromisedFuncBody` has an attribute of type `sema_tpClassContext` named `SemaContext`
- `PromisedFuncBody` has an attribute of type `parser_tpClassContext` named `ParserContext`
- `PromisedFuncBody` has an attribute of type `short` named `IsProcessed`
- `TypeParam` has an attribute of type `teTypeParamSpec` named `Spec`
- `StorageClass` has an attribute of type `teStorClass` named `Spec`
- `CVQualifier` has an attribute of type `teTypeQual` named `Spec`
- `TypeAdjective` has an attribute of type `teTypeAdj` named `Spec`
- `BuiltinType` has an attribute of type `teBuiltin` named `Spec`
- `EnumType` has an attribute of type `teDeclarationOrDefinitionFlag` named `IsDeclaration`
- `EnumType` has an attribute of type `teEnum` named `Tag`
- `ClassType` has an attribute of type `teClass` named `Tag`
- `ClassType` has an attribute of type `teDeclarationOrDefinitionFlag` named `IsDeclaration`
- `ClassType` has an attribute of type `teFinalClass` named `Final`
- `FuncSpec` has an attribute of type `teFunctionSpecifier` named `Spec`
- `AnyAttribute` has an attribute of type `teAttribute` named `Name`
- `AttributeWithArgs` has an attribute of type `ident_t` named `Id`
- `PropertyPutFunc` has an attribute of type `ident_t` named `Id`
- `PropertyGetFunc` has an attribute of type `ident_t` named `Id`
- `AccessSpecification` has an attribute of type `teAccessSpecifier` named `Access`
- `PromisedMemberDecl` has an attribute of type `sema_tpClassContext` named `SemaContext`
- `PromisedMemberDecl` has an attribute of type `parser_tpClassContext` named `ParserContext`
- `PromisedMemberDecl` has an attribute of type `short` named `IsProcessed`
- `Enumerator` has an attribute of type `ident_t` named `Id`
- `ArrayDeclarator` has an attribute of type `teArrayDeclaratorSizeKind` named `SizeKind`
- `FuncDeclarator` has an attribute of type `teDefaultedFunction` named `Defaulted`
- `PtrDeclarator` has an attribute of type `tePointerOperator` named `Spec`
- `ParamName` has an attribute of type `ident_t` named `Id`
- `TruncatedInitClause` has an attribute of type `inits_count_t` named `inits_count`
- `FieldDesignator` has an attribute of type `ident_t` named `Id`
- `MemberDesignator` has an attribute of type `ident_t` named `Id`
- `Label` has an attribute of type `ident_t` named `Id`
- `BoolLiteralExpr` has an attribute of type `teBoolValue` named `Value`
- `LiteralExpr` has an attribute of type `tValue` named `Value`
- `UserLiteralExpr` has an attribute of type `ident_t` named `Suffix`
- `UserLiteralExpr` has an attribute of type `tValue` named `Value`
- `StringLiteralExpr` has an attribute of type `tStringRef` named `Value`
- `UserStringLiteralExpr` has an attribute of type `ident_t` named `Suffix`
- `MemberExpr` has an attribute of type `teOperation` named `Op`
- `UnaryExpr` has an attribute of type `teOperation` named `Op`
- `BinaryExpr` has an attribute of type `teOperation` named `Op`
- `SpecialCastExpr` has an attribute of type `teCastSpecifier` named `Cast`
- `Name` has an attribute of type `ident_t` named `Id`
- `OpFunc` has an attribute of type `teOperation` named `Op`
- `BaseSpec` has an attribute of type `teVirtualSpecifier` named `Virtual`
- `BaseSpec` has an attribute of type `teAccessSpecifier` named `Access` 

Where:
 - Type `teAccessSpecifier` can have one of the following values: `KTC_ACCESSSPECIFIER_NONE`, `KTC_ACCESSSPECIFIER_PRIVATE`, `KTC_ACCESSSPECIFIER_PROTECTED`, `KTC_ACCESSSPECIFIER_PUBLIC`
 - Type `teArrayDeclaratorSizeKind` can have one of the following values: `KTC_ARRAYDECLSIZEKIND_NONE`, `KTC_ARRAYDECLSIZEKIND_STATIC`
 - Type `teAttribute` can have one of the following values: `KTC_ATTRIBUTE_UNKNOWN`, `KTC_ATTRIBUTE_NORETURN`, `KTC_ATTRIBUTE_NOINLINE`, `KTC_ATTRIBUTE_ALWAYS_INLINE`, `KTC_ATTRIBUTE_PURE`, `KTC_ATTRIBUTE_CONST`, `KTC_ATTRIBUTE_NOTHROW`, `KTC_ATTRIBUTE_FORMAT`, `KTC_ATTRIBUTE_FORMAT_ARG`, `KTC_ATTRIBUTE_NONNULL`, `KTC_ATTRIBUTE_NO_INSTRUMENT_FUNCTION`, `KTC_ATTRIBUTE_SECTION`, `KTC_ATTRIBUTE_CONSTRUCTOR`, `KTC_ATTRIBUTE_DESTRUCTOR`, `KTC_ATTRIBUTE_UNUSED`, `KTC_ATTRIBUTE_USED`, `KTC_ATTRIBUTE_DEPRECATED`, `KTC_ATTRIBUTE_WARN_RESULT_UNUSED`, `KTC_ATTRIBUTE_WEAK`, `KTC_ATTRIBUTE_MALLOC`, `KTC_ATTRIBUTE_ALIAS`, `KTC_ATTRIBUTE_VISIBILITY`, `KTC_ATTRIBUTE_REGPARM`, `KTC_ATTRIBUTE_STDCALL`, `KTC_ATTRIBUTE_FASTCALL`, `KTC_ATTRIBUTE_CDECL`, `KTC_ATTRIBUTE_LONGCALL`, `KTC_ATTRIBUTE_SHORTCALL`, `KTC_ATTRIBUTE_FUNCTION_VECTOR`, `KTC_ATTRIBUTE_INTERRUPT`, `KTC_ATTRIBUTE_INTERRUPT_HANDLER`, `KTC_ATTRIBUTE_SP_SWITCH`, `KTC_ATTRIBUTE_TRAP_EXIT`, `KTC_ATTRIBUTE_EIGHTBIT_DATA`, `KTC_ATTRIBUTE_TINY_DATA`, `KTC_ATTRIBUTE_SAVECALL`, `KTC_ATTRIBUTE_SIGNAL`, `KTC_ATTRIBUTE_NAKED`, `KTC_ATTRIBUTE_MODEL`, `KTC_ATTRIBUTE_FAR`, `KTC_ATTRIBUTE_NEAR`, `KTC_ATTRIBUTE_DLLIMPORT`, `KTC_ATTRIBUTE_DLLEXPORT`, `KTC_ATTRIBUTE_ALIGNED`, `KTC_ATTRIBUTE_CLEANUP`, `KTC_ATTRIBUTE_COMMON`, `KTC_ATTRIBUTE_NOCOMMON`, `KTC_ATTRIBUTE_MODE`, `KTC_ATTRIBUTE_PACKED`, `KTC_ATTRIBUTE_SHARED`, `KTC_ATTRIBUTE_TLS_MODEL`, `KTC_ATTRIBUTE_TRANSPARENT_UNION`, `KTC_ATTRIBUTE_MS_STRUCT`, `KTC_ATTRIBUTE_GCC_STRUCT`, `KTC_ATTRIBUTE_INIT_PRIORITY`, `KTC_ATTRIBUTE_MAY_ALIAS`, `KTC_ATTRIBUTE_JAVA_INTERFACE`, `KTC_ATTRIBUTE_STRONG`, `KTC_ATTRIBUTE_ALTIVEC` 
 - Type `teBoolValue` can have one of the following values: `KTC_BOOLVALUE_FALSE`, `KTC_BOOLVALUE_TRUE`
 - Type `teBuiltin` can have one of the following values: `KTC_BUILTINTYPE_NONE`, `KTC_BUILTINTYPE_VOID`, `KTC_BUILTINTYPE_BOOL`, `KTC_BUILTINTYPE_WCHAR_T`, `KTC_BUILTINTYPE_CHAR`, `KTC_BUILTINTYPE_SIGNEDCHAR`, `KTC_BUILTINTYPE_UNSIGNEDCHAR`, `KTC_BUILTINTYPE_SHORTINT`, `KTC_BUILTINTYPE_SIGNEDSHORTINT`, `KTC_BUILTINTYPE_UNSIGNEDSHORTINT`, `KTC_BUILTINTYPE_INT`, `KTC_BUILTINTYPE_SIGNEDINT`, `KTC_BUILTINTYPE_UNSIGNEDINT`, `KTC_BUILTINTYPE_LONGINT`, `KTC_BUILTINTYPE_SIGNEDLONGINT`, `KTC_BUILTINTYPE_UNSIGNEDLONGINT`, `KTC_BUILTINTYPE_LONGLONGINT`, `KTC_BUILTINTYPE_SIGNEDLONGLONGINT`, `KTC_BUILTINTYPE_UNSIGNEDLONGLONGINT`, `KTC_BUILTINTYPE_FLOAT`, `KTC_BUILTINTYPE_DOUBLE`, `KTC_BUILTINTYPE_LONGDOUBLE`, `KTC_BUILTINTYPE_CHAR16`, `KTC_BUILTINTYPE_CHAR32`, `KTC_BUILTINTYPE_NULLPTR_T`, `KTC_BUILTINTYPE_MAXIMUMBUILTINNUMBER`
 - Type `teCastSpecifier` can have one of the following values: `KTC_CASTSPECIFIER_DYNAMIC`, `KTC_CASTSPECIFIER_STATIC`, `KTC_CASTSPECIFIER_REINTERPRET`, `KTC_CASTSPECIFIER_CONST`
 - Type `teClass` can have one of the following values: `KTC_CLASSTAG_NONE`, `KTC_CLASSTAG_STRUCT`, `KTC_CLASSTAG_UNION`, `KTC_CLASSTAG_CLASS`
 - Type `teDeclarationOrDefinitionFlag` can have one of the following values: `KTC_DECLORDEFLAG_DECLARATION`, `KTC_DECLORDEFLAG_DEFINITION`
 - Type `teDefaultedFunction` can have one of the following values: `KTC_FUNCTION_DEFAULT_NONE`, `KTC_FUNCTION_DEFAULT_DEFAULTED`, `KTC_FUNCTION_DEFAULT_DELETED`
 - Type `teEnum` can have one of the following values: `KTC_ENUMTAG_NONE`, `KTC_ENUMTAG_ENUM`, `KTC_ENUMTAG_ENUMCLASS`, `KTC_ENUMTAG_ENUMSTRUCT`
 - Type `teFinalClass` can have one of the following values: `KTC_FINAL_CLASS_NONE`, `KTC_FINAL_CLASS_FINAL`
 - Type `teFunctionSpecifier` can have one of the following values: `KTC_FUNCSPECIFIER_NONE`, `KTC_FUNCSPECIFIER_INLINE`, `KTC_FUNCSPECIFIER_VIRTUAL`, `KTC_FUNCSPECIFIER_EXPLICIT`, `KTC_FUNCSPECIFIER_FRIEND`
 - Type `teOperation` can have one of the following values: `KTC_OPCODE_NONE`, `KTC_OPCODE_ASSIGN`, `KTC_OPCODE_MULASSIGN`, `KTC_OPCODE_DIVASSIGN`, `KTC_OPCODE_MODASSIGN`, `KTC_OPCODE_ADDASSIGN`, `KTC_OPCODE_SUBASSIGN`, `KTC_OPCODE_ASLASSIGN`, `KTC_OPCODE_ASRASSIGN`, `KTC_OPCODE_ANDASSIGN`, `KTC_OPCODE_XORASSIGN`, `KTC_OPCODE_ORASSIGN`, `KTC_OPCODE_COMMA`, `KTC_OPCODE_COND`, `KTC_OPCODE_LOGOR`, `KTC_OPCODE_LOGAND`, `KTC_OPCODE_BITOR`, `KTC_OPCODE_BITXOR`, `KTC_OPCODE_BITAND`, `KTC_OPCODE_EQ`, `KTC_OPCODE_NE`, `KTC_OPCODE_LT`, `KTC_OPCODE_GT`, `KTC_OPCODE_LE`, `KTC_OPCODE_GE`, `KTC_OPCODE_ASR`, `KTC_OPCODE_ASL`, `KTC_OPCODE_ADD`, `KTC_OPCODE_SUB`, `KTC_OPCODE_MUL`, `KTC_OPCODE_DIV`, `KTC_OPCODE_MOD`, `KTC_OPCODE_CAST`, `KTC_OPCODE_PREINC`, `KTC_OPCODE_PREDEC`, `KTC_OPCODE_SIZEOF`, `KTC_OPCODE_DEREF`, `KTC_OPCODE_ADDRESS`, `KTC_OPCODE_PLUS`, `KTC_OPCODE_MINUS`, `KTC_OPCODE_BITNOT`, `KTC_OPCODE_LOGNOT`, `KTC_OPCODE_POSTINC`, `KTC_OPCODE_POSTDEC`, `KTC_OPCODE_FIELD`, `KTC_OPCODE_FIELDREF`, `KTC_OPCODE_NEW`, `KTC_OPCODE_NEW_ARRAY`, `KTC_OPCODE_DELETE`, `KTC_OPCODE_DELETE_ARRAY`, `KTC_OPCODE_DOTAST`, `KTC_OPCODE_DEREFAST`, `KTC_OPCODE_ROUND_BRACKETS`, `KTC_OPCODE_SQUARE_BRACKETS`, `KTC_OPCODE_THROW`, `KTC_OPCODE_MIN`, `KTC_OPCODE_MAX`, `KTC_OPCODE_NOEXCEPT`, `KTC_OPCODE_MAXIMUM_OPERATOR_NUMBER`
 - Type `tePointerOperator` can have one of the following values: `KTC_POINTEROPERATOR_NONE`, `KTC_POINTEROPERATOR_POINTER`, `KTC_POINTEROPERATOR_REFERENCE`, `KTC_POINTEROPERATOR_RVALUE`
 - Type `teStorClass` can have one of the following values: `KTC_STORAGECLASS_NONE`, `KTC_STORAGECLASS_TYPEDEF`, `KTC_STORAGECLASS_EXTERN`, `KTC_STORAGECLASS_STATIC`, `KTC_STORAGECLASS_AUTO`, `KTC_STORAGECLASS_REGISTER`, `KTC_STORAGECLASS_MUTABLE`, `KTC_STORAGECLASS_THREADLOCAL`
 - Type `teTypeAdj` can have one of the following values: `KTC_ADJECTIVE_SIGNED`, `KTC_ADJECTIVE_UNSIGNED`, `KTC_ADJECTIVE_SHORT`, `KTC_ADJECTIVE_LONG`
 - Type `teTypeParamSpec` can have one of the following values: `KTC_TYPEPARAMSPEC_CLASS`, `KTC_TYPEPARAMSPEC_TYPENAME`
 - Type `teTypeQual` can have one of the following values: `KTC_CVQUALIFIER_NONE`, `KTC_CVQUALIFIER_CONST`, `KTC_CVQUALIFIER_VOLATILE`, `KTC_CVQUALIFIER_FINAL`, `KTC_CVQUALIFIER_OVERRIDE`, `KTC_CVQUALIFIER_FAR`, `KTC_CVQUALIFIER_NEAR`, `KTC_CVQUALIFIER_RESTRICT`
 - Type `teVirtualSpecifier` can have one of the following values: `KTC_VIRTUALSPECIFIER_NONE`, `KTC_VIRTUALSPECIFIER_VIRTUAL`, `KTC_VIRTUALSPECIFIER_NONVIRTUAL`
 - Type `tStringRef` is a string value
 - Type `tValue` is an integer value
 - Type `ident_t` is a string value
If you use any of the above attribute names in your answer, make sure to prefix them with @. For example, we could select BinaryExpr whose operator Op is KTC_OPCODE_ASSIGN using the following KAST pattern //BinaryExpr[@Op = KTC_OPCODE_ASSIGN].

To be invoked, function names should be followed with parentheses, and arguments when necessary. Functions apply to the current node being selected, for example:

//FuncDef[isStatic()]
Would select FuncDef nodes where isStatic() is true. The isStatic() function would be applied to FuncDef nodes. There is no need to use this.

Functions can only be called on nodes that they are applicable to. Here is a list of functions, their descriptions and the nodes that their are applicable to. If no nodes are specified, then they can be applied to any nodes. Do not invent functions, only use the ones from this list.

- Function `assembleString()`: Returns the string which is concatenation of adjacent string literals.. It can only be applied on nodes of type: `StringLiteralExpr`.
- Function `comesFromMacro()`: Deprecated. Checks if the current AST node is a part of a code fragment, that was inserted by preprocessor by expanding a macro. Terms that come from macro arguments are not considered to be a part of macro expansion.. It can only be applied on nodes of type: `AccessSpecification`, `AliasDecl`, `AlignAsExpr`, `AlignAsType`, `AlignOfExpr`, `AnyAttribute`, `AnyCapture`, `AnyDecl`, `AnyDeclarator`, `AnyDesignator`, `AnyEnumerator`, `AnyExpr`, `AnyFuncBody`, `AnyInitializer`, `AnyLabel`, `AnyMemberDecl`, `AnyName`, `AnyNameQualifier`, `AnyNameSpec`, `AnyNames`, `AnyNonPtrDeclarator`, `AnyParamName`, `AnyPropertyFunc`, `AnyPseudoDtor`, `AnyStmt`, `AnyTemplateArg`, `AnyTypeName`, `AnyTypeOf`, `AnyTypeParam`, `AnyUsing`, `ArrayDeclarator`, `AsmDef`, `AsmStmt`, `Attribute`, `AttributeDeclSpec`, `AttributeSpec`, `AttributeSpecs`, `AttributeWithArgs`, `AttributedDeclarator`, `Attributes`, `AutoType`, `BaseSpec`, `BaseSpecs`, `BinaryExpr`, `BitFieldDeclarator`, `BoolLiteralExpr`, `BreakStmt`, `BuiltinType`, `CVQualifier`, `CallExpr`, `Capture`, `CaptureDefault`, `CaseLabel`, `CaseRangeLabel`, `CastExpr`, `ClassType`, `CompoundStmt`, `ConditionalExpr`, `ConstExpr`, `ContinueStmt`, `ConvFunc`, `CopyInitializer`, `CtorInitializer`, `Decl`, `DeclEllipsis`, `DeclOrStmt`, `DeclOrStmts`, `DeclSpec`, `DeclSpecs`, `DefaultException`, `DefaultLabel`, `DeleteExpr`, `DenyThrowSpec`, `Designators`, `DirectInitializer`, `DoDeclStmt`, `DoStmt`, `Dtor`, `EnumType`, `Enumerator`, `Enumerators`, `ExceptHandler`, `Exception`, `ExceptionSpec`, `ExplicitInstantiation`, `ExprArg`, `ExprStmt`, `ExprTypeIdExpr`, `Exprs`, `FieldDesignator`, `FinallyHandler`, `ForEachStmt`, `ForRangeStmt`, `ForStmt`, `FuncBody`, `FuncDeclarator`, `FuncDef`, `FuncSpec`, `FuncTryBlock`, `GenericAttribute`, `GlobalScope`, `GotoStmt`, `Handler`, `Handlers`, `IdExpr`, `IfDeclStmt`, `IfStmt`, `IndexDesignator`, `IndexExpr`, `InitClause`, `InitializedCapture`, `InitializedDeclarator`, `InitializerExpr`, `Initializers`, `KRFuncDeclarator`, `Label`, `LabeledStmt`, `LambdaDeclarator`, `LambdaExpr`, `LambdaIntroducer`, `LeaveStmt`, `LinkageSpec`, `LiteralExpr`, `MaybeCtorInitializer`, `MaybeDeclarator`, `MaybeException`, `MaybeExceptionSpec`, `MaybeLambdaDeclarator`, `MaybeNewInitializer`, `MaybeTypeId`, `MemberDecl`, `MemberDecls`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `MemberInitializer`, `MemberInitializers`, `MemberTemplate`, `MemberUsingDecl`, `Name`, `NameDeclarator`, `NameSpec`, `NamespaceAlias`, `NamespaceDecl`, `NewExpr`, `NewInitializer`, `NoAttribute`, `NoAttributeSpec`, `NoBaseSpec`, `NoCapture`, `NoCtorInitializer`, `NoDeclOrStmt`, `NoDeclSpec`, `NoDeclarator`, `NoDesignator`, `NoEnumerator`, `NoException`, `NoExceptionSpec`, `NoExpr`, `NoHandler`, `NoInitializer`, `NoLambdaDeclarator`, `NoMemberDecl`, `NoMemberInitializer`, `NoName`, `NoNameQualifier`, `NoNewInitializer`, `NoParamName`, `NoPropertyFunc`, `NoTemplateArg`, `NoTemplateParam`, `NoTypeId`, `Node`, `NullptrLiteralExpr`, `OpFunc`, `Param`, `ParamName`, `ParamNames`, `ParensDeclarator`, `ParensExpr`, `PromisedFuncBody`, `PromisedMemberDecl`, `PropertyAttribute`, `PropertyFuncs`, `PropertyGetFunc`, `PropertyPutFunc`, `PseudoDtor`, `PtrDeclarator`, `QualifiedName`, `QualifiedPseudoDtor`, `RangeDesignator`, `ReservedTypeSpec`, `ReturnStmt`, `SizeOfExpr`, `SpecialCastExpr`, `StaticAssertDecl`, `StmtExpr`, `StorageClass`, `StringLiteralExpr`, `SuffixFunc`, `SuperScope`, `SwitchDeclStmt`, `SwitchStmt`, `TemplateArgs`, `TemplateDecl`, `TemplateName`, `TemplateParam`, `TemplateParams`, `TemplateSpec`, `TemplateTypeArg`, `TemplateTypeParam`, `ThisExpr`, `ThrowExpr`, `TranslationUnit`, `TruncatedInitClause`, `TryExceptStmt`, `TryFinallyStmt`, `TryStmt`, `TypeAdjective`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfExpr`, `TypeOfSpec`, `TypeOfType`, `TypeParam`, `TypeTypeIdExpr`, `UnaryExpr`, `UnparsedDecl`, `UnparsedDeclSpec`, `UnparsedDeclarator`, `UnparsedEnumerator`, `UnparsedException`, `UnparsedExpr`, `UnparsedInitializer`, `UnparsedLabel`, `UnparsedMemberDecl`, `UnparsedName`, `UnparsedNameQualifier`, `UnparsedParamName`, `UnparsedPropertyFunc`, `UnparsedStmt`, `UnqualifiedName`, `UserLiteralExpr`, `UserStringLiteralExpr`, `UsingDecl`, `UsingDirective`, `WhileDeclStmt`, `WhileStmt`.
- Function `concat()`: Returns concatenation of two strings.
- Function `contains()`: Checks if the second argument is a substring of the first argument. There also can be an optional third argument that specifies the position from which comparisons should be started.
- Function `contains-nocase()`: Checks if the second argument is a substring of the first argument. Individual characters of two strings are being compared case-insensitively. There also can be an optional third argument that specifies the position from which comparisons should be started.
- Function `ends-with()`: Checks if the second argument is a suffix of the first argument.
- Function `ends-with-nocase()`: Checks if the second argument is a suffix of the first argument. Individual characters of two strings are being compared case-insensitively.
- Function `false()`: Checks if the argument is false.
- Function `functionAcceptsVararg()`: Checks if the current AST node corresponds to a variadic function.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `ClassType`, `EnumType`, `Enumerator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `getArrayElementType()`: If current ast node declares or refers an array, returns semantic information about type of its elements; otherwise returns 0.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `getArraySizeSema()`: Returns semantic information about the size of the array that is the type of the given AST node.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `getBaseIntegralTypeName()`: Returns one of the following strings depending on the type of the current AST node: 'char', 'short', 'int', 'long', 'long long'. If the current node is not of an integral built-in type, '' (an empty string) is returned.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `getDefinedType()`: If current ast node type is defined through a typedef, returns semantic information about the type aliased in this typedef, otherwise returns sematic information about language type of the current node.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `getDestructor()`: Returns semantic information about a class destructor.. It can only be applied on nodes of type: `ClassType`, `QualifiedName`.
- Function `getFileName()`: Returns the name of the source or header file containing a code fragment, that corresponds to the given AST node.. It can only be applied on nodes of type: `AccessSpecification`, `AliasDecl`, `AlignAsExpr`, `AlignAsType`, `AlignOfExpr`, `AnyAttribute`, `AnyCapture`, `AnyDecl`, `AnyDeclarator`, `AnyDesignator`, `AnyEnumerator`, `AnyExpr`, `AnyFuncBody`, `AnyInitializer`, `AnyLabel`, `AnyMemberDecl`, `AnyName`, `AnyNameQualifier`, `AnyNameSpec`, `AnyNames`, `AnyNonPtrDeclarator`, `AnyParamName`, `AnyPropertyFunc`, `AnyPseudoDtor`, `AnyStmt`, `AnyTemplateArg`, `AnyTypeName`, `AnyTypeOf`, `AnyTypeParam`, `AnyUsing`, `ArrayDeclarator`, `AsmDef`, `AsmStmt`, `Attribute`, `AttributeDeclSpec`, `AttributeSpec`, `AttributeSpecs`, `AttributeWithArgs`, `AttributedDeclarator`, `Attributes`, `AutoType`, `BaseSpec`, `BaseSpecs`, `BinaryExpr`, `BitFieldDeclarator`, `BoolLiteralExpr`, `BreakStmt`, `BuiltinType`, `CVQualifier`, `CallExpr`, `Capture`, `CaptureDefault`, `CaseLabel`, `CaseRangeLabel`, `CastExpr`, `ClassType`, `CompoundStmt`, `ConditionalExpr`, `ConstExpr`, `ContinueStmt`, `ConvFunc`, `CopyInitializer`, `CtorInitializer`, `Decl`, `DeclEllipsis`, `DeclOrStmt`, `DeclOrStmts`, `DeclSpec`, `DeclSpecs`, `DefaultException`, `DefaultLabel`, `DeleteExpr`, `DenyThrowSpec`, `Designators`, `DirectInitializer`, `DoDeclStmt`, `DoStmt`, `Dtor`, `EnumType`, `Enumerator`, `Enumerators`, `ExceptHandler`, `Exception`, `ExceptionSpec`, `ExplicitInstantiation`, `ExprArg`, `ExprStmt`, `ExprTypeIdExpr`, `Exprs`, `FieldDesignator`, `FinallyHandler`, `ForEachStmt`, `ForRangeStmt`, `ForStmt`, `FuncBody`, `FuncDeclarator`, `FuncDef`, `FuncSpec`, `FuncTryBlock`, `GenericAttribute`, `GlobalScope`, `GotoStmt`, `Handler`, `Handlers`, `IdExpr`, `IfDeclStmt`, `IfStmt`, `IndexDesignator`, `IndexExpr`, `InitClause`, `InitializedCapture`, `InitializedDeclarator`, `InitializerExpr`, `Initializers`, `KRFuncDeclarator`, `Label`, `LabeledStmt`, `LambdaDeclarator`, `LambdaExpr`, `LambdaIntroducer`, `LeaveStmt`, `LinkageSpec`, `LiteralExpr`, `MaybeCtorInitializer`, `MaybeDeclarator`, `MaybeException`, `MaybeExceptionSpec`, `MaybeLambdaDeclarator`, `MaybeNewInitializer`, `MaybeTypeId`, `MemberDecl`, `MemberDecls`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `MemberInitializer`, `MemberInitializers`, `MemberTemplate`, `MemberUsingDecl`, `Name`, `NameDeclarator`, `NameSpec`, `NamespaceAlias`, `NamespaceDecl`, `NewExpr`, `NewInitializer`, `NoAttribute`, `NoAttributeSpec`, `NoBaseSpec`, `NoCapture`, `NoCtorInitializer`, `NoDeclOrStmt`, `NoDeclSpec`, `NoDeclarator`, `NoDesignator`, `NoEnumerator`, `NoException`, `NoExceptionSpec`, `NoExpr`, `NoHandler`, `NoInitializer`, `NoLambdaDeclarator`, `NoMemberDecl`, `NoMemberInitializer`, `NoName`, `NoNameQualifier`, `NoNewInitializer`, `NoParamName`, `NoPropertyFunc`, `NoTemplateArg`, `NoTemplateParam`, `NoTypeId`, `Node`, `NullptrLiteralExpr`, `OpFunc`, `Param`, `ParamName`, `ParamNames`, `ParensDeclarator`, `ParensExpr`, `PromisedFuncBody`, `PromisedMemberDecl`, `PropertyAttribute`, `PropertyFuncs`, `PropertyGetFunc`, `PropertyPutFunc`, `PseudoDtor`, `PtrDeclarator`, `QualifiedName`, `QualifiedPseudoDtor`, `RangeDesignator`, `ReservedTypeSpec`, `ReturnStmt`, `SizeOfExpr`, `SpecialCastExpr`, `StaticAssertDecl`, `StmtExpr`, `StorageClass`, `StringLiteralExpr`, `SuffixFunc`, `SuperScope`, `SwitchDeclStmt`, `SwitchStmt`, `TemplateArgs`, `TemplateDecl`, `TemplateName`, `TemplateParam`, `TemplateParams`, `TemplateSpec`, `TemplateTypeArg`, `TemplateTypeParam`, `ThisExpr`, `ThrowExpr`, `TranslationUnit`, `TruncatedInitClause`, `TryExceptStmt`, `TryFinallyStmt`, `TryStmt`, `TypeAdjective`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfExpr`, `TypeOfSpec`, `TypeOfType`, `TypeParam`, `TypeTypeIdExpr`, `UnaryExpr`, `UnparsedDecl`, `UnparsedDeclSpec`, `UnparsedDeclarator`, `UnparsedEnumerator`, `UnparsedException`, `UnparsedExpr`, `UnparsedInitializer`, `UnparsedLabel`, `UnparsedMemberDecl`, `UnparsedName`, `UnparsedNameQualifier`, `UnparsedParamName`, `UnparsedPropertyFunc`, `UnparsedStmt`, `UnqualifiedName`, `UserLiteralExpr`, `UserStringLiteralExpr`, `UsingDecl`, `UsingDirective`, `WhileDeclStmt`, `WhileStmt`.
- Function `getFloatValue()`: Tries to evaluate the expression represented by current AST node and returns the result. For expressions that can not be evaluated (non-constant expressions), or nodes that do not represent expressions returns 0.. It can only be applied on nodes of type: `BinaryExpr`, `BoolLiteralExpr`, `CastExpr`, `IdExpr`, `LiteralExpr`, `ParensExpr`, `SpecialCastExpr`, `UnaryExpr`.
- Function `getFormalParameter()`: Returns semantic information on the given formal parameter of the function whose semantic description is provided as an argument.
- Function `getInitialDefinedType()`: If current ast node type is defined through a chain of typedefs, returns semantic information about the type aliased in this chain, otherwise returns sematic information about language type of the current node or the provided semantic information itself. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `getIntValue()`: Tries to evaluate the expression represented by current AST node and returns the result. For expressions that can not be evaluated (non-constant expressions), or nodes that do not represent expressions returns 0.. It can only be applied on nodes of type: `BinaryExpr`, `BoolLiteralExpr`, `CastExpr`, `IdExpr`, `LiteralExpr`, `ParensExpr`, `SpecialCastExpr`, `UnaryExpr`.
- Function `getLanguageType()`: Returns semantic information about language type of current AST node.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `getMaxTypeValue()`: Returns the maximal value representable by the given integral type.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `Enumerator`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `KRFuncDeclarator`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `getMinTypeValue()`: Returns the minimal value representable by the given integral type.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `Enumerator`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `KRFuncDeclarator`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `getName()`: Returns the name of declared or referenced entity (variable/function/type/namespace).. It can only be applied on nodes of type: `ArrayDeclarator`, `CallExpr`, `Exception`, `ExplicitInstantiation`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `KRFuncDeclarator`, `MemberFunc`, `ParensDeclarator`.
- Function `getNodeColumn()`: Returns column number where language construct corresponding to the given AST node starts.. It can only be applied on nodes of type: `AccessSpecification`, `AliasDecl`, `AlignAsExpr`, `AlignAsType`, `AlignOfExpr`, `AnyAttribute`, `AnyCapture`, `AnyDecl`, `AnyDeclarator`, `AnyDesignator`, `AnyEnumerator`, `AnyExpr`, `AnyFuncBody`, `AnyInitializer`, `AnyLabel`, `AnyMemberDecl`, `AnyName`, `AnyNameQualifier`, `AnyNameSpec`, `AnyNames`, `AnyNonPtrDeclarator`, `AnyParamName`, `AnyPropertyFunc`, `AnyPseudoDtor`, `AnyStmt`, `AnyTemplateArg`, `AnyTypeName`, `AnyTypeOf`, `AnyTypeParam`, `AnyUsing`, `ArrayDeclarator`, `AsmDef`, `AsmStmt`, `Attribute`, `AttributeDeclSpec`, `AttributeSpec`, `AttributeSpecs`, `AttributeWithArgs`, `AttributedDeclarator`, `Attributes`, `AutoType`, `BaseSpec`, `BaseSpecs`, `BinaryExpr`, `BitFieldDeclarator`, `BoolLiteralExpr`, `BreakStmt`, `BuiltinType`, `CVQualifier`, `CallExpr`, `Capture`, `CaptureDefault`, `CaseLabel`, `CaseRangeLabel`, `CastExpr`, `ClassType`, `CompoundStmt`, `ConditionalExpr`, `ConstExpr`, `ContinueStmt`, `ConvFunc`, `CopyInitializer`, `CtorInitializer`, `Decl`, `DeclEllipsis`, `DeclOrStmt`, `DeclOrStmts`, `DeclSpec`, `DeclSpecs`, `DefaultException`, `DefaultLabel`, `DeleteExpr`, `DenyThrowSpec`, `Designators`, `DirectInitializer`, `DoDeclStmt`, `DoStmt`, `Dtor`, `EnumType`, `Enumerator`, `Enumerators`, `ExceptHandler`, `Exception`, `ExceptionSpec`, `ExplicitInstantiation`, `ExprArg`, `ExprStmt`, `ExprTypeIdExpr`, `Exprs`, `FieldDesignator`, `FinallyHandler`, `ForEachStmt`, `ForRangeStmt`, `ForStmt`, `FuncBody`, `FuncDeclarator`, `FuncDef`, `FuncSpec`, `FuncTryBlock`, `GenericAttribute`, `GlobalScope`, `GotoStmt`, `Handler`, `Handlers`, `IdExpr`, `IfDeclStmt`, `IfStmt`, `IndexDesignator`, `IndexExpr`, `InitClause`, `InitializedCapture`, `InitializedDeclarator`, `InitializerExpr`, `Initializers`, `KRFuncDeclarator`, `Label`, `LabeledStmt`, `LambdaDeclarator`, `LambdaExpr`, `LambdaIntroducer`, `LeaveStmt`, `LinkageSpec`, `LiteralExpr`, `MaybeCtorInitializer`, `MaybeDeclarator`, `MaybeException`, `MaybeExceptionSpec`, `MaybeLambdaDeclarator`, `MaybeNewInitializer`, `MaybeTypeId`, `MemberDecl`, `MemberDecls`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `MemberInitializer`, `MemberInitializers`, `MemberTemplate`, `MemberUsingDecl`, `Name`, `NameDeclarator`, `NameSpec`, `NamespaceAlias`, `NamespaceDecl`, `NewExpr`, `NewInitializer`, `NoAttribute`, `NoAttributeSpec`, `NoBaseSpec`, `NoCapture`, `NoCtorInitializer`, `NoDeclOrStmt`, `NoDeclSpec`, `NoDeclarator`, `NoDesignator`, `NoEnumerator`, `NoException`, `NoExceptionSpec`, `NoExpr`, `NoHandler`, `NoInitializer`, `NoLambdaDeclarator`, `NoMemberDecl`, `NoMemberInitializer`, `NoName`, `NoNameQualifier`, `NoNewInitializer`, `NoParamName`, `NoPropertyFunc`, `NoTemplateArg`, `NoTemplateParam`, `NoTypeId`, `Node`, `NullptrLiteralExpr`, `OpFunc`, `Param`, `ParamName`, `ParamNames`, `ParensDeclarator`, `ParensExpr`, `PromisedFuncBody`, `PromisedMemberDecl`, `PropertyAttribute`, `PropertyFuncs`, `PropertyGetFunc`, `PropertyPutFunc`, `PseudoDtor`, `PtrDeclarator`, `QualifiedName`, `QualifiedPseudoDtor`, `RangeDesignator`, `ReservedTypeSpec`, `ReturnStmt`, `SizeOfExpr`, `SpecialCastExpr`, `StaticAssertDecl`, `StmtExpr`, `StorageClass`, `StringLiteralExpr`, `SuffixFunc`, `SuperScope`, `SwitchDeclStmt`, `SwitchStmt`, `TemplateArgs`, `TemplateDecl`, `TemplateName`, `TemplateParam`, `TemplateParams`, `TemplateSpec`, `TemplateTypeArg`, `TemplateTypeParam`, `ThisExpr`, `ThrowExpr`, `TranslationUnit`, `TruncatedInitClause`, `TryExceptStmt`, `TryFinallyStmt`, `TryStmt`, `TypeAdjective`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfExpr`, `TypeOfSpec`, `TypeOfType`, `TypeParam`, `TypeTypeIdExpr`, `UnaryExpr`, `UnparsedDecl`, `UnparsedDeclSpec`, `UnparsedDeclarator`, `UnparsedEnumerator`, `UnparsedException`, `UnparsedExpr`, `UnparsedInitializer`, `UnparsedLabel`, `UnparsedMemberDecl`, `UnparsedName`, `UnparsedNameQualifier`, `UnparsedParamName`, `UnparsedPropertyFunc`, `UnparsedStmt`, `UnqualifiedName`, `UserLiteralExpr`, `UserStringLiteralExpr`, `UsingDecl`, `UsingDirective`, `WhileDeclStmt`, `WhileStmt`.
- Function `getNodeLastColumn()`: Returns column number where language construct corresponding to the given AST node ends.. It can only be applied on nodes of type: `AccessSpecification`, `AliasDecl`, `AlignAsExpr`, `AlignAsType`, `AlignOfExpr`, `AnyAttribute`, `AnyCapture`, `AnyDecl`, `AnyDeclarator`, `AnyDesignator`, `AnyEnumerator`, `AnyExpr`, `AnyFuncBody`, `AnyInitializer`, `AnyLabel`, `AnyMemberDecl`, `AnyName`, `AnyNameQualifier`, `AnyNameSpec`, `AnyNames`, `AnyNonPtrDeclarator`, `AnyParamName`, `AnyPropertyFunc`, `AnyPseudoDtor`, `AnyStmt`, `AnyTemplateArg`, `AnyTypeName`, `AnyTypeOf`, `AnyTypeParam`, `AnyUsing`, `ArrayDeclarator`, `AsmDef`, `AsmStmt`, `Attribute`, `AttributeDeclSpec`, `AttributeSpec`, `AttributeSpecs`, `AttributeWithArgs`, `AttributedDeclarator`, `Attributes`, `AutoType`, `BaseSpec`, `BaseSpecs`, `BinaryExpr`, `BitFieldDeclarator`, `BoolLiteralExpr`, `BreakStmt`, `BuiltinType`, `CVQualifier`, `CallExpr`, `Capture`, `CaptureDefault`, `CaseLabel`, `CaseRangeLabel`, `CastExpr`, `ClassType`, `CompoundStmt`, `ConditionalExpr`, `ConstExpr`, `ContinueStmt`, `ConvFunc`, `CopyInitializer`, `CtorInitializer`, `Decl`, `DeclEllipsis`, `DeclOrStmt`, `DeclOrStmts`, `DeclSpec`, `DeclSpecs`, `DefaultException`, `DefaultLabel`, `DeleteExpr`, `DenyThrowSpec`, `Designators`, `DirectInitializer`, `DoDeclStmt`, `DoStmt`, `Dtor`, `EnumType`, `Enumerator`, `Enumerators`, `ExceptHandler`, `Exception`, `ExceptionSpec`, `ExplicitInstantiation`, `ExprArg`, `ExprStmt`, `ExprTypeIdExpr`, `Exprs`, `FieldDesignator`, `FinallyHandler`, `ForEachStmt`, `ForRangeStmt`, `ForStmt`, `FuncBody`, `FuncDeclarator`, `FuncDef`, `FuncSpec`, `FuncTryBlock`, `GenericAttribute`, `GlobalScope`, `GotoStmt`, `Handler`, `Handlers`, `IdExpr`, `IfDeclStmt`, `IfStmt`, `IndexDesignator`, `IndexExpr`, `InitClause`, `InitializedCapture`, `InitializedDeclarator`, `InitializerExpr`, `Initializers`, `KRFuncDeclarator`, `Label`, `LabeledStmt`, `LambdaDeclarator`, `LambdaExpr`, `LambdaIntroducer`, `LeaveStmt`, `LinkageSpec`, `LiteralExpr`, `MaybeCtorInitializer`, `MaybeDeclarator`, `MaybeException`, `MaybeExceptionSpec`, `MaybeLambdaDeclarator`, `MaybeNewInitializer`, `MaybeTypeId`, `MemberDecl`, `MemberDecls`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `MemberInitializer`, `MemberInitializers`, `MemberTemplate`, `MemberUsingDecl`, `Name`, `NameDeclarator`, `NameSpec`, `NamespaceAlias`, `NamespaceDecl`, `NewExpr`, `NewInitializer`, `NoAttribute`, `NoAttributeSpec`, `NoBaseSpec`, `NoCapture`, `NoCtorInitializer`, `NoDeclOrStmt`, `NoDeclSpec`, `NoDeclarator`, `NoDesignator`, `NoEnumerator`, `NoException`, `NoExceptionSpec`, `NoExpr`, `NoHandler`, `NoInitializer`, `NoLambdaDeclarator`, `NoMemberDecl`, `NoMemberInitializer`, `NoName`, `NoNameQualifier`, `NoNewInitializer`, `NoParamName`, `NoPropertyFunc`, `NoTemplateArg`, `NoTemplateParam`, `NoTypeId`, `Node`, `NullptrLiteralExpr`, `OpFunc`, `Param`, `ParamName`, `ParamNames`, `ParensDeclarator`, `ParensExpr`, `PromisedFuncBody`, `PromisedMemberDecl`, `PropertyAttribute`, `PropertyFuncs`, `PropertyGetFunc`, `PropertyPutFunc`, `PseudoDtor`, `PtrDeclarator`, `QualifiedName`, `QualifiedPseudoDtor`, `RangeDesignator`, `ReservedTypeSpec`, `ReturnStmt`, `SizeOfExpr`, `SpecialCastExpr`, `StaticAssertDecl`, `StmtExpr`, `StorageClass`, `StringLiteralExpr`, `SuffixFunc`, `SuperScope`, `SwitchDeclStmt`, `SwitchStmt`, `TemplateArgs`, `TemplateDecl`, `TemplateName`, `TemplateParam`, `TemplateParams`, `TemplateSpec`, `TemplateTypeArg`, `TemplateTypeParam`, `ThisExpr`, `ThrowExpr`, `TranslationUnit`, `TruncatedInitClause`, `TryExceptStmt`, `TryFinallyStmt`, `TryStmt`, `TypeAdjective`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfExpr`, `TypeOfSpec`, `TypeOfType`, `TypeParam`, `TypeTypeIdExpr`, `UnaryExpr`, `UnparsedDecl`, `UnparsedDeclSpec`, `UnparsedDeclarator`, `UnparsedEnumerator`, `UnparsedException`, `UnparsedExpr`, `UnparsedInitializer`, `UnparsedLabel`, `UnparsedMemberDecl`, `UnparsedName`, `UnparsedNameQualifier`, `UnparsedParamName`, `UnparsedPropertyFunc`, `UnparsedStmt`, `UnqualifiedName`, `UserLiteralExpr`, `UserStringLiteralExpr`, `UsingDecl`, `UsingDirective`, `WhileDeclStmt`, `WhileStmt`.
- Function `getNodeLastLine()`: Returns line number where language construct corresponding to the given AST node ends.. It can only be applied on nodes of type: `AccessSpecification`, `AliasDecl`, `AlignAsExpr`, `AlignAsType`, `AlignOfExpr`, `AnyAttribute`, `AnyCapture`, `AnyDecl`, `AnyDeclarator`, `AnyDesignator`, `AnyEnumerator`, `AnyExpr`, `AnyFuncBody`, `AnyInitializer`, `AnyLabel`, `AnyMemberDecl`, `AnyName`, `AnyNameQualifier`, `AnyNameSpec`, `AnyNames`, `AnyNonPtrDeclarator`, `AnyParamName`, `AnyPropertyFunc`, `AnyPseudoDtor`, `AnyStmt`, `AnyTemplateArg`, `AnyTypeName`, `AnyTypeOf`, `AnyTypeParam`, `AnyUsing`, `ArrayDeclarator`, `AsmDef`, `AsmStmt`, `Attribute`, `AttributeDeclSpec`, `AttributeSpec`, `AttributeSpecs`, `AttributeWithArgs`, `AttributedDeclarator`, `Attributes`, `AutoType`, `BaseSpec`, `BaseSpecs`, `BinaryExpr`, `BitFieldDeclarator`, `BoolLiteralExpr`, `BreakStmt`, `BuiltinType`, `CVQualifier`, `CallExpr`, `Capture`, `CaptureDefault`, `CaseLabel`, `CaseRangeLabel`, `CastExpr`, `ClassType`, `CompoundStmt`, `ConditionalExpr`, `ConstExpr`, `ContinueStmt`, `ConvFunc`, `CopyInitializer`, `CtorInitializer`, `Decl`, `DeclEllipsis`, `DeclOrStmt`, `DeclOrStmts`, `DeclSpec`, `DeclSpecs`, `DefaultException`, `DefaultLabel`, `DeleteExpr`, `DenyThrowSpec`, `Designators`, `DirectInitializer`, `DoDeclStmt`, `DoStmt`, `Dtor`, `EnumType`, `Enumerator`, `Enumerators`, `ExceptHandler`, `Exception`, `ExceptionSpec`, `ExplicitInstantiation`, `ExprArg`, `ExprStmt`, `ExprTypeIdExpr`, `Exprs`, `FieldDesignator`, `FinallyHandler`, `ForEachStmt`, `ForRangeStmt`, `ForStmt`, `FuncBody`, `FuncDeclarator`, `FuncDef`, `FuncSpec`, `FuncTryBlock`, `GenericAttribute`, `GlobalScope`, `GotoStmt`, `Handler`, `Handlers`, `IdExpr`, `IfDeclStmt`, `IfStmt`, `IndexDesignator`, `IndexExpr`, `InitClause`, `InitializedCapture`, `InitializedDeclarator`, `InitializerExpr`, `Initializers`, `KRFuncDeclarator`, `Label`, `LabeledStmt`, `LambdaDeclarator`, `LambdaExpr`, `LambdaIntroducer`, `LeaveStmt`, `LinkageSpec`, `LiteralExpr`, `MaybeCtorInitializer`, `MaybeDeclarator`, `MaybeException`, `MaybeExceptionSpec`, `MaybeLambdaDeclarator`, `MaybeNewInitializer`, `MaybeTypeId`, `MemberDecl`, `MemberDecls`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `MemberInitializer`, `MemberInitializers`, `MemberTemplate`, `MemberUsingDecl`, `Name`, `NameDeclarator`, `NameSpec`, `NamespaceAlias`, `NamespaceDecl`, `NewExpr`, `NewInitializer`, `NoAttribute`, `NoAttributeSpec`, `NoBaseSpec`, `NoCapture`, `NoCtorInitializer`, `NoDeclOrStmt`, `NoDeclSpec`, `NoDeclarator`, `NoDesignator`, `NoEnumerator`, `NoException`, `NoExceptionSpec`, `NoExpr`, `NoHandler`, `NoInitializer`, `NoLambdaDeclarator`, `NoMemberDecl`, `NoMemberInitializer`, `NoName`, `NoNameQualifier`, `NoNewInitializer`, `NoParamName`, `NoPropertyFunc`, `NoTemplateArg`, `NoTemplateParam`, `NoTypeId`, `Node`, `NullptrLiteralExpr`, `OpFunc`, `Param`, `ParamName`, `ParamNames`, `ParensDeclarator`, `ParensExpr`, `PromisedFuncBody`, `PromisedMemberDecl`, `PropertyAttribute`, `PropertyFuncs`, `PropertyGetFunc`, `PropertyPutFunc`, `PseudoDtor`, `PtrDeclarator`, `QualifiedName`, `QualifiedPseudoDtor`, `RangeDesignator`, `ReservedTypeSpec`, `ReturnStmt`, `SizeOfExpr`, `SpecialCastExpr`, `StaticAssertDecl`, `StmtExpr`, `StorageClass`, `StringLiteralExpr`, `SuffixFunc`, `SuperScope`, `SwitchDeclStmt`, `SwitchStmt`, `TemplateArgs`, `TemplateDecl`, `TemplateName`, `TemplateParam`, `TemplateParams`, `TemplateSpec`, `TemplateTypeArg`, `TemplateTypeParam`, `ThisExpr`, `ThrowExpr`, `TranslationUnit`, `TruncatedInitClause`, `TryExceptStmt`, `TryFinallyStmt`, `TryStmt`, `TypeAdjective`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfExpr`, `TypeOfSpec`, `TypeOfType`, `TypeParam`, `TypeTypeIdExpr`, `UnaryExpr`, `UnparsedDecl`, `UnparsedDeclSpec`, `UnparsedDeclarator`, `UnparsedEnumerator`, `UnparsedException`, `UnparsedExpr`, `UnparsedInitializer`, `UnparsedLabel`, `UnparsedMemberDecl`, `UnparsedName`, `UnparsedNameQualifier`, `UnparsedParamName`, `UnparsedPropertyFunc`, `UnparsedStmt`, `UnqualifiedName`, `UserLiteralExpr`, `UserStringLiteralExpr`, `UsingDecl`, `UsingDirective`, `WhileDeclStmt`, `WhileStmt`.
- Function `getNodeLine()`: Returns line number where language construct corresponding to the given AST node starts.. It can only be applied on nodes of type: `AccessSpecification`, `AliasDecl`, `AlignAsExpr`, `AlignAsType`, `AlignOfExpr`, `AnyAttribute`, `AnyCapture`, `AnyDecl`, `AnyDeclarator`, `AnyDesignator`, `AnyEnumerator`, `AnyExpr`, `AnyFuncBody`, `AnyInitializer`, `AnyLabel`, `AnyMemberDecl`, `AnyName`, `AnyNameQualifier`, `AnyNameSpec`, `AnyNames`, `AnyNonPtrDeclarator`, `AnyParamName`, `AnyPropertyFunc`, `AnyPseudoDtor`, `AnyStmt`, `AnyTemplateArg`, `AnyTypeName`, `AnyTypeOf`, `AnyTypeParam`, `AnyUsing`, `ArrayDeclarator`, `AsmDef`, `AsmStmt`, `Attribute`, `AttributeDeclSpec`, `AttributeSpec`, `AttributeSpecs`, `AttributeWithArgs`, `AttributedDeclarator`, `Attributes`, `AutoType`, `BaseSpec`, `BaseSpecs`, `BinaryExpr`, `BitFieldDeclarator`, `BoolLiteralExpr`, `BreakStmt`, `BuiltinType`, `CVQualifier`, `CallExpr`, `Capture`, `CaptureDefault`, `CaseLabel`, `CaseRangeLabel`, `CastExpr`, `ClassType`, `CompoundStmt`, `ConditionalExpr`, `ConstExpr`, `ContinueStmt`, `ConvFunc`, `CopyInitializer`, `CtorInitializer`, `Decl`, `DeclEllipsis`, `DeclOrStmt`, `DeclOrStmts`, `DeclSpec`, `DeclSpecs`, `DefaultException`, `DefaultLabel`, `DeleteExpr`, `DenyThrowSpec`, `Designators`, `DirectInitializer`, `DoDeclStmt`, `DoStmt`, `Dtor`, `EnumType`, `Enumerator`, `Enumerators`, `ExceptHandler`, `Exception`, `ExceptionSpec`, `ExplicitInstantiation`, `ExprArg`, `ExprStmt`, `ExprTypeIdExpr`, `Exprs`, `FieldDesignator`, `FinallyHandler`, `ForEachStmt`, `ForRangeStmt`, `ForStmt`, `FuncBody`, `FuncDeclarator`, `FuncDef`, `FuncSpec`, `FuncTryBlock`, `GenericAttribute`, `GlobalScope`, `GotoStmt`, `Handler`, `Handlers`, `IdExpr`, `IfDeclStmt`, `IfStmt`, `IndexDesignator`, `IndexExpr`, `InitClause`, `InitializedCapture`, `InitializedDeclarator`, `InitializerExpr`, `Initializers`, `KRFuncDeclarator`, `Label`, `LabeledStmt`, `LambdaDeclarator`, `LambdaExpr`, `LambdaIntroducer`, `LeaveStmt`, `LinkageSpec`, `LiteralExpr`, `MaybeCtorInitializer`, `MaybeDeclarator`, `MaybeException`, `MaybeExceptionSpec`, `MaybeLambdaDeclarator`, `MaybeNewInitializer`, `MaybeTypeId`, `MemberDecl`, `MemberDecls`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `MemberInitializer`, `MemberInitializers`, `MemberTemplate`, `MemberUsingDecl`, `Name`, `NameDeclarator`, `NameSpec`, `NamespaceAlias`, `NamespaceDecl`, `NewExpr`, `NewInitializer`, `NoAttribute`, `NoAttributeSpec`, `NoBaseSpec`, `NoCapture`, `NoCtorInitializer`, `NoDeclOrStmt`, `NoDeclSpec`, `NoDeclarator`, `NoDesignator`, `NoEnumerator`, `NoException`, `NoExceptionSpec`, `NoExpr`, `NoHandler`, `NoInitializer`, `NoLambdaDeclarator`, `NoMemberDecl`, `NoMemberInitializer`, `NoName`, `NoNameQualifier`, `NoNewInitializer`, `NoParamName`, `NoPropertyFunc`, `NoTemplateArg`, `NoTemplateParam`, `NoTypeId`, `Node`, `NullptrLiteralExpr`, `OpFunc`, `Param`, `ParamName`, `ParamNames`, `ParensDeclarator`, `ParensExpr`, `PromisedFuncBody`, `PromisedMemberDecl`, `PropertyAttribute`, `PropertyFuncs`, `PropertyGetFunc`, `PropertyPutFunc`, `PseudoDtor`, `PtrDeclarator`, `QualifiedName`, `QualifiedPseudoDtor`, `RangeDesignator`, `ReservedTypeSpec`, `ReturnStmt`, `SizeOfExpr`, `SpecialCastExpr`, `StaticAssertDecl`, `StmtExpr`, `StorageClass`, `StringLiteralExpr`, `SuffixFunc`, `SuperScope`, `SwitchDeclStmt`, `SwitchStmt`, `TemplateArgs`, `TemplateDecl`, `TemplateName`, `TemplateParam`, `TemplateParams`, `TemplateSpec`, `TemplateTypeArg`, `TemplateTypeParam`, `ThisExpr`, `ThrowExpr`, `TranslationUnit`, `TruncatedInitClause`, `TryExceptStmt`, `TryFinallyStmt`, `TryStmt`, `TypeAdjective`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfExpr`, `TypeOfSpec`, `TypeOfType`, `TypeParam`, `TypeTypeIdExpr`, `UnaryExpr`, `UnparsedDecl`, `UnparsedDeclSpec`, `UnparsedDeclarator`, `UnparsedEnumerator`, `UnparsedException`, `UnparsedExpr`, `UnparsedInitializer`, `UnparsedLabel`, `UnparsedMemberDecl`, `UnparsedName`, `UnparsedNameQualifier`, `UnparsedParamName`, `UnparsedPropertyFunc`, `UnparsedStmt`, `UnqualifiedName`, `UserLiteralExpr`, `UserStringLiteralExpr`, `UsingDecl`, `UsingDirective`, `WhileDeclStmt`, `WhileStmt`.
- Function `getNumberOfActualParams()`: Returns number of arguments actually provided to a function that is called in current ast node.. It can only be applied on nodes of type: `CallExpr`.
- Function `getNumberOfFormalParams()`: Returns number of formal parameters for a function associated with current ast node. If no function is associated with the current node, returns1.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `Enumerator`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `KRFuncDeclarator`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `getOperationCode()`: Retrieves operation code for the expression represented by current AST node.. It can only be applied on nodes of type: `BinaryExpr`, `MemberExpr`, `OpFunc`, `UnaryExpr`.
- Function `getOverridenMethod()`: Returns semantic information about base class method overriden with method that is associated with current AST node.. It can only be applied on nodes of type: `MemberDecl`, `MemberFunc`.
- Function `getParent()`: Returns semantic information about parent scope for current AST node.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `Enumerator`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `KRFuncDeclarator`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `getPointedType()`: If current ast node declares or refers a pointer, returns semantic information about type it points to; otherwise returns 0.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `getPositionInList()`: Returns the node's index in a list child (list of a function call arguments, list of inner statements in a compound statement, etc.). For non-list children or when the node does not belong to the list, (-1) is returned.. It can only be applied on nodes of type: `AccessSpecification`, `AliasDecl`, `AlignAsExpr`, `AlignAsType`, `AlignOfExpr`, `AnyAttribute`, `AnyCapture`, `AnyDecl`, `AnyDeclarator`, `AnyDesignator`, `AnyEnumerator`, `AnyExpr`, `AnyFuncBody`, `AnyInitializer`, `AnyLabel`, `AnyMemberDecl`, `AnyName`, `AnyNameQualifier`, `AnyNameSpec`, `AnyNames`, `AnyNonPtrDeclarator`, `AnyParamName`, `AnyPropertyFunc`, `AnyPseudoDtor`, `AnyStmt`, `AnyTemplateArg`, `AnyTypeName`, `AnyTypeOf`, `AnyTypeParam`, `AnyUsing`, `ArrayDeclarator`, `AsmDef`, `AsmStmt`, `Attribute`, `AttributeDeclSpec`, `AttributeSpec`, `AttributeSpecs`, `AttributeWithArgs`, `AttributedDeclarator`, `Attributes`, `AutoType`, `BaseSpec`, `BaseSpecs`, `BinaryExpr`, `BitFieldDeclarator`, `BoolLiteralExpr`, `BreakStmt`, `BuiltinType`, `CVQualifier`, `CallExpr`, `Capture`, `CaptureDefault`, `CaseLabel`, `CaseRangeLabel`, `CastExpr`, `ClassType`, `CompoundStmt`, `ConditionalExpr`, `ConstExpr`, `ContinueStmt`, `ConvFunc`, `CopyInitializer`, `CtorInitializer`, `Decl`, `DeclEllipsis`, `DeclOrStmt`, `DeclOrStmts`, `DeclSpec`, `DeclSpecs`, `DefaultException`, `DefaultLabel`, `DeleteExpr`, `DenyThrowSpec`, `Designators`, `DirectInitializer`, `DoDeclStmt`, `DoStmt`, `Dtor`, `EnumType`, `Enumerator`, `Enumerators`, `ExceptHandler`, `Exception`, `ExceptionSpec`, `ExplicitInstantiation`, `ExprArg`, `ExprStmt`, `ExprTypeIdExpr`, `Exprs`, `FieldDesignator`, `FinallyHandler`, `ForEachStmt`, `ForRangeStmt`, `ForStmt`, `FuncBody`, `FuncDeclarator`, `FuncDef`, `FuncSpec`, `FuncTryBlock`, `GenericAttribute`, `GlobalScope`, `GotoStmt`, `Handler`, `Handlers`, `IdExpr`, `IfDeclStmt`, `IfStmt`, `IndexDesignator`, `IndexExpr`, `InitClause`, `InitializedCapture`, `InitializedDeclarator`, `InitializerExpr`, `Initializers`, `KRFuncDeclarator`, `Label`, `LabeledStmt`, `LambdaDeclarator`, `LambdaExpr`, `LambdaIntroducer`, `LeaveStmt`, `LinkageSpec`, `LiteralExpr`, `MaybeCtorInitializer`, `MaybeDeclarator`, `MaybeException`, `MaybeExceptionSpec`, `MaybeLambdaDeclarator`, `MaybeNewInitializer`, `MaybeTypeId`, `MemberDecl`, `MemberDecls`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `MemberInitializer`, `MemberInitializers`, `MemberTemplate`, `MemberUsingDecl`, `Name`, `NameDeclarator`, `NameSpec`, `NamespaceAlias`, `NamespaceDecl`, `NewExpr`, `NewInitializer`, `NoAttribute`, `NoAttributeSpec`, `NoBaseSpec`, `NoCapture`, `NoCtorInitializer`, `NoDeclOrStmt`, `NoDeclSpec`, `NoDeclarator`, `NoDesignator`, `NoEnumerator`, `NoException`, `NoExceptionSpec`, `NoExpr`, `NoHandler`, `NoInitializer`, `NoLambdaDeclarator`, `NoMemberDecl`, `NoMemberInitializer`, `NoName`, `NoNameQualifier`, `NoNewInitializer`, `NoParamName`, `NoPropertyFunc`, `NoTemplateArg`, `NoTemplateParam`, `NoTypeId`, `Node`, `NullptrLiteralExpr`, `OpFunc`, `Param`, `ParamName`, `ParamNames`, `ParensDeclarator`, `ParensExpr`, `PromisedFuncBody`, `PromisedMemberDecl`, `PropertyAttribute`, `PropertyFuncs`, `PropertyGetFunc`, `PropertyPutFunc`, `PseudoDtor`, `PtrDeclarator`, `QualifiedName`, `QualifiedPseudoDtor`, `RangeDesignator`, `ReservedTypeSpec`, `ReturnStmt`, `SizeOfExpr`, `SpecialCastExpr`, `StaticAssertDecl`, `StmtExpr`, `StorageClass`, `StringLiteralExpr`, `SuffixFunc`, `SuperScope`, `SwitchDeclStmt`, `SwitchStmt`, `TemplateArgs`, `TemplateDecl`, `TemplateName`, `TemplateParam`, `TemplateParams`, `TemplateSpec`, `TemplateTypeArg`, `TemplateTypeParam`, `ThisExpr`, `ThrowExpr`, `TranslationUnit`, `TruncatedInitClause`, `TryExceptStmt`, `TryFinallyStmt`, `TryStmt`, `TypeAdjective`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfExpr`, `TypeOfSpec`, `TypeOfType`, `TypeParam`, `TypeTypeIdExpr`, `UnaryExpr`, `UnparsedDecl`, `UnparsedDeclSpec`, `UnparsedDeclarator`, `UnparsedEnumerator`, `UnparsedException`, `UnparsedExpr`, `UnparsedInitializer`, `UnparsedLabel`, `UnparsedMemberDecl`, `UnparsedName`, `UnparsedNameQualifier`, `UnparsedParamName`, `UnparsedPropertyFunc`, `UnparsedStmt`, `UnqualifiedName`, `UserLiteralExpr`, `UserStringLiteralExpr`, `UsingDecl`, `UsingDirective`, `WhileDeclStmt`, `WhileStmt`.
- Function `getPrimaryTemplate()`: Returns semantic information the primary template for the given template instantiation or specialization.. It can only be applied on nodes of type: `IdExpr`, `TemplateDecl`.
- Function `getQualifiedTypeName()`: Infers the qualified type of declared/referenced entity and returns the name of this type. Type qualifiers are the keyword const and volatile. For nodes that does not declare/reference an entity returns '<@error@>'.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `getReferencedType()`: If current ast node declares or refers a reference, returns semantic information about type referenced by it; otherwise returns 0.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `getReferencedTypeOrSelf()`: If current ast node declares or refers a reference, returns semantic information about type referenced by it; otherwise returns semantic information on the provided node's type or the provided semantic information itself.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `getReturnType()`: Returns semantic information about return type of function associated with current AST node.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `Enumerator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `KRFuncDeclarator`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `getSemanticInfo()`: Returns semantic information associated with current AST node.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `Enumerator`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `KRFuncDeclarator`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `getTypeName()`: Infers the type of declared/referenced entity and returns the name of this type. For nodes that does not declare/reference an entity returns '<@error@>'.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `getTypeSize()`: Returns the size of declared/referenced variable or expression. For nodes that do not declare/reference a variable, and are not expressions returns 0.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `getUnderlyingType()`: If current ast node type is defined through a chain of typedefs, returns semantic information about the type aliased in this chain. If current node declares or refers to a reference (directly or through a chain of typedefs), that reference is resolved. If neither typedefs nor references are used, returns sematic information about language type of the current node or the provided semantic information itself.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `hasCompleteDefinition()`: Checks if the current AST node corresponds to a completely defined type or to an expression of a completely defined type. A type is considered 'completely defined' if it has a definition (but not only a declaration) and (in case of classes/structs/unions) all its members are also completely defined.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `ClassType`, `EnumType`, `Enumerator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `hasVirtualBase()`: Checks if the given AST node corresponds to a class with a virtual base class, or the current node's type is a class type with a virtual base.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isAbstract()`: Checks if the current AST node corresponds to an abstract class type or to an expression of an abstract class type.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isArray()`: Checks if the current AST node declares an array, or is an expression that evaluates to an array.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isAssignmentOperator()`: Checks if the current AST node declares overloaded assignment operator.. It can only be applied on nodes of type: `ArrayDeclarator`, `Exception`, `ExplicitInstantiation`, `FuncDeclarator`, `FuncDef`, `KRFuncDeclarator`, `MemberFunc`, `ParensDeclarator`.
- Function `isBoolean()`: Checks if the current AST node declares something of type 'bool' or is an expression whose value is of type 'bool'.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isBuiltinType()`: Checks if the current AST node declares something of built-in type, or is an expression whose value is of built-in type.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isCharacterLiteral()`: Checks if current AST node represents a character literal.. It can only be applied on nodes of type: `LiteralExpr`.
- Function `isCLanguage()`: Returns true if the current file is a C (but not C++) source. It can only be applied on nodes of type: `AccessSpecification`, `AliasDecl`, `AlignAsExpr`, `AlignAsType`, `AlignOfExpr`, `AnyAttribute`, `AnyCapture`, `AnyDecl`, `AnyDeclarator`, `AnyDesignator`, `AnyEnumerator`, `AnyExpr`, `AnyFuncBody`, `AnyInitializer`, `AnyLabel`, `AnyMemberDecl`, `AnyName`, `AnyNameQualifier`, `AnyNameSpec`, `AnyNames`, `AnyNonPtrDeclarator`, `AnyParamName`, `AnyPropertyFunc`, `AnyPseudoDtor`, `AnyStmt`, `AnyTemplateArg`, `AnyTypeName`, `AnyTypeOf`, `AnyTypeParam`, `AnyUsing`, `ArrayDeclarator`, `AsmDef`, `AsmStmt`, `Attribute`, `AttributeDeclSpec`, `AttributeSpec`, `AttributeSpecs`, `AttributeWithArgs`, `AttributedDeclarator`, `Attributes`, `AutoType`, `BaseSpec`, `BaseSpecs`, `BinaryExpr`, `BitFieldDeclarator`, `BoolLiteralExpr`, `BreakStmt`, `BuiltinType`, `CVQualifier`, `CallExpr`, `Capture`, `CaptureDefault`, `CaseLabel`, `CaseRangeLabel`, `CastExpr`, `ClassType`, `CompoundStmt`, `ConditionalExpr`, `ConstExpr`, `ContinueStmt`, `ConvFunc`, `CopyInitializer`, `CtorInitializer`, `Decl`, `DeclEllipsis`, `DeclOrStmt`, `DeclOrStmts`, `DeclSpec`, `DeclSpecs`, `DefaultException`, `DefaultLabel`, `DeleteExpr`, `DenyThrowSpec`, `Designators`, `DirectInitializer`, `DoDeclStmt`, `DoStmt`, `Dtor`, `EnumType`, `Enumerator`, `Enumerators`, `ExceptHandler`, `Exception`, `ExceptionSpec`, `ExplicitInstantiation`, `ExprArg`, `ExprStmt`, `ExprTypeIdExpr`, `Exprs`, `FieldDesignator`, `FinallyHandler`, `ForEachStmt`, `ForRangeStmt`, `ForStmt`, `FuncBody`, `FuncDeclarator`, `FuncDef`, `FuncSpec`, `FuncTryBlock`, `GenericAttribute`, `GlobalScope`, `GotoStmt`, `Handler`, `Handlers`, `IdExpr`, `IfDeclStmt`, `IfStmt`, `IndexDesignator`, `IndexExpr`, `InitClause`, `InitializedCapture`, `InitializedDeclarator`, `InitializerExpr`, `Initializers`, `KRFuncDeclarator`, `Label`, `LabeledStmt`, `LambdaDeclarator`, `LambdaExpr`, `LambdaIntroducer`, `LeaveStmt`, `LinkageSpec`, `LiteralExpr`, `MaybeCtorInitializer`, `MaybeDeclarator`, `MaybeException`, `MaybeExceptionSpec`, `MaybeLambdaDeclarator`, `MaybeNewInitializer`, `MaybeTypeId`, `MemberDecl`, `MemberDecls`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `MemberInitializer`, `MemberInitializers`, `MemberTemplate`, `MemberUsingDecl`, `Name`, `NameDeclarator`, `NameSpec`, `NamespaceAlias`, `NamespaceDecl`, `NewExpr`, `NewInitializer`, `NoAttribute`, `NoAttributeSpec`, `NoBaseSpec`, `NoCapture`, `NoCtorInitializer`, `NoDeclOrStmt`, `NoDeclSpec`, `NoDeclarator`, `NoDesignator`, `NoEnumerator`, `NoException`, `NoExceptionSpec`, `NoExpr`, `NoHandler`, `NoInitializer`, `NoLambdaDeclarator`, `NoMemberDecl`, `NoMemberInitializer`, `NoName`, `NoNameQualifier`, `NoNewInitializer`, `NoParamName`, `NoPropertyFunc`, `NoTemplateArg`, `NoTemplateParam`, `NoTypeId`, `Node`, `NullptrLiteralExpr`, `OpFunc`, `Param`, `ParamName`, `ParamNames`, `ParensDeclarator`, `ParensExpr`, `PromisedFuncBody`, `PromisedMemberDecl`, `PropertyAttribute`, `PropertyFuncs`, `PropertyGetFunc`, `PropertyPutFunc`, `PseudoDtor`, `PtrDeclarator`, `QualifiedName`, `QualifiedPseudoDtor`, `RangeDesignator`, `ReservedTypeSpec`, `ReturnStmt`, `SizeOfExpr`, `SpecialCastExpr`, `StaticAssertDecl`, `StmtExpr`, `StorageClass`, `StringLiteralExpr`, `SuffixFunc`, `SuperScope`, `SwitchDeclStmt`, `SwitchStmt`, `TemplateArgs`, `TemplateDecl`, `TemplateName`, `TemplateParam`, `TemplateParams`, `TemplateSpec`, `TemplateTypeArg`, `TemplateTypeParam`, `ThisExpr`, `ThrowExpr`, `TranslationUnit`, `TruncatedInitClause`, `TryExceptStmt`, `TryFinallyStmt`, `TryStmt`, `TypeAdjective`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfExpr`, `TypeOfSpec`, `TypeOfType`, `TypeParam`, `TypeTypeIdExpr`, `UnaryExpr`, `UnparsedDecl`, `UnparsedDeclSpec`, `UnparsedDeclarator`, `UnparsedEnumerator`, `UnparsedException`, `UnparsedExpr`, `UnparsedInitializer`, `UnparsedLabel`, `UnparsedMemberDecl`, `UnparsedName`, `UnparsedNameQualifier`, `UnparsedParamName`, `UnparsedPropertyFunc`, `UnparsedStmt`, `UnqualifiedName`, `UserLiteralExpr`, `UserStringLiteralExpr`, `UsingDecl`, `UsingDirective`, `WhileDeclStmt`, `WhileStmt`.
- Function `isClass()`: Checks if the current AST node declares a class/struct/union, or is an expression whose value is of class/struct/union type.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isClassInstantiation()`: Checks if the current AST node declares a class template instantiation.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `isClassMember()`: Checks if the current AST node declares a member of class, or is an expression that refers to member of class.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `Enumerator`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `KRFuncDeclarator`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `isClassSpecialization()`: Checks if the current AST node declares a class template specialization.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `isClassTemplate()`: Checks if the current AST node declares a template.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `Enumerator`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `isClassType()`: Checks if the current AST node declares a class (but not a struct or a union), or is an expression whose value is of class type.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isConstant()`: Checks if current AST node represents constant expression.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isConstExpr()`: Checks if current AST node represents constexpr expression.. It can only be applied on nodes of type: `ConstExpr`, `Decl`, `MemberDecl`.
- Function `isConst()`: Checks if the current AST node declares a constant variable or member function, or is an expression that refers to constant variable.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isConstructor()`: Checks if the current AST node declares a constructor, or is an expression that refers to a constructor.. It can only be applied on nodes of type: `ArrayDeclarator`, `Exception`, `ExplicitInstantiation`, `FuncDeclarator`, `FuncDef`, `KRFuncDeclarator`, `MemberFunc`, `ParensDeclarator`.
- Function `isConvFunc()`: Checks if the current node declares a type conversion operator.. It can only be applied on nodes of type: `ArrayDeclarator`, `Exception`, `ExplicitInstantiation`, `FuncDeclarator`, `FuncDef`, `KRFuncDeclarator`, `MemberFunc`, `ParensDeclarator`.
- Function `isCopyConstructor()`: Checks if the current AST node declares copy constructor.. It can only be applied on nodes of type: `ArrayDeclarator`, `Exception`, `ExplicitInstantiation`, `FuncDeclarator`, `FuncDef`, `KRFuncDeclarator`, `MemberFunc`, `ParensDeclarator`.
- Function `isDefinition()`: Checks if the current AST node defines a function, class or enum, or is an expression that refers to definition of function, class or enum.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `ClassType`, `EnumType`, `Enumerator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `isDerivedFrom()`: Checks if the AST node represented by the first argument is of a class type that is derived from another class. The function is also able to accept a class semantic description as its first argument.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `Enumerator`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `KRFuncDeclarator`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `isDerived()`: Checks if the given AST node's type is a class derived from another class. The function is also able to accept a class semantic description as an argument.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `Enumerator`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `KRFuncDeclarator`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `isDestructor()`: Checks if the current AST node declares a destructor, or is an expression that refers to a destructor.. It can only be applied on nodes of type: `ArrayDeclarator`, `Exception`, `ExplicitInstantiation`, `FuncDeclarator`, `FuncDef`, `KRFuncDeclarator`, `MemberFunc`, `ParensDeclarator`.
- Function `isEnum()`: Checks if the current AST node declares an enum, or is an expression whose value is of enum type.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isExplicit()`: Checks if the current AST node declares an explicit constructor, or is an expression that refers to explicit constructor.. It can only be applied on nodes of type: `ArrayDeclarator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `MemberFunc`, `Name`, `QualifiedName`.
- Function `isExtern()`: Checks if the current AST node declares an extern variable/function, or is an expression that refers to extern variable/function.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `KRFuncDeclarator`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `isFloatPoint()`: Checks if current AST node declares something of floating point type, or is an expression whose value is of floating point type ('float', 'double', 'long double'). It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isFriend()`: Checks if the current AST node declares a friend function or class, or is an expression that refers to friend function or class.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `Enumerator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `isFromMacroArg()`: Checks if the current AST node is a part of a code fragment, that was inserted by preprocessor as a macro argument within a a macro expansion.. It can only be applied on nodes of type: `AccessSpecification`, `AliasDecl`, `AlignAsExpr`, `AlignAsType`, `AlignOfExpr`, `AnyAttribute`, `AnyCapture`, `AnyDecl`, `AnyDeclarator`, `AnyDesignator`, `AnyEnumerator`, `AnyExpr`, `AnyFuncBody`, `AnyInitializer`, `AnyLabel`, `AnyMemberDecl`, `AnyName`, `AnyNameQualifier`, `AnyNameSpec`, `AnyNames`, `AnyNonPtrDeclarator`, `AnyParamName`, `AnyPropertyFunc`, `AnyPseudoDtor`, `AnyStmt`, `AnyTemplateArg`, `AnyTypeName`, `AnyTypeOf`, `AnyTypeParam`, `AnyUsing`, `ArrayDeclarator`, `AsmDef`, `AsmStmt`, `Attribute`, `AttributeDeclSpec`, `AttributeSpec`, `AttributeSpecs`, `AttributeWithArgs`, `AttributedDeclarator`, `Attributes`, `AutoType`, `BaseSpec`, `BaseSpecs`, `BinaryExpr`, `BitFieldDeclarator`, `BoolLiteralExpr`, `BreakStmt`, `BuiltinType`, `CVQualifier`, `CallExpr`, `Capture`, `CaptureDefault`, `CaseLabel`, `CaseRangeLabel`, `CastExpr`, `ClassType`, `CompoundStmt`, `ConditionalExpr`, `ConstExpr`, `ContinueStmt`, `ConvFunc`, `CopyInitializer`, `CtorInitializer`, `Decl`, `DeclEllipsis`, `DeclOrStmt`, `DeclOrStmts`, `DeclSpec`, `DeclSpecs`, `DefaultException`, `DefaultLabel`, `DeleteExpr`, `DenyThrowSpec`, `Designators`, `DirectInitializer`, `DoDeclStmt`, `DoStmt`, `Dtor`, `EnumType`, `Enumerator`, `Enumerators`, `ExceptHandler`, `Exception`, `ExceptionSpec`, `ExplicitInstantiation`, `ExprArg`, `ExprStmt`, `ExprTypeIdExpr`, `Exprs`, `FieldDesignator`, `FinallyHandler`, `ForEachStmt`, `ForRangeStmt`, `ForStmt`, `FuncBody`, `FuncDeclarator`, `FuncDef`, `FuncSpec`, `FuncTryBlock`, `GenericAttribute`, `GlobalScope`, `GotoStmt`, `Handler`, `Handlers`, `IdExpr`, `IfDeclStmt`, `IfStmt`, `IndexDesignator`, `IndexExpr`, `InitClause`, `InitializedCapture`, `InitializedDeclarator`, `InitializerExpr`, `Initializers`, `KRFuncDeclarator`, `Label`, `LabeledStmt`, `LambdaDeclarator`, `LambdaExpr`, `LambdaIntroducer`, `LeaveStmt`, `LinkageSpec`, `LiteralExpr`, `MaybeCtorInitializer`, `MaybeDeclarator`, `MaybeException`, `MaybeExceptionSpec`, `MaybeLambdaDeclarator`, `MaybeNewInitializer`, `MaybeTypeId`, `MemberDecl`, `MemberDecls`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `MemberInitializer`, `MemberInitializers`, `MemberTemplate`, `MemberUsingDecl`, `Name`, `NameDeclarator`, `NameSpec`, `NamespaceAlias`, `NamespaceDecl`, `NewExpr`, `NewInitializer`, `NoAttribute`, `NoAttributeSpec`, `NoBaseSpec`, `NoCapture`, `NoCtorInitializer`, `NoDeclOrStmt`, `NoDeclSpec`, `NoDeclarator`, `NoDesignator`, `NoEnumerator`, `NoException`, `NoExceptionSpec`, `NoExpr`, `NoHandler`, `NoInitializer`, `NoLambdaDeclarator`, `NoMemberDecl`, `NoMemberInitializer`, `NoName`, `NoNameQualifier`, `NoNewInitializer`, `NoParamName`, `NoPropertyFunc`, `NoTemplateArg`, `NoTemplateParam`, `NoTypeId`, `Node`, `NullptrLiteralExpr`, `OpFunc`, `Param`, `ParamName`, `ParamNames`, `ParensDeclarator`, `ParensExpr`, `PromisedFuncBody`, `PromisedMemberDecl`, `PropertyAttribute`, `PropertyFuncs`, `PropertyGetFunc`, `PropertyPutFunc`, `PseudoDtor`, `PtrDeclarator`, `QualifiedName`, `QualifiedPseudoDtor`, `RangeDesignator`, `ReservedTypeSpec`, `ReturnStmt`, `SizeOfExpr`, `SpecialCastExpr`, `StaticAssertDecl`, `StmtExpr`, `StorageClass`, `StringLiteralExpr`, `SuffixFunc`, `SuperScope`, `SwitchDeclStmt`, `SwitchStmt`, `TemplateArgs`, `TemplateDecl`, `TemplateName`, `TemplateParam`, `TemplateParams`, `TemplateSpec`, `TemplateTypeArg`, `TemplateTypeParam`, `ThisExpr`, `ThrowExpr`, `TranslationUnit`, `TruncatedInitClause`, `TryExceptStmt`, `TryFinallyStmt`, `TryStmt`, `TypeAdjective`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfExpr`, `TypeOfSpec`, `TypeOfType`, `TypeParam`, `TypeTypeIdExpr`, `UnaryExpr`, `UnparsedDecl`, `UnparsedDeclSpec`, `UnparsedDeclarator`, `UnparsedEnumerator`, `UnparsedException`, `UnparsedExpr`, `UnparsedInitializer`, `UnparsedLabel`, `UnparsedMemberDecl`, `UnparsedName`, `UnparsedNameQualifier`, `UnparsedParamName`, `UnparsedPropertyFunc`, `UnparsedStmt`, `UnqualifiedName`, `UserLiteralExpr`, `UserStringLiteralExpr`, `UsingDecl`, `UsingDirective`, `WhileDeclStmt`, `WhileStmt`.
- Function `isFromMacro()`: Checks if the current AST node is a part of a code fragment, that was inserted by preprocessor by expanding a macro. Terms that come from macro arguments are considered to be a part of macro expansion as well.. It can only be applied on nodes of type: `AccessSpecification`, `AliasDecl`, `AlignAsExpr`, `AlignAsType`, `AlignOfExpr`, `AnyAttribute`, `AnyCapture`, `AnyDecl`, `AnyDeclarator`, `AnyDesignator`, `AnyEnumerator`, `AnyExpr`, `AnyFuncBody`, `AnyInitializer`, `AnyLabel`, `AnyMemberDecl`, `AnyName`, `AnyNameQualifier`, `AnyNameSpec`, `AnyNames`, `AnyNonPtrDeclarator`, `AnyParamName`, `AnyPropertyFunc`, `AnyPseudoDtor`, `AnyStmt`, `AnyTemplateArg`, `AnyTypeName`, `AnyTypeOf`, `AnyTypeParam`, `AnyUsing`, `ArrayDeclarator`, `AsmDef`, `AsmStmt`, `Attribute`, `AttributeDeclSpec`, `AttributeSpec`, `AttributeSpecs`, `AttributeWithArgs`, `AttributedDeclarator`, `Attributes`, `AutoType`, `BaseSpec`, `BaseSpecs`, `BinaryExpr`, `BitFieldDeclarator`, `BoolLiteralExpr`, `BreakStmt`, `BuiltinType`, `CVQualifier`, `CallExpr`, `Capture`, `CaptureDefault`, `CaseLabel`, `CaseRangeLabel`, `CastExpr`, `ClassType`, `CompoundStmt`, `ConditionalExpr`, `ConstExpr`, `ContinueStmt`, `ConvFunc`, `CopyInitializer`, `CtorInitializer`, `Decl`, `DeclEllipsis`, `DeclOrStmt`, `DeclOrStmts`, `DeclSpec`, `DeclSpecs`, `DefaultException`, `DefaultLabel`, `DeleteExpr`, `DenyThrowSpec`, `Designators`, `DirectInitializer`, `DoDeclStmt`, `DoStmt`, `Dtor`, `EnumType`, `Enumerator`, `Enumerators`, `ExceptHandler`, `Exception`, `ExceptionSpec`, `ExplicitInstantiation`, `ExprArg`, `ExprStmt`, `ExprTypeIdExpr`, `Exprs`, `FieldDesignator`, `FinallyHandler`, `ForEachStmt`, `ForRangeStmt`, `ForStmt`, `FuncBody`, `FuncDeclarator`, `FuncDef`, `FuncSpec`, `FuncTryBlock`, `GenericAttribute`, `GlobalScope`, `GotoStmt`, `Handler`, `Handlers`, `IdExpr`, `IfDeclStmt`, `IfStmt`, `IndexDesignator`, `IndexExpr`, `InitClause`, `InitializedCapture`, `InitializedDeclarator`, `InitializerExpr`, `Initializers`, `KRFuncDeclarator`, `Label`, `LabeledStmt`, `LambdaDeclarator`, `LambdaExpr`, `LambdaIntroducer`, `LeaveStmt`, `LinkageSpec`, `LiteralExpr`, `MaybeCtorInitializer`, `MaybeDeclarator`, `MaybeException`, `MaybeExceptionSpec`, `MaybeLambdaDeclarator`, `MaybeNewInitializer`, `MaybeTypeId`, `MemberDecl`, `MemberDecls`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `MemberInitializer`, `MemberInitializers`, `MemberTemplate`, `MemberUsingDecl`, `Name`, `NameDeclarator`, `NameSpec`, `NamespaceAlias`, `NamespaceDecl`, `NewExpr`, `NewInitializer`, `NoAttribute`, `NoAttributeSpec`, `NoBaseSpec`, `NoCapture`, `NoCtorInitializer`, `NoDeclOrStmt`, `NoDeclSpec`, `NoDeclarator`, `NoDesignator`, `NoEnumerator`, `NoException`, `NoExceptionSpec`, `NoExpr`, `NoHandler`, `NoInitializer`, `NoLambdaDeclarator`, `NoMemberDecl`, `NoMemberInitializer`, `NoName`, `NoNameQualifier`, `NoNewInitializer`, `NoParamName`, `NoPropertyFunc`, `NoTemplateArg`, `NoTemplateParam`, `NoTypeId`, `Node`, `NullptrLiteralExpr`, `OpFunc`, `Param`, `ParamName`, `ParamNames`, `ParensDeclarator`, `ParensExpr`, `PromisedFuncBody`, `PromisedMemberDecl`, `PropertyAttribute`, `PropertyFuncs`, `PropertyGetFunc`, `PropertyPutFunc`, `PseudoDtor`, `PtrDeclarator`, `QualifiedName`, `QualifiedPseudoDtor`, `RangeDesignator`, `ReservedTypeSpec`, `ReturnStmt`, `SizeOfExpr`, `SpecialCastExpr`, `StaticAssertDecl`, `StmtExpr`, `StorageClass`, `StringLiteralExpr`, `SuffixFunc`, `SuperScope`, `SwitchDeclStmt`, `SwitchStmt`, `TemplateArgs`, `TemplateDecl`, `TemplateName`, `TemplateParam`, `TemplateParams`, `TemplateSpec`, `TemplateTypeArg`, `TemplateTypeParam`, `ThisExpr`, `ThrowExpr`, `TranslationUnit`, `TruncatedInitClause`, `TryExceptStmt`, `TryFinallyStmt`, `TryStmt`, `TypeAdjective`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfExpr`, `TypeOfSpec`, `TypeOfType`, `TypeParam`, `TypeTypeIdExpr`, `UnaryExpr`, `UnparsedDecl`, `UnparsedDeclSpec`, `UnparsedDeclarator`, `UnparsedEnumerator`, `UnparsedException`, `UnparsedExpr`, `UnparsedInitializer`, `UnparsedLabel`, `UnparsedMemberDecl`, `UnparsedName`, `UnparsedNameQualifier`, `UnparsedParamName`, `UnparsedPropertyFunc`, `UnparsedStmt`, `UnqualifiedName`, `UserLiteralExpr`, `UserStringLiteralExpr`, `UsingDecl`, `UsingDirective`, `WhileDeclStmt`, `WhileStmt`.
- Function `isFunction()`: Checks if the current AST node declares a function, or is an expression that evaluates to a function.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isFunctionInstantiation()`: Checks if the current AST node declares a function template instantiation.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `isFunctionSpecialization()`: Checks if the current AST node declares a function template specialization.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `isFunctionTemplate()`: Checks if the current AST node declares a function template.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `Enumerator`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `isFuncType()`: Checks if the current AST node declares something of a function type or is an expression whose value is of a function type.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isGlobal()`: Checks if the current AST node declares a global variable or function, or is an expression that refers to a global variable or function.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `KRFuncDeclarator`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `isIncluded()`: Checks if the current AST node corresponds to a code fragment, that belongs to an included header file.. It can only be applied on nodes of type: `AccessSpecification`, `AliasDecl`, `AlignAsExpr`, `AlignAsType`, `AlignOfExpr`, `AnyAttribute`, `AnyCapture`, `AnyDecl`, `AnyDeclarator`, `AnyDesignator`, `AnyEnumerator`, `AnyExpr`, `AnyFuncBody`, `AnyInitializer`, `AnyLabel`, `AnyMemberDecl`, `AnyName`, `AnyNameQualifier`, `AnyNameSpec`, `AnyNames`, `AnyNonPtrDeclarator`, `AnyParamName`, `AnyPropertyFunc`, `AnyPseudoDtor`, `AnyStmt`, `AnyTemplateArg`, `AnyTypeName`, `AnyTypeOf`, `AnyTypeParam`, `AnyUsing`, `ArrayDeclarator`, `AsmDef`, `AsmStmt`, `Attribute`, `AttributeDeclSpec`, `AttributeSpec`, `AttributeSpecs`, `AttributeWithArgs`, `AttributedDeclarator`, `Attributes`, `AutoType`, `BaseSpec`, `BaseSpecs`, `BinaryExpr`, `BitFieldDeclarator`, `BoolLiteralExpr`, `BreakStmt`, `BuiltinType`, `CVQualifier`, `CallExpr`, `Capture`, `CaptureDefault`, `CaseLabel`, `CaseRangeLabel`, `CastExpr`, `ClassType`, `CompoundStmt`, `ConditionalExpr`, `ConstExpr`, `ContinueStmt`, `ConvFunc`, `CopyInitializer`, `CtorInitializer`, `Decl`, `DeclEllipsis`, `DeclOrStmt`, `DeclOrStmts`, `DeclSpec`, `DeclSpecs`, `DefaultException`, `DefaultLabel`, `DeleteExpr`, `DenyThrowSpec`, `Designators`, `DirectInitializer`, `DoDeclStmt`, `DoStmt`, `Dtor`, `EnumType`, `Enumerator`, `Enumerators`, `ExceptHandler`, `Exception`, `ExceptionSpec`, `ExplicitInstantiation`, `ExprArg`, `ExprStmt`, `ExprTypeIdExpr`, `Exprs`, `FieldDesignator`, `FinallyHandler`, `ForEachStmt`, `ForRangeStmt`, `ForStmt`, `FuncBody`, `FuncDeclarator`, `FuncDef`, `FuncSpec`, `FuncTryBlock`, `GenericAttribute`, `GlobalScope`, `GotoStmt`, `Handler`, `Handlers`, `IdExpr`, `IfDeclStmt`, `IfStmt`, `IndexDesignator`, `IndexExpr`, `InitClause`, `InitializedCapture`, `InitializedDeclarator`, `InitializerExpr`, `Initializers`, `KRFuncDeclarator`, `Label`, `LabeledStmt`, `LambdaDeclarator`, `LambdaExpr`, `LambdaIntroducer`, `LeaveStmt`, `LinkageSpec`, `LiteralExpr`, `MaybeCtorInitializer`, `MaybeDeclarator`, `MaybeException`, `MaybeExceptionSpec`, `MaybeLambdaDeclarator`, `MaybeNewInitializer`, `MaybeTypeId`, `MemberDecl`, `MemberDecls`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `MemberInitializer`, `MemberInitializers`, `MemberTemplate`, `MemberUsingDecl`, `Name`, `NameDeclarator`, `NameSpec`, `NamespaceAlias`, `NamespaceDecl`, `NewExpr`, `NewInitializer`, `NoAttribute`, `NoAttributeSpec`, `NoBaseSpec`, `NoCapture`, `NoCtorInitializer`, `NoDeclOrStmt`, `NoDeclSpec`, `NoDeclarator`, `NoDesignator`, `NoEnumerator`, `NoException`, `NoExceptionSpec`, `NoExpr`, `NoHandler`, `NoInitializer`, `NoLambdaDeclarator`, `NoMemberDecl`, `NoMemberInitializer`, `NoName`, `NoNameQualifier`, `NoNewInitializer`, `NoParamName`, `NoPropertyFunc`, `NoTemplateArg`, `NoTemplateParam`, `NoTypeId`, `Node`, `NullptrLiteralExpr`, `OpFunc`, `Param`, `ParamName`, `ParamNames`, `ParensDeclarator`, `ParensExpr`, `PromisedFuncBody`, `PromisedMemberDecl`, `PropertyAttribute`, `PropertyFuncs`, `PropertyGetFunc`, `PropertyPutFunc`, `PseudoDtor`, `PtrDeclarator`, `QualifiedName`, `QualifiedPseudoDtor`, `RangeDesignator`, `ReservedTypeSpec`, `ReturnStmt`, `SizeOfExpr`, `SpecialCastExpr`, `StaticAssertDecl`, `StmtExpr`, `StorageClass`, `StringLiteralExpr`, `SuffixFunc`, `SuperScope`, `SwitchDeclStmt`, `SwitchStmt`, `TemplateArgs`, `TemplateDecl`, `TemplateName`, `TemplateParam`, `TemplateParams`, `TemplateSpec`, `TemplateTypeArg`, `TemplateTypeParam`, `ThisExpr`, `ThrowExpr`, `TranslationUnit`, `TruncatedInitClause`, `TryExceptStmt`, `TryFinallyStmt`, `TryStmt`, `TypeAdjective`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfExpr`, `TypeOfSpec`, `TypeOfType`, `TypeParam`, `TypeTypeIdExpr`, `UnaryExpr`, `UnparsedDecl`, `UnparsedDeclSpec`, `UnparsedDeclarator`, `UnparsedEnumerator`, `UnparsedException`, `UnparsedExpr`, `UnparsedInitializer`, `UnparsedLabel`, `UnparsedMemberDecl`, `UnparsedName`, `UnparsedNameQualifier`, `UnparsedParamName`, `UnparsedPropertyFunc`, `UnparsedStmt`, `UnqualifiedName`, `UserLiteralExpr`, `UserStringLiteralExpr`, `UsingDecl`, `UsingDirective`, `WhileDeclStmt`, `WhileStmt`.
- Function `isInline()`: Checks if the current AST node declares an inline function, or is an expression that refers to static function.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `Enumerator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `KRFuncDeclarator`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `isInstantiation()`: Checks if the current AST node declares a class or function template instantiation.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `isIntegral()`: Checks if current AST node declares something of integral type, or is an expression whose value is of integral type ('char', 'int', 'unsigned long int', etc.). It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isLvalueReference()`: Checks if the current AST node declares an lvalue reference, or is an expression that evaluates to an lvalue reference.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isMacroDefined()`: Checks if the macro whose name is provided as an argument, is defined at the end of preprocessing.
- Function `isOpFunc()`: Checks if the current node declares an overloaded operator.. It can only be applied on nodes of type: `ArrayDeclarator`, `Exception`, `ExplicitInstantiation`, `FuncDeclarator`, `FuncDef`, `KRFuncDeclarator`, `MemberFunc`, `ParensDeclarator`.
- Function `isOverloaded()`: Checks if the current operation AST node refers to an overloaded operation.
- Function `isPadded()`: Checks if the current AST node is a padded class/struct.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `ThisExpr`, `ThrowExpr`, `TypeConvExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isPODType()`: Checks if the current AST node declares a POD type, or is an expression of a POD type.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isPointer()`: Checks if the current AST node declares a pointer, or is an expression that evaluates to a pointer.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isPolymorphic()`: Checks if the current AST node corresponds to a polymorphic class type or to an expression of a polymorphic class type.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isPrivate()`: Checks if the current AST node declares a private member variable/function/type, or is an expression that refers to private member.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `Enumerator`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `KRFuncDeclarator`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `isProtected()`: Checks if the current AST node declares a protected member variable/function/type, or is an expression that refers to protected member.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `Enumerator`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `KRFuncDeclarator`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `isPublic()`: Checks if the current AST node declares a public member variable/function/type, or is an expression that refers to public member.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `Enumerator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `KRFuncDeclarator`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `isReference()`: Checks if the current AST node declares a reference, or is an expression that evaluates to a reference.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isRvalueReference()`: Checks if the current AST node declares an rvalue reference, or is an expression that evaluates to an rvalue reference.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isSigned()`: Checks if the current AST node declares an entity of signed integer-valued type, or is an expression whose value is of signed integer-valued type.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isSignedInt()`: Checks if the current AST node declares something of type 'signed int', or is an expression whose value is of type 'signed int'.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isSimpleStruct()`: Checks if the current AST node declares a struct with no methods, no base classes and fileds of builtin types only, or is an expression of such type.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isSpecialization()`: Checks if the current AST node declares a class or function template specialization.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `isStatic()`: Checks if the current AST node declares a static variable/function, or is an expression that refers to static variable/function.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `Enumerator`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `KRFuncDeclarator`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `isStructType()`: Checks if the current AST node declares a struct (but not a class or a union), or is an expression whose value is of struct type.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isTemplate()`: Checks if the current AST node declares a class or function template.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `Enumerator`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `isTypedef()`: Checks if the current AST node declares a typedef, or is an expression whose value is of typedef type.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isTypeParameter()`: Checks if the current AST node declares a template type parameter, or is an expression whose value is of template parameter type.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isUnionType()`: Checks if the current AST node declares a union (but not a struct or a class), or is an expression whose value is of union type.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isUnsigned()`: Checks if the current AST node declares an entity of unsigned integer-valued type, or is an expression whose value is of unsigned integer-valued type.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isVariable()`: Checks if the current AST node declares a variable, or is an expression that refers to a variable.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `KRFuncDeclarator`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `isVirtual()`: Checks if the current AST node declares a virtual member function, or is an expression that refers to virtual member function.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `Enumerator`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `KRFuncDeclarator`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `isVolatile()`: Checks if the current AST node declares a volatile variable, or is an expression that refers to volatile variable.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `BinaryExpr`, `BoolLiteralExpr`, `CallExpr`, `CastExpr`, `ConditionalExpr`, `DeleteExpr`, `Enumerator`, `ExprTypeIdExpr`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `InitializerExpr`, `KRFuncDeclarator`, `LiteralExpr`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `NewExpr`, `ParensDeclarator`, `ParensExpr`, `QualifiedName`, `SizeOfExpr`, `SpecialCastExpr`, `StmtExpr`, `StringLiteralExpr`, `TemplateTypeArg`, `ThisExpr`, `ThrowExpr`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UnaryExpr`, `UsingDecl`, `UsingDirective`.
- Function `isWeak()`: Checks if the current AST node is a function declaration containing 'weak' attribute.. It can only be applied on nodes of type: `AnyUsing`, `ArrayDeclarator`, `CallExpr`, `CastExpr`, `Enumerator`, `FieldDesignator`, `FuncDeclarator`, `FuncDef`, `IdExpr`, `IndexExpr`, `KRFuncDeclarator`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `Name`, `NameSpec`, `NamespaceAlias`, `ParensDeclarator`, `QualifiedName`, `TemplateTypeArg`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfType`, `TypeTypeIdExpr`, `UsingDecl`, `UsingDirective`.
- Function `isWideString()`: Returns true if the given string literal is a wide string. It can only be applied on nodes of type: `StringLiteralExpr`.
- Function `length()`: Returns length of the string.
- Function `matches()`: Checks if the first argument matches a regular expression specified as the second argument.
- Function `matches-nocase()`: Checks if the first argument matches a regular expression specified as the second argument without paying attention to characters' case.
- Function `name()`: Returns the type name of the current AST node.. It can only be applied on nodes of type: `AccessSpecification`, `AliasDecl`, `AlignAsExpr`, `AlignAsType`, `AlignOfExpr`, `AnyAttribute`, `AnyCapture`, `AnyDecl`, `AnyDeclarator`, `AnyDesignator`, `AnyEnumerator`, `AnyExpr`, `AnyFuncBody`, `AnyInitializer`, `AnyLabel`, `AnyMemberDecl`, `AnyName`, `AnyNameQualifier`, `AnyNameSpec`, `AnyNames`, `AnyNonPtrDeclarator`, `AnyParamName`, `AnyPropertyFunc`, `AnyPseudoDtor`, `AnyStmt`, `AnyTemplateArg`, `AnyTypeName`, `AnyTypeOf`, `AnyTypeParam`, `AnyUsing`, `ArrayDeclarator`, `AsmDef`, `AsmStmt`, `Attribute`, `AttributeDeclSpec`, `AttributeSpec`, `AttributeSpecs`, `AttributeWithArgs`, `AttributedDeclarator`, `Attributes`, `AutoType`, `BaseSpec`, `BaseSpecs`, `BinaryExpr`, `BitFieldDeclarator`, `BoolLiteralExpr`, `BreakStmt`, `BuiltinType`, `CVQualifier`, `CallExpr`, `Capture`, `CaptureDefault`, `CaseLabel`, `CaseRangeLabel`, `CastExpr`, `ClassType`, `CompoundStmt`, `ConditionalExpr`, `ConstExpr`, `ContinueStmt`, `ConvFunc`, `CopyInitializer`, `CtorInitializer`, `Decl`, `DeclEllipsis`, `DeclOrStmt`, `DeclOrStmts`, `DeclSpec`, `DeclSpecs`, `DefaultException`, `DefaultLabel`, `DeleteExpr`, `DenyThrowSpec`, `Designators`, `DirectInitializer`, `DoDeclStmt`, `DoStmt`, `Dtor`, `EnumType`, `Enumerator`, `Enumerators`, `ExceptHandler`, `Exception`, `ExceptionSpec`, `ExplicitInstantiation`, `ExprArg`, `ExprStmt`, `ExprTypeIdExpr`, `Exprs`, `FieldDesignator`, `FinallyHandler`, `ForEachStmt`, `ForRangeStmt`, `ForStmt`, `FuncBody`, `FuncDeclarator`, `FuncDef`, `FuncSpec`, `FuncTryBlock`, `GenericAttribute`, `GlobalScope`, `GotoStmt`, `Handler`, `Handlers`, `IdExpr`, `IfDeclStmt`, `IfStmt`, `IndexDesignator`, `IndexExpr`, `InitClause`, `InitializedCapture`, `InitializedDeclarator`, `InitializerExpr`, `Initializers`, `KRFuncDeclarator`, `Label`, `LabeledStmt`, `LambdaDeclarator`, `LambdaExpr`, `LambdaIntroducer`, `LeaveStmt`, `LinkageSpec`, `LiteralExpr`, `MaybeCtorInitializer`, `MaybeDeclarator`, `MaybeException`, `MaybeExceptionSpec`, `MaybeLambdaDeclarator`, `MaybeNewInitializer`, `MaybeTypeId`, `MemberDecl`, `MemberDecls`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `MemberInitializer`, `MemberInitializers`, `MemberTemplate`, `MemberUsingDecl`, `Name`, `NameDeclarator`, `NameSpec`, `NamespaceAlias`, `NamespaceDecl`, `NewExpr`, `NewInitializer`, `NoAttribute`, `NoAttributeSpec`, `NoBaseSpec`, `NoCapture`, `NoCtorInitializer`, `NoDeclOrStmt`, `NoDeclSpec`, `NoDeclarator`, `NoDesignator`, `NoEnumerator`, `NoException`, `NoExceptionSpec`, `NoExpr`, `NoHandler`, `NoInitializer`, `NoLambdaDeclarator`, `NoMemberDecl`, `NoMemberInitializer`, `NoName`, `NoNameQualifier`, `NoNewInitializer`, `NoParamName`, `NoPropertyFunc`, `NoTemplateArg`, `NoTemplateParam`, `NoTypeId`, `Node`, `NullptrLiteralExpr`, `OpFunc`, `Param`, `ParamName`, `ParamNames`, `ParensDeclarator`, `ParensExpr`, `PromisedFuncBody`, `PromisedMemberDecl`, `PropertyAttribute`, `PropertyFuncs`, `PropertyGetFunc`, `PropertyPutFunc`, `PseudoDtor`, `PtrDeclarator`, `QualifiedName`, `QualifiedPseudoDtor`, `RangeDesignator`, `ReservedTypeSpec`, `ReturnStmt`, `SizeOfExpr`, `SpecialCastExpr`, `StaticAssertDecl`, `StmtExpr`, `StorageClass`, `StringLiteralExpr`, `SuffixFunc`, `SuperScope`, `SwitchDeclStmt`, `SwitchStmt`, `TemplateArgs`, `TemplateDecl`, `TemplateName`, `TemplateParam`, `TemplateParams`, `TemplateSpec`, `TemplateTypeArg`, `TemplateTypeParam`, `ThisExpr`, `ThrowExpr`, `TranslationUnit`, `TruncatedInitClause`, `TryExceptStmt`, `TryFinallyStmt`, `TryStmt`, `TypeAdjective`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfExpr`, `TypeOfSpec`, `TypeOfType`, `TypeParam`, `TypeTypeIdExpr`, `UnaryExpr`, `UnparsedDecl`, `UnparsedDeclSpec`, `UnparsedDeclarator`, `UnparsedEnumerator`, `UnparsedException`, `UnparsedExpr`, `UnparsedInitializer`, `UnparsedLabel`, `UnparsedMemberDecl`, `UnparsedName`, `UnparsedNameQualifier`, `UnparsedParamName`, `UnparsedPropertyFunc`, `UnparsedStmt`, `UnqualifiedName`, `UserLiteralExpr`, `UserStringLiteralExpr`, `UsingDecl`, `UsingDirective`, `WhileDeclStmt`, `WhileStmt`.
- Function `pretty()`: Returns string containing C/C++ code that correspond to the provided AST node.. It can only be applied on nodes of type: `AccessSpecification`, `AliasDecl`, `AlignAsExpr`, `AlignAsType`, `AlignOfExpr`, `AnyAttribute`, `AnyCapture`, `AnyDecl`, `AnyDeclarator`, `AnyDesignator`, `AnyEnumerator`, `AnyExpr`, `AnyFuncBody`, `AnyInitializer`, `AnyLabel`, `AnyMemberDecl`, `AnyName`, `AnyNameQualifier`, `AnyNameSpec`, `AnyNames`, `AnyNonPtrDeclarator`, `AnyParamName`, `AnyPropertyFunc`, `AnyPseudoDtor`, `AnyStmt`, `AnyTemplateArg`, `AnyTypeName`, `AnyTypeOf`, `AnyTypeParam`, `AnyUsing`, `ArrayDeclarator`, `AsmDef`, `AsmStmt`, `Attribute`, `AttributeDeclSpec`, `AttributeSpec`, `AttributeSpecs`, `AttributeWithArgs`, `AttributedDeclarator`, `Attributes`, `AutoType`, `BaseSpec`, `BaseSpecs`, `BinaryExpr`, `BitFieldDeclarator`, `BoolLiteralExpr`, `BreakStmt`, `BuiltinType`, `CVQualifier`, `CallExpr`, `Capture`, `CaptureDefault`, `CaseLabel`, `CaseRangeLabel`, `CastExpr`, `ClassType`, `CompoundStmt`, `ConditionalExpr`, `ConstExpr`, `ContinueStmt`, `ConvFunc`, `CopyInitializer`, `CtorInitializer`, `Decl`, `DeclEllipsis`, `DeclOrStmt`, `DeclOrStmts`, `DeclSpec`, `DeclSpecs`, `DefaultException`, `DefaultLabel`, `DeleteExpr`, `DenyThrowSpec`, `Designators`, `DirectInitializer`, `DoDeclStmt`, `DoStmt`, `Dtor`, `EnumType`, `Enumerator`, `Enumerators`, `ExceptHandler`, `Exception`, `ExceptionSpec`, `ExplicitInstantiation`, `ExprArg`, `ExprStmt`, `ExprTypeIdExpr`, `Exprs`, `FieldDesignator`, `FinallyHandler`, `ForEachStmt`, `ForRangeStmt`, `ForStmt`, `FuncBody`, `FuncDeclarator`, `FuncDef`, `FuncSpec`, `FuncTryBlock`, `GenericAttribute`, `GlobalScope`, `GotoStmt`, `Handler`, `Handlers`, `IdExpr`, `IfDeclStmt`, `IfStmt`, `IndexDesignator`, `IndexExpr`, `InitClause`, `InitializedCapture`, `InitializedDeclarator`, `InitializerExpr`, `Initializers`, `KRFuncDeclarator`, `Label`, `LabeledStmt`, `LambdaDeclarator`, `LambdaExpr`, `LambdaIntroducer`, `LeaveStmt`, `LinkageSpec`, `LiteralExpr`, `MaybeCtorInitializer`, `MaybeDeclarator`, `MaybeException`, `MaybeExceptionSpec`, `MaybeLambdaDeclarator`, `MaybeNewInitializer`, `MaybeTypeId`, `MemberDecl`, `MemberDecls`, `MemberDesignator`, `MemberExpr`, `MemberFunc`, `MemberInitializer`, `MemberInitializers`, `MemberTemplate`, `MemberUsingDecl`, `Name`, `NameDeclarator`, `NameSpec`, `NamespaceAlias`, `NamespaceDecl`, `NewExpr`, `NewInitializer`, `NoAttribute`, `NoAttributeSpec`, `NoBaseSpec`, `NoCapture`, `NoCtorInitializer`, `NoDeclOrStmt`, `NoDeclSpec`, `NoDeclarator`, `NoDesignator`, `NoEnumerator`, `NoException`, `NoExceptionSpec`, `NoExpr`, `NoHandler`, `NoInitializer`, `NoLambdaDeclarator`, `NoMemberDecl`, `NoMemberInitializer`, `NoName`, `NoNameQualifier`, `NoNewInitializer`, `NoParamName`, `NoPropertyFunc`, `NoTemplateArg`, `NoTemplateParam`, `NoTypeId`, `Node`, `NullptrLiteralExpr`, `OpFunc`, `Param`, `ParamName`, `ParamNames`, `ParensDeclarator`, `ParensExpr`, `PromisedFuncBody`, `PromisedMemberDecl`, `PropertyAttribute`, `PropertyFuncs`, `PropertyGetFunc`, `PropertyPutFunc`, `PseudoDtor`, `PtrDeclarator`, `QualifiedName`, `QualifiedPseudoDtor`, `RangeDesignator`, `ReservedTypeSpec`, `ReturnStmt`, `SizeOfExpr`, `SpecialCastExpr`, `StaticAssertDecl`, `StmtExpr`, `StorageClass`, `StringLiteralExpr`, `SuffixFunc`, `SuperScope`, `SwitchDeclStmt`, `SwitchStmt`, `TemplateArgs`, `TemplateDecl`, `TemplateName`, `TemplateParam`, `TemplateParams`, `TemplateSpec`, `TemplateTypeArg`, `TemplateTypeParam`, `ThisExpr`, `ThrowExpr`, `TranslationUnit`, `TruncatedInitClause`, `TryExceptStmt`, `TryFinallyStmt`, `TryStmt`, `TypeAdjective`, `TypeArg`, `TypeConvExpr`, `TypeId`, `TypeName`, `TypeOfExpr`, `TypeOfSpec`, `TypeOfType`, `TypeParam`, `TypeTypeIdExpr`, `UnaryExpr`, `UnparsedDecl`, `UnparsedDeclSpec`, `UnparsedDeclarator`, `UnparsedEnumerator`, `UnparsedException`, `UnparsedExpr`, `UnparsedInitializer`, `UnparsedLabel`, `UnparsedMemberDecl`, `UnparsedName`, `UnparsedNameQualifier`, `UnparsedParamName`, `UnparsedPropertyFunc`, `UnparsedStmt`, `UnqualifiedName`, `UserLiteralExpr`, `UserStringLiteralExpr`, `UsingDecl`, `UsingDirective`, `WhileDeclStmt`, `WhileStmt`.
- Function `print()`: Prints its argument and returns true.
- Function `replace()`: Finds the first substring matching a regular expression specified as the second argument in the first argument and then replaces it with the third argument.
- Function `replace-nocase()`: Finds the first substring matching a regular expression specified as the second argument in the first argument and then replaces it with the third argument. No attention is paid to characters' case when matching the pattern.
- Function `starts-from-capital()`: Checks if the string starts from upper case letter.
- Function `starts-with()`: Checks if the second argument is a prefix of the first argument.
- Function `starts-with-nocase()`: Checks if the second argument is a prefix of the first argument. Individual characters of two strings are being compared case-insensitively.
- Function `substring()`: Returns the substring of the first argument that starts from the position specified as the second argument and has length specified as the third argument. If the last argument is omitted, the resulting substring extends to the end of the initial string.
- Function `this()`: Returns a pointer to the current AST node.

You can not call any function, that is not a part of the above list. Do not try to come up with similar function names from the above list. Only the above mentioned functions are defined in KAST API.


- Only functions that can be applied on node `AlignOfExpr` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AttributeDeclSpec` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `Enumerators` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AccessSpecification` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `StringLiteralExpr` are: `assembleString()`, `comesFromMacro()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassType()`, `isConstant()`, `isConst()`, `isEnum()`, `isFloatPoint()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFuncType()`, `isIncluded()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isStructType()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVolatile()`, `isWideString()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AliasDecl` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AlignAsExpr` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `CallExpr` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfActualParams()`, `getNumberOfFormalParams()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasCompleteDefinition()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassInstantiation()`, `isClassMember()`, `isClassSpecialization()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isDefinition()`, `isDerivedFrom()`, `isDerived()`, `isEnum()`, `isExtern()`, `isFloatPoint()`, `isFriend()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionInstantiation()`, `isFunctionSpecialization()`, `isFunctionTemplate()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isInline()`, `isInstantiation()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isSpecialization()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `DenyThrowSpec` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AlignAsType` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AnyAttribute` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AnyCapture` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `CaseLabel` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `ArrayDeclarator` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasCompleteDefinition()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isAssignmentOperator()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassInstantiation()`, `isClassMember()`, `isClassSpecialization()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isConstructor()`, `isConvFunc()`, `isCopyConstructor()`, `isDefinition()`, `isDerivedFrom()`, `isDerived()`, `isDestructor()`, `isEnum()`, `isExplicit()`, `isExtern()`, `isFloatPoint()`, `isFriend()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionInstantiation()`, `isFunctionSpecialization()`, `isFunctionTemplate()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isInline()`, `isInstantiation()`, `isIntegral()`, `isLvalueReference()`, `isOpFunc()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isSpecialization()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `StaticAssertDecl` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AnyDecl` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `FuncDef` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasCompleteDefinition()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isAssignmentOperator()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassInstantiation()`, `isClassMember()`, `isClassSpecialization()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isConstructor()`, `isConvFunc()`, `isCopyConstructor()`, `isDefinition()`, `isDerivedFrom()`, `isDerived()`, `isDestructor()`, `isEnum()`, `isExplicit()`, `isExtern()`, `isFloatPoint()`, `isFriend()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionInstantiation()`, `isFunctionSpecialization()`, `isFunctionTemplate()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isInline()`, `isInstantiation()`, `isIntegral()`, `isLvalueReference()`, `isOpFunc()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isSpecialization()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AnyPseudoDtor` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AnyDeclarator` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `Enumerator` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasCompleteDefinition()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassMember()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isDefinition()`, `isDerivedFrom()`, `isDerived()`, `isEnum()`, `isFloatPoint()`, `isFriend()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionTemplate()`, `isFuncType()`, `isIncluded()`, `isInline()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AnyDesignator` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AsmDef` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AnyFuncBody` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AnyEnumerator` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `BreakStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AutoType` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AnyPropertyFunc` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AnyTypeName` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `InitClause` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AnyExpr` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AnyInitializer` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `CtorInitializer` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `ConvFunc` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NoDeclSpec` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AnyLabel` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `TypeOfExpr` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `ForEachStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AnyMemberDecl` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AnyNameQualifier` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `ExprArg` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AnyName` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `CastExpr` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getFloatValue()`, `getInitialDefinedType()`, `getIntValue()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasCompleteDefinition()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassInstantiation()`, `isClassMember()`, `isClassSpecialization()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isDefinition()`, `isDerivedFrom()`, `isDerived()`, `isEnum()`, `isExtern()`, `isFloatPoint()`, `isFriend()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionInstantiation()`, `isFunctionSpecialization()`, `isFunctionTemplate()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isInline()`, `isInstantiation()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isSpecialization()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AnyNameSpec` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `TypeTypeIdExpr` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasCompleteDefinition()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassInstantiation()`, `isClassMember()`, `isClassSpecialization()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isDefinition()`, `isDerivedFrom()`, `isDerived()`, `isEnum()`, `isExtern()`, `isFloatPoint()`, `isFriend()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionInstantiation()`, `isFunctionSpecialization()`, `isFunctionTemplate()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isInline()`, `isInstantiation()`, `isIntegral()`, `isLvalueReference()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isSpecialization()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `PropertyFuncs` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `MaybeCtorInitializer` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `ClassType` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getDestructor()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `hasCompleteDefinition()`, `isCLanguage()`, `isDefinition()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AnyNames` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AnyNonPtrDeclarator` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `MemberInitializer` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `Capture` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AnyParamName` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `ConstExpr` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isConstExpr()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AnyStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AnyTemplateArg` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `CopyInitializer` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `MemberExpr` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getOperationCode()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasCompleteDefinition()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassInstantiation()`, `isClassMember()`, `isClassSpecialization()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isDefinition()`, `isDerivedFrom()`, `isDerived()`, `isEnum()`, `isExtern()`, `isFloatPoint()`, `isFriend()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionInstantiation()`, `isFunctionSpecialization()`, `isFunctionTemplate()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isInline()`, `isInstantiation()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isSpecialization()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `ExprStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `BuiltinType` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `PropertyAttribute` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AnyTypeOf` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `CompoundStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AnyTypeParam` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AnyUsing` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasCompleteDefinition()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassInstantiation()`, `isClassMember()`, `isClassSpecialization()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isDefinition()`, `isDerivedFrom()`, `isDerived()`, `isEnum()`, `isExtern()`, `isFloatPoint()`, `isFriend()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionInstantiation()`, `isFunctionSpecialization()`, `isFunctionTemplate()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isInline()`, `isInstantiation()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isSpecialization()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `TemplateArgs` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AsmStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `Attribute` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `ConditionalExpr` are: `comesFromMacro()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassType()`, `isConstant()`, `isConst()`, `isEnum()`, `isFloatPoint()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFuncType()`, `isIncluded()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isStructType()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVolatile()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AttributeSpec` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AttributeSpecs` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `DeclOrStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `CaptureDefault` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `UserLiteralExpr` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AttributeWithArgs` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `PropertyGetFunc` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `AttributedDeclarator` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `Attributes` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `CaseRangeLabel` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `BaseSpec` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `BaseSpecs` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `BinaryExpr` are: `comesFromMacro()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getFloatValue()`, `getInitialDefinedType()`, `getIntValue()`, `getLanguageType()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getOperationCode()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassType()`, `isConstant()`, `isConst()`, `isEnum()`, `isFloatPoint()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFuncType()`, `isIncluded()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isStructType()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVolatile()`, `name()` and `pretty()`.
- Only functions that can be applied on node `BitFieldDeclarator` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `BoolLiteralExpr` are: `comesFromMacro()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getFloatValue()`, `getInitialDefinedType()`, `getIntValue()`, `getLanguageType()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassType()`, `isConstant()`, `isConst()`, `isEnum()`, `isFloatPoint()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFuncType()`, `isIncluded()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isStructType()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVolatile()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NoTemplateArg` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `CVQualifier` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `ContinueStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `Decl` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isConstExpr()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `DeclEllipsis` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `DeclOrStmts` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `DeclSpec` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `ParensExpr` are: `comesFromMacro()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getFloatValue()`, `getInitialDefinedType()`, `getIntValue()`, `getLanguageType()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassType()`, `isConstant()`, `isConst()`, `isEnum()`, `isFloatPoint()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFuncType()`, `isIncluded()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isStructType()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVolatile()`, `name()` and `pretty()`.
- Only functions that can be applied on node `DeclSpecs` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NoTypeId` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `DefaultException` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `UnparsedNameQualifier` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `MemberDecls` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `DefaultLabel` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `DeleteExpr` are: `comesFromMacro()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassType()`, `isConstant()`, `isConst()`, `isEnum()`, `isFloatPoint()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFuncType()`, `isIncluded()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isStructType()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVolatile()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NamespaceDecl` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `Designators` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `DirectInitializer` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `DoDeclStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `DoStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `Dtor` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `EnumType` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `hasCompleteDefinition()`, `isCLanguage()`, `isDefinition()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `ExceptHandler` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `Exception` are: `comesFromMacro()`, `getFileName()`, `getName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isAssignmentOperator()`, `isCLanguage()`, `isConstructor()`, `isConvFunc()`, `isCopyConstructor()`, `isDestructor()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `isOpFunc()`, `name()` and `pretty()`.
- Only functions that can be applied on node `ExceptionSpec` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `ExplicitInstantiation` are: `comesFromMacro()`, `getFileName()`, `getName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isAssignmentOperator()`, `isCLanguage()`, `isConstructor()`, `isConvFunc()`, `isCopyConstructor()`, `isDestructor()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `isOpFunc()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NoMemberDecl` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `ExprTypeIdExpr` are: `comesFromMacro()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassType()`, `isConstant()`, `isConst()`, `isEnum()`, `isFloatPoint()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFuncType()`, `isIncluded()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isStructType()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVolatile()`, `name()` and `pretty()`.
- Only functions that can be applied on node `Exprs` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `FieldDesignator` are: `comesFromMacro()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassMember()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isDerivedFrom()`, `isDerived()`, `isEnum()`, `isFloatPoint()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionTemplate()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `FinallyHandler` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `ForRangeStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `PseudoDtor` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `ForStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `FuncBody` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `TryStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `FuncDeclarator` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasCompleteDefinition()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isAssignmentOperator()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassInstantiation()`, `isClassMember()`, `isClassSpecialization()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isConstructor()`, `isConvFunc()`, `isCopyConstructor()`, `isDefinition()`, `isDerivedFrom()`, `isDerived()`, `isDestructor()`, `isEnum()`, `isExplicit()`, `isExtern()`, `isFloatPoint()`, `isFriend()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionInstantiation()`, `isFunctionSpecialization()`, `isFunctionTemplate()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isInline()`, `isInstantiation()`, `isIntegral()`, `isLvalueReference()`, `isOpFunc()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isSpecialization()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `TemplateTypeParam` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `IfDeclStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `FuncSpec` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `FuncTryBlock` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `GenericAttribute` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `SuffixFunc` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `GlobalScope` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `InitializerExpr` are: `comesFromMacro()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassType()`, `isConstant()`, `isConst()`, `isEnum()`, `isFloatPoint()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFuncType()`, `isIncluded()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isStructType()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVolatile()`, `name()` and `pretty()`.
- Only functions that can be applied on node `GotoStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `Handler` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `Handlers` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `IdExpr` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getFloatValue()`, `getInitialDefinedType()`, `getIntValue()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getPrimaryTemplate()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasCompleteDefinition()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassInstantiation()`, `isClassMember()`, `isClassSpecialization()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isDefinition()`, `isDerivedFrom()`, `isDerived()`, `isEnum()`, `isExplicit()`, `isExtern()`, `isFloatPoint()`, `isFriend()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionInstantiation()`, `isFunctionSpecialization()`, `isFunctionTemplate()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isInline()`, `isInstantiation()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isSpecialization()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NoCtorInitializer` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `IfStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `ReturnStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `IndexDesignator` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `UnparsedExpr` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `StmtExpr` are: `comesFromMacro()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassType()`, `isConstant()`, `isConst()`, `isEnum()`, `isFloatPoint()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFuncType()`, `isIncluded()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isStructType()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVolatile()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NoBaseSpec` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `IndexExpr` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasCompleteDefinition()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassInstantiation()`, `isClassMember()`, `isClassSpecialization()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isDefinition()`, `isDerivedFrom()`, `isDerived()`, `isEnum()`, `isExtern()`, `isFloatPoint()`, `isFriend()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionInstantiation()`, `isFunctionSpecialization()`, `isFunctionTemplate()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isInline()`, `isInstantiation()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isSpecialization()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `InitializedCapture` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `InitializedDeclarator` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NoMemberInitializer` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `Initializers` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `KRFuncDeclarator` are: `comesFromMacro()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isAssignmentOperator()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassMember()`, `isClassType()`, `isConstant()`, `isConst()`, `isConstructor()`, `isConvFunc()`, `isCopyConstructor()`, `isDerivedFrom()`, `isDerived()`, `isDestructor()`, `isEnum()`, `isExtern()`, `isFloatPoint()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isInline()`, `isIntegral()`, `isLvalueReference()`, `isOpFunc()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isStatic()`, `isStructType()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `MemberUsingDecl` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `Label` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `LabeledStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `LambdaDeclarator` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `LambdaExpr` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `LambdaIntroducer` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `LeaveStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `LinkageSpec` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `LiteralExpr` are: `comesFromMacro()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getFloatValue()`, `getInitialDefinedType()`, `getIntValue()`, `getLanguageType()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCharacterLiteral()`, `isCLanguage()`, `isClass()`, `isClassType()`, `isConstant()`, `isConst()`, `isEnum()`, `isFloatPoint()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFuncType()`, `isIncluded()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isStructType()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVolatile()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NoExceptionSpec` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `MaybeDeclarator` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `MaybeException` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `MaybeExceptionSpec` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `MaybeLambdaDeclarator` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `MaybeNewInitializer` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `MaybeTypeId` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `MemberDecl` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getOverridenMethod()`, `getPositionInList()`, `isCLanguage()`, `isConstExpr()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `MemberDesignator` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasCompleteDefinition()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassInstantiation()`, `isClassMember()`, `isClassSpecialization()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isDefinition()`, `isDerivedFrom()`, `isDerived()`, `isEnum()`, `isExtern()`, `isFloatPoint()`, `isFriend()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionInstantiation()`, `isFunctionSpecialization()`, `isFunctionTemplate()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isInline()`, `isInstantiation()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isSpecialization()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `UnparsedInitializer` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `MemberFunc` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getOverridenMethod()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasCompleteDefinition()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isAssignmentOperator()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassInstantiation()`, `isClassMember()`, `isClassSpecialization()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isConstructor()`, `isConvFunc()`, `isCopyConstructor()`, `isDefinition()`, `isDerivedFrom()`, `isDerived()`, `isDestructor()`, `isEnum()`, `isExplicit()`, `isExtern()`, `isFloatPoint()`, `isFriend()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionInstantiation()`, `isFunctionSpecialization()`, `isFunctionTemplate()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isInline()`, `isInstantiation()`, `isIntegral()`, `isLvalueReference()`, `isOpFunc()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isSpecialization()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `MemberInitializers` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `MemberTemplate` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NoAttribute` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `Name` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasCompleteDefinition()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassInstantiation()`, `isClassMember()`, `isClassSpecialization()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isDefinition()`, `isDerivedFrom()`, `isDerived()`, `isEnum()`, `isExplicit()`, `isExtern()`, `isFloatPoint()`, `isFriend()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionInstantiation()`, `isFunctionSpecialization()`, `isFunctionTemplate()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isInline()`, `isInstantiation()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isSpecialization()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NameDeclarator` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NoAttributeSpec` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NameSpec` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasCompleteDefinition()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassInstantiation()`, `isClassMember()`, `isClassSpecialization()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isDefinition()`, `isDerivedFrom()`, `isDerived()`, `isEnum()`, `isExtern()`, `isFloatPoint()`, `isFriend()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionInstantiation()`, `isFunctionSpecialization()`, `isFunctionTemplate()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isInline()`, `isInstantiation()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isSpecialization()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NamespaceAlias` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasCompleteDefinition()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassInstantiation()`, `isClassMember()`, `isClassSpecialization()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isDefinition()`, `isDerivedFrom()`, `isDerived()`, `isEnum()`, `isExtern()`, `isFloatPoint()`, `isFriend()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionInstantiation()`, `isFunctionSpecialization()`, `isFunctionTemplate()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isInline()`, `isInstantiation()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isSpecialization()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NewExpr` are: `comesFromMacro()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassType()`, `isConstant()`, `isConst()`, `isEnum()`, `isFloatPoint()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFuncType()`, `isIncluded()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isStructType()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVolatile()`, `name()` and `pretty()`.
- Only functions that can be applied on node `TypeArg` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasCompleteDefinition()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassInstantiation()`, `isClassMember()`, `isClassSpecialization()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isDefinition()`, `isDerivedFrom()`, `isDerived()`, `isEnum()`, `isExtern()`, `isFloatPoint()`, `isFriend()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionInstantiation()`, `isFunctionSpecialization()`, `isFunctionTemplate()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isInline()`, `isInstantiation()`, `isIntegral()`, `isLvalueReference()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isSpecialization()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NewInitializer` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NoCapture` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NoDeclOrStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NoDeclarator` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NoDesignator` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NoEnumerator` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NoException` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NoExpr` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NoHandler` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NoInitializer` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NoLambdaDeclarator` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NoName` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NoNameQualifier` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NoNewInitializer` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NoParamName` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NoPropertyFunc` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NoTemplateParam` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `Node` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `NullptrLiteralExpr` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `TemplateSpec` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `OpFunc` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getOperationCode()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `Param` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `ParamName` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `ParamNames` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `ParensDeclarator` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasCompleteDefinition()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isAssignmentOperator()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassInstantiation()`, `isClassMember()`, `isClassSpecialization()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isConstructor()`, `isConvFunc()`, `isCopyConstructor()`, `isDefinition()`, `isDerivedFrom()`, `isDerived()`, `isDestructor()`, `isEnum()`, `isExtern()`, `isFloatPoint()`, `isFriend()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionInstantiation()`, `isFunctionSpecialization()`, `isFunctionTemplate()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isInline()`, `isInstantiation()`, `isIntegral()`, `isLvalueReference()`, `isOpFunc()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isSpecialization()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `PromisedFuncBody` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `PromisedMemberDecl` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `PropertyPutFunc` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `PtrDeclarator` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `ThisExpr` are: `comesFromMacro()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassType()`, `isConstant()`, `isConst()`, `isEnum()`, `isFloatPoint()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFuncType()`, `isIncluded()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isStructType()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVolatile()`, `name()` and `pretty()`.
- Only functions that can be applied on node `QualifiedName` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getDestructor()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasCompleteDefinition()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassInstantiation()`, `isClassMember()`, `isClassSpecialization()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isDefinition()`, `isDerivedFrom()`, `isDerived()`, `isEnum()`, `isExplicit()`, `isExtern()`, `isFloatPoint()`, `isFriend()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionInstantiation()`, `isFunctionSpecialization()`, `isFunctionTemplate()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isInline()`, `isInstantiation()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isSpecialization()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `QualifiedPseudoDtor` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `RangeDesignator` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `ReservedTypeSpec` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `SizeOfExpr` are: `comesFromMacro()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassType()`, `isConstant()`, `isConst()`, `isEnum()`, `isFloatPoint()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFuncType()`, `isIncluded()`, `isIntegral()`, `isLvalueReference()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isStructType()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVolatile()`, `name()` and `pretty()`.
- Only functions that can be applied on node `SpecialCastExpr` are: `comesFromMacro()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getFloatValue()`, `getInitialDefinedType()`, `getIntValue()`, `getLanguageType()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassType()`, `isConstant()`, `isConst()`, `isEnum()`, `isFloatPoint()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFuncType()`, `isIncluded()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isStructType()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVolatile()`, `name()` and `pretty()`.
- Only functions that can be applied on node `StorageClass` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `SuperScope` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `SwitchDeclStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `SwitchStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `TemplateDecl` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `getPrimaryTemplate()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `TemplateName` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `TemplateParam` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `TemplateParams` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `TemplateTypeArg` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasCompleteDefinition()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassInstantiation()`, `isClassMember()`, `isClassSpecialization()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isDefinition()`, `isDerivedFrom()`, `isDerived()`, `isEnum()`, `isExtern()`, `isFloatPoint()`, `isFriend()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionInstantiation()`, `isFunctionSpecialization()`, `isFunctionTemplate()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isInline()`, `isInstantiation()`, `isIntegral()`, `isLvalueReference()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isSpecialization()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `ThrowExpr` are: `comesFromMacro()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassType()`, `isConstant()`, `isConst()`, `isEnum()`, `isFloatPoint()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFuncType()`, `isIncluded()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isStructType()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVolatile()`, `name()` and `pretty()`.
- Only functions that can be applied on node `TranslationUnit` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `TruncatedInitClause` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `TryExceptStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `TryFinallyStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `TypeAdjective` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `TypeConvExpr` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasCompleteDefinition()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassInstantiation()`, `isClassMember()`, `isClassSpecialization()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isDefinition()`, `isDerivedFrom()`, `isDerived()`, `isEnum()`, `isExtern()`, `isFloatPoint()`, `isFriend()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionInstantiation()`, `isFunctionSpecialization()`, `isFunctionTemplate()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isInline()`, `isInstantiation()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isSpecialization()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `TypeId` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasCompleteDefinition()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassInstantiation()`, `isClassMember()`, `isClassSpecialization()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isDefinition()`, `isDerivedFrom()`, `isDerived()`, `isEnum()`, `isExtern()`, `isFloatPoint()`, `isFriend()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionInstantiation()`, `isFunctionSpecialization()`, `isFunctionTemplate()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isInline()`, `isInstantiation()`, `isIntegral()`, `isLvalueReference()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isSpecialization()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `TypeName` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasCompleteDefinition()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassInstantiation()`, `isClassMember()`, `isClassSpecialization()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isDefinition()`, `isDerivedFrom()`, `isDerived()`, `isEnum()`, `isExtern()`, `isFloatPoint()`, `isFriend()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionInstantiation()`, `isFunctionSpecialization()`, `isFunctionTemplate()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isInline()`, `isInstantiation()`, `isIntegral()`, `isLvalueReference()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isSpecialization()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `TypeOfSpec` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `TypeOfType` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasCompleteDefinition()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassInstantiation()`, `isClassMember()`, `isClassSpecialization()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isDefinition()`, `isDerivedFrom()`, `isDerived()`, `isEnum()`, `isExtern()`, `isFloatPoint()`, `isFriend()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionInstantiation()`, `isFunctionSpecialization()`, `isFunctionTemplate()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isInline()`, `isInstantiation()`, `isIntegral()`, `isLvalueReference()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isSpecialization()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `TypeParam` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `UnaryExpr` are: `comesFromMacro()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getFloatValue()`, `getInitialDefinedType()`, `getIntValue()`, `getLanguageType()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getOperationCode()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassType()`, `isConstant()`, `isConst()`, `isEnum()`, `isFloatPoint()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFuncType()`, `isIncluded()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isStructType()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVolatile()`, `name()` and `pretty()`.
- Only functions that can be applied on node `UnparsedDecl` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `UnparsedDeclSpec` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `UnparsedDeclarator` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `UnparsedEnumerator` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `UnparsedPropertyFunc` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `UnparsedException` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `UnparsedLabel` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `UnparsedMemberDecl` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `UnparsedName` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `UnparsedParamName` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `UnparsedStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `UnqualifiedName` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `UserStringLiteralExpr` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `UsingDecl` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasCompleteDefinition()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassInstantiation()`, `isClassMember()`, `isClassSpecialization()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isDefinition()`, `isDerivedFrom()`, `isDerived()`, `isEnum()`, `isExtern()`, `isFloatPoint()`, `isFriend()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionInstantiation()`, `isFunctionSpecialization()`, `isFunctionTemplate()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isInline()`, `isInstantiation()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isSpecialization()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `UsingDirective` are: `comesFromMacro()`, `functionAcceptsVararg()`, `getArrayElementType()`, `getArraySizeSema()`, `getBaseIntegralTypeName()`, `getDefinedType()`, `getFileName()`, `getInitialDefinedType()`, `getLanguageType()`, `getMaxTypeValue()`, `getMinTypeValue()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getNumberOfFormalParams()`, `getParent()`, `getPointedType()`, `getPositionInList()`, `getQualifiedTypeName()`, `getReferencedType()`, `getReferencedTypeOrSelf()`, `getReturnType()`, `getSemanticInfo()`, `getTypeName()`, `getTypeSize()`, `getUnderlyingType()`, `hasCompleteDefinition()`, `hasVirtualBase()`, `isAbstract()`, `isArray()`, `isBoolean()`, `isBuiltinType()`, `isCLanguage()`, `isClass()`, `isClassInstantiation()`, `isClassMember()`, `isClassSpecialization()`, `isClassTemplate()`, `isClassType()`, `isConstant()`, `isConst()`, `isDefinition()`, `isDerivedFrom()`, `isDerived()`, `isEnum()`, `isExtern()`, `isFloatPoint()`, `isFriend()`, `isFromMacroArg()`, `isFromMacro()`, `isFunction()`, `isFunctionInstantiation()`, `isFunctionSpecialization()`, `isFunctionTemplate()`, `isFuncType()`, `isGlobal()`, `isIncluded()`, `isInline()`, `isInstantiation()`, `isIntegral()`, `isLvalueReference()`, `isPadded()`, `isPODType()`, `isPointer()`, `isPolymorphic()`, `isPrivate()`, `isProtected()`, `isPublic()`, `isReference()`, `isRvalueReference()`, `isSigned()`, `isSignedInt()`, `isSimpleStruct()`, `isSpecialization()`, `isStatic()`, `isStructType()`, `isTemplate()`, `isTypedef()`, `isTypeParameter()`, `isUnionType()`, `isUnsigned()`, `isVariable()`, `isVirtual()`, `isVolatile()`, `isWeak()`, `name()` and `pretty()`.
- Only functions that can be applied on node `WhileDeclStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Only functions that can be applied on node `WhileStmt` are: `comesFromMacro()`, `getFileName()`, `getNodeColumn()`, `getNodeLastColumn()`, `getNodeLastLine()`, `getNodeLine()`, `getPositionInList()`, `isCLanguage()`, `isFromMacroArg()`, `isFromMacro()`, `isIncluded()`, `name()` and `pretty()`.
- Functions : `concat()`, `contains()`, `contains-nocase()`, `ends-with()`, `ends-with-nocase()`, `false()`, `getFormalParameter()`, `isMacroDefined()`, `isOverloaded()`, `length()`, `matches()`, `matches-nocase()`, `print()`, `replace()`, `replace-nocase()`, `starts-from-capital()`, `starts-with()`, `starts-with-nocase()`, `substring()` and `this()` are applicable on all node types.

On any specific node only the functions mentioned here can be applied. Do not create new functions. Whenever you are using a function add a pair of braces '()' following the function name. 

For example : use getOperationCode() instead of getOperationCode and isStatic() instead of isStatic.

Instead of using terminal characters like 'NoName', use 'Null' instead whenever needed.

For example prompt: Find all anonymous unions -
Right KAST expression is - //ClassType[@Tag = KTC_CLASSTAG_UNION][Name::Null], 
while wrong KAST expression is - //ClassType[@Tag = KTC_CLASSTAG_UNION][Name::NoName]

Function isCLanguage() checks if the language being used is 'C' only and not C++. Use 'isCLanguage()' function only when you are checking for something which is present in 'C Language' but not in 'C++' language. Similarly use [not isCLanguage()] predicate only when you are checking for something which is present in 'C++ Language' but not in 'C' language.

Always prioritize calling functions instead of using predicates or steps or attributes. Use predicates or attributes only if the intended task can not be achieved by calling a function.

Use following example prompts and output patterns as reference. These examples are just for your better understanding of what you are expected to do. Do not follow these examples completely. Try to come up with your own KAST expression taking these examples as reference points. Sometimes one KAST expression is not enough to cover all cases of a prompt. We use multiple KAST expressions in that case, where each KAST expression covers a particular use case.

- prompt: Find all instances where type long double is used. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

        //BuiltinType [not isCLanguage()] [@Spec=KTC_BUILTINTYPE_DOUBLE]
            [parent::*/DeclSpecs[*]::TypeAdjective[@Spec=KTC_ADJECTIVE_LONG]]


- prompt: Find all instances where do statements is used. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

        //DoStmt [not isCLanguage()] [not comesFromMacro()]


- prompt: Find all instances where c-style arrays is used. This KAST expression should only check programs written in C language and not in C++ language.


-This is the pattern for the above prompt:

//ArrayDeclarator [ not (isCLanguage()) ]
    [not parent::{*[name()!='ClassType']/parent::}MemberDecl
        [DeclSpecs[*]::StorageClass[@Spec=KTC_STORAGECLASS_STATIC] ]
        [DeclSpecs[*]::ConstExpr]
    ]


- prompt: Find all instances where non-virtual public or protected member functions are redefined in derived classes. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

//FuncDeclarator [not isCLanguage()]
        [getOverridenMethod()]
        [not getOverridenMethod().isVirtual()]
        [not getOverridenMethod().isPrivate()]
        [not getOverridenMethod().isConstructor()]
        [$derived_class:=getOverridenMethod().getParent()]
        [$class:=getParent()]
        [ancestor::ClassType
                [getName()=$class.getName()]
                [BaseSpecs[*]::BaseSpec
                        [Name::NameSpec [getName()=$derived_class.getName()] ]
                        [@Access!=KTC_ACCESSSPECIFIER_PRIVATE]
                ]
        ]


- prompt: Find all instances where "operator[]" is overloaded with a non-const version, but const version is not implemented. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

//FuncDeclarator [not isCLanguage()]
    [Declarator::NameDeclarator/Name::OpFunc [@Op=KTC_OPCODE_SQUARE_BRACKETS] ] [not isConst()] [$this:=this()]
    [not parent::{AnyDeclarator/parent::}AnyMemberDecl/parent::ClassType/MemberDecls[*]::AnyMemberDecl/Declarator::{AnyDeclarator/Declarator::}FuncDeclarator
        [this()!=$this]
        [Declarator::NameDeclarator/Name::OpFunc [@Op=KTC_OPCODE_SQUARE_BRACKETS] ]
        [isConst()]
    ]


- prompt: Find all instances where variables are implicitly captured in a lambda expression. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

        //LambdaIntroducer [not isCLanguage()] [LambdaCapture[*]::CaptureDefault]


- prompt: Find all instances where assignment operators are not declared with the ref-qualifier &. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

//FuncDeclarator [not isCLanguage()] [isOpFunc()]
    [parent::PtrDeclarator [parent::MemberDecl | parent::MemberFunc]
        [parent::*
            [$m:='Attempt to identify ref-qualifier']
            [$p:=pretty()]
            [$p2:=$p.replace('{.*$', '')]
            [$p3:=$p2.replace('^.*\\)', '')]
            [$p4:=$p3.replace('\\s+', '')]
            [$p5:=$p4.replace('//.*$', '')]
            [$p6:=$p5.replace('/\\*.*\\*/', '')]
            [not $p6.matches('(^|[^&])& ')]
        ]
    ]
    [Declarator::NameDeclarator/Name::OpFunc
        [@Op=KTC_OPCODE_ASSIGN | @Op=KTC_OPCODE_MULASSIGN
        |@Op=KTC_OPCODE_DIVASSIGN | @Op=KTC_OPCODE_MODASSIGN
        |@Op=KTC_OPCODE_ADDASSIGN | @Op=KTC_OPCODE_SUBASSIGN
        |@Op=KTC_OPCODE_ASLASSIGN | @Op=KTC_OPCODE_ASRASSIGN
        |@Op=KTC_OPCODE_ANDASSIGN | @Op=KTC_OPCODE_XORASSIGN
        |@Op=KTC_OPCODE_ORASSIGN
        ]
    ]
    [not isFromMacro()]


- prompt: Find all instances where in  function templates, the trailing return type syntax is not used if the return type depends on the type of parameters. This KAST expression should only check programs written in C++ language and not in C language.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

//TemplateDecl [not isCLanguage()] /Decl::FuncDef
        [Declarator::FuncDeclarator/TrailingReturnType::Null]
        [DeclSpecs[0]::TypeName [isTemplate()] | DeclSpecs[0]::TypeName/descendant::TemplateName]

-->pattern 2 :

//MemberFunc [not isCLanguage()]
        [Declarator::FuncDeclarator/TrailingReturnType::Null]
        [DeclSpecs[0]::TypeName [isTemplate()] | DeclSpecs[0]::TypeName/descendant::TemplateName]


- prompt: Find all instances where the volatile type qualifier is used. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

        //CVQualifier [not isCLanguage()] [@Spec=KTC_CVQUALIFIER_VOLATILE]


- prompt: Find all instances where hexadecimal constants contains any lower case. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

        //LiteralExpr  [not isCLanguage()] [pretty().starts-with('0x')]
            [matches(pretty(),'[a-f]')] [$0:=pretty()]


- prompt: Find all instances where a non-member generic operator is not declared in a namespace that does not contain class (struct) type, enum type or union type declarations. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

//OpFunc [not isCLanguage()] [not isClassMember()] [isTemplate()]
    [parent::NameDeclarator/parent::FuncDeclarator
        [Params[0]::Decl]
        [Params[*]::Decl[Declarators[0]::Null | Declarators[0]::PtrDeclarator [@Spec=KTC_POINTEROPERATOR_REFERENCE | @Spec=KTC_POINTEROPERATOR_RVALUE]]/DeclSpecs::TypeName [isTypeParameter()] ]
    ]
    [parent::NameDeclarator/parent::FuncDeclarator/parent::* /parent::TemplateDecl/parent::NamespaceDecl
        [Decls[*]::{AnyDecl/Decl::}Decl/DeclSpecs[*]::ClassType | Decls[*]::{AnyDecl/Decl::}Decl/DeclSpecs[*]::EnumType ]
    ]


- prompt: Find all instances where the ternary conditional operator is used as a sub-expression. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

        //ConditionalExpr [not isCLanguage()] [not isFromMacro()] [ancestor::ConditionalExpr [not isFromMacro()] ]


- prompt: Find all instances where fixed width integer types from <cstdint> is not used in place of the basic numerical types. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

// Node [not isCLanguage()]
    [not Declarator::FuncDeclarator [getName()='main'] ]
    [$this:=this()]
    [not parent::FuncDeclarator
        [Params[*]::Decl [$this=this()]]
        [Declarator::NameDeclarator/Name::OpFunc [@Op=KTC_OPCODE_PREINC] ]
    ]
    [ not Declarators[*]::BitFieldDeclarator ]
    [ DeclSpecs[0]::*
        [ $name := getDeclSpecifiersText() ]
        [ not comesFromMacro() ]
    ]
    [ $name.length() != 0 ]
    [ $name != 'void' ]
    [ $name != 'bool' ]
    [ $name != 'char' ]
    [ $name != 'char16_t' ]
    [ $name != 'char32_t' ]
    [ $name != 'wchar_t' ]
    [ $name != 'double' ]
    [ $name != 'long double' ]
    [ $name != 'float' ]
    [ $0 := $name ]


- prompt: Find all instances where type wchar_t is used. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

        //BuiltinType  [not isCLanguage()] [@Spec=KTC_BUILTINTYPE_WCHAR_T]


- prompt: Find all instances where all user-defined conversion operators is not defined 'explicit'. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

        //ConvFunc [not isCLanguage()] [not isExplicit()] [ConversionType::TypeId [$0:=pretty()] ]


- prompt: Find all instances where a function definition is placed in a class definition even though neither of the following 3 options is true - (1) the function is intended to be inlined (2); it is a member function template; (3) it is a member function of a class template. This KAST expression should only check programs written in C++ language and not in C language.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

        //MemberTemplate [not isCLanguage()] [MemberDecl::MemberDecl [descendant::FuncDeclarator [$m:=getName()]] ]
            [$0:='Template member function'][$1:=$m]

-->pattern 2 :

        //MemberDecl  [not isCLanguage()] [not isVariable()]
            [descendant::FuncDeclarator
                [@Defaulted!=KTC_FUNCTION_DEFAULT_DELETED]
                [@Defaulted!=KTC_FUNCTION_DEFAULT_DEFAULTED]
                [$m:=getName()]
            ]
            [not pretty().ends-with('= default ;')]
            [not pretty().ends-with('= delete ;')]
            [parent::ClassType/parent::Decl/parent::TemplateDecl]
            [$0:='Member function of template class'][$1:=$m]


- prompt: Find all instances where "ynamic_cast" is used. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

        //SpecialCastExpr [not isCLanguage()] [@Cast=KTC_CASTSPECIFIER_DYNAMIC]


- prompt: Find all instances where parameter list (possibly empty) is not included in every lambda expression. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

        //LambdaExpr [not isCLanguage()] [Declarator::Null]


- prompt: Find all instances where the std::vector<bool> specialization is used. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

//TypeName [not isCLanguage()]
    [Name::{QualifiedName[Qualifier::NameSpec[getName()='std']]/Name::}TemplateName
        [Name::Name [getName()='vector'] ]
        [Args[0]::TypeArg/Type::TypeId/DeclSpecs[*]::BuiltinType [@Spec=KTC_BUILTINTYPE_BOOL] ]
    ]


- prompt: Find all instances where a lambda expression object outlives any of its reference-captured objects. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

        //LambdaIntroducer [not isCLanguage()]
            [LambdaCapture[*]::Capture [@CaptureType=KTC_CAPTURETYPE_REFERENCE] [Expr::IdExpr [$0:=getName()]] ]


- prompt: Find all instances where return type of a non-void return type lambda expression is not explicitly specified. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

        //LambdaExpr [not isCLanguage()] [Declarator::LambdaDeclarator/TrailingReturnType::Null]
            [FuncBody::FuncBody/descendant::ReturnStmt [not Expr::Null]]


- prompt: Find all instances where any of the functions malloc, calloc, realloc and free is used. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

//CallExpr [not isCLanguage()]
    [Func::IdExpr/Name::{QualifiedName[Qualifier::NameSpec[getName()='std']]/Name::}Name
        [getName()='malloc' | getName()='calloc' | getName()='realloc' | getName()='free'] [$0:=getName()]
    ]
    [not parent::{*[name()!='FuncDef']/parent::}FuncDef[isOpFunc()]/Declarator::FuncDeclarator[getName()='new' | getName()='delete']]


- prompt: Find all instances where a lambda is an operand to decltype or typeid. This KAST expression should only check programs written in C++ language and not in C language.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

        //ExprTypeIdExpr [not isCLanguage()] [Expr::IdExpr [getTypeName().starts-with('#_LAMBDA')] [$0:=getName()] ]

-->pattern 2 :

        //TypeOfExpr [not isCLanguage()] [Expr::IdExpr [getTypeName().starts-with('#_LAMBDA')] [$0:=getName()] ]


- prompt: Find all instances where lambda expressions is defined inside another lambda expression. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

        //LambdaExpr [not isCLanguage()] [ancestor::LambdaExpr]


- prompt: Find all instances where traditional C-style casts are used. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

//CastExpr [ not isCLanguage() ]
          [ $tname := getTypeName() ]
          [ $0 := Expr.getTypeName() ]
          [ $1 := $tname ]


- prompt: Find all instances where "einterpret_cast" is used. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

        //SpecialCastExpr [not isCLanguage()] [@Cast=KTC_CASTSPECIFIER_REINTERPRET]


- prompt: Find all instances where a pointer to member virtual function is tested for equality with something other than null-pointer-constant. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

        //BinaryExpr [not isCLanguage()] [@Op=KTC_OPCODE_EQ | @Op=KTC_OPCODE_NE]
            [Left::* /parent::BinaryExpr
                [not Right::NullptrLiteralExpr]
                [Left::UnaryExpr/Expr::IdExpr/Name::QualifiedName
                    [isClassMember()] [isFunction()] [isVirtual()] [$0:=getName()]
                ]
                |Left::* /parent::BinaryExpr
                [not Left::NullptrLiteralExpr]
                [Right::UnaryExpr/Expr::IdExpr/Name::QualifiedName
                    [isClassMember()] [isFunction()] [isVirtual()] [$0:=getName()]
                ]
            ]


- prompt: Find all instances where a class with non-virtual public destructor, is not declared final. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

//ClassType [not isCLanguage()] [@Tag=KTC_CLASSTAG_CLASS] [@Final!=KTC_FINAL_CLASS_FINAL]
    [MemberDecls[*]::MemberDecl
        [Declarators[*]::FuncDeclarator
            [isDestructor()] [isPublic()]
            [not CVQualifiers[*]::CVQualifier[@Spec=KTC_CVQUALIFIER_OVERRIDE] ]
            [not CVQualifiers[*]::CVQualifier[@Spec=KTC_CVQUALIFIER_FINAL] ]
        ]
        [not DeclSpecs[*]::FuncSpec [@Spec=KTC_FUNCSPECIFIER_VIRTUAL] ]
    |MemberDecls[*]::MemberFunc
        [Declarator::FuncDeclarator
            [isDestructor()] [isPublic()]
            [not CVQualifiers[*]::CVQualifier[@Spec=KTC_CVQUALIFIER_OVERRIDE] ]
            [not CVQualifiers[*]::CVQualifier[@Spec=KTC_CVQUALIFIER_FINAL] ]
        ]
        [not DeclSpecs[*]::FuncSpec [@Spec=KTC_FUNCSPECIFIER_VIRTUAL] ]
    ]
    [$0:=getName()]


- prompt: Find all instances where a switch statement does not have at least two case-clauses, distinct from the default label. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

//SwitchStmt [not isCLanguage()] [not Stmt::CompoundStmt/Stmts[*]::LabeledStmt
    [not Label::DefaultLabel]
    [$pos:=getPositionInList()]
    [parent::CompoundStmt/Stmts[*]::LabeledStmt
        [not Label::DefaultLabel]
        [getPositionInList()>$pos]
    ]
]


- prompt: Find all instances where the goto statement is used. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

        //GotoStmt [not isCLanguage()]


- prompt: Find all instances where cV-qualifiers are not placed on the right hand side of the type that is a typedef or a using name. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

//TypeName [not isCLanguage()] [$pos:=getPositionInList()]
    [Name::Name [isTypedef()] [$0:=getTypeName()] ]
    [parent::* /DeclSpecs[*]::CVQualifier [getPositionInList()<$pos] [$1:=pretty()]]


- prompt: Find all instances where the register keyword is used. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

        //StorageClass [not isCLanguage()] [@Spec=KTC_STORAGECLASS_REGISTER]


- prompt: Find all instances where a variable of type auto is initialized using '{}' or '={}' braced-initialization. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

        //InitializedDeclarator [not isCLanguage()] [isVariable()]
            [parent::Decl/DeclSpecs[*]::AutoType] [Init::InitClause]


- prompt: Find all instances where the typedef specifier is used. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

        //StorageClass [not isCLanguage()] [@Spec=KTC_STORAGECLASS_TYPEDEF]


- prompt: Find all instances where an expression statement and an identifier declaration is not placed on a separate line. This KAST expression should only check programs written in C++ language and not in C language.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

//DeclOrStmt [not isCLanguage()]
    [not descendant::AnyExpr [comesFromMacro()] ]
    [$line:=getNodeLine()] [$pos:=getPositionInList()]
    [parent::* /Stmts[*]::DeclOrStmt [getPositionInList()=$pos + 1] [getNodeLine()=$line]
    |parent::* /Decls[*]::DeclOrStmt [getPositionInList()=$pos + 1] [getNodeLine()=$line]
    ]
    [parent::* [$pos=0]
    |parent::* /Stmts[*]::DeclOrStmt [getPositionInList()=$pos - 1] [getNodeLine()<$line]
    |parent::* /Decls[*]::DeclOrStmt [getPositionInList()=$pos - 1] [getNodeLine()<$line]
    ]

-->pattern 2 :

//MemberDecl [not isCLanguage()] [$line:=getNodeLine()] [$pos:=getPositionInList()]
    [parent::* /MemberDecls[*]::MemberDecl [getPositionInList()=$pos + 1] [getNodeLine()=$line] ]
    [parent::* [$pos=0] | parent::* /MemberDecls[*]::* [getPositionInList()=$pos - 1] [getNodeLine()<$line] ]


- prompt: Find all instances where virtual function declaration contains a specifier other than these three: (1) virtual, (2) override, (3) final. This KAST expression should only check programs written in C++ language and not in C language.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

//MemberDecl [not isCLanguage()] [DeclSpecs::FuncSpec [@Spec=KTC_FUNCSPECIFIER_VIRTUAL] ]
    [Declarators[*]::{AnyDeclarator/Declarator::}FuncDeclarator
        [CVQualifiers[*]::CVQualifier[@Spec=KTC_CVQUALIFIER_OVERRIDE]
        |CVQualifiers[*]::CVQualifier[@Spec=KTC_CVQUALIFIER_FINAL]
        ]
        [$0:=getName()]
    ]

-->pattern 2 :

//MemberFunc [not isCLanguage()] [isVirtual()]
    [DeclSpecs[*]::*
        [parent::MemberFunc
            [not DeclSpecs[*]::FuncSpec[@Spec=KTC_FUNCSPECIFIER_VIRTUAL]]
            [not Declarator::{AnyDeclarator/Declarator::}FuncDeclarator/CVQualifiers[*]::CVQualifier[@Spec=KTC_CVQUALIFIER_OVERRIDE]]
            [not Declarator::{AnyDeclarator/Declarator::}FuncDeclarator/CVQualifiers[*]::CVQualifier[@Spec=KTC_CVQUALIFIER_FINAL]]
        |parent::MemberFunc
            [DeclSpecs[*]::FuncSpec[@Spec=KTC_FUNCSPECIFIER_VIRTUAL]]
            [Declarator::{AnyDeclarator/Declarator::}FuncDeclarator
                [CVQualifiers[*]::CVQualifier[@Spec=KTC_CVQUALIFIER_OVERRIDE]
                |CVQualifiers[*]::CVQualifier[@Spec=KTC_CVQUALIFIER_FINAL]
                ]
            ]
        |parent::MemberFunc
            [Declarator::{AnyDeclarator/Declarator::}FuncDeclarator/CVQualifiers[*]::CVQualifier[@Spec=KTC_CVQUALIFIER_OVERRIDE]]
            [DeclSpecs[*]::FuncSpec[@Spec=KTC_FUNCSPECIFIER_VIRTUAL]
            |Declarator::{AnyDeclarator/Declarator::}FuncDeclarator/CVQualifiers[*]::CVQualifier[@Spec=KTC_CVQUALIFIER_FINAL]
            ]
        |parent::MemberFunc
            [Declarator::{AnyDeclarator/Declarator::}FuncDeclarator/CVQualifiers[*]::CVQualifier[@Spec=KTC_CVQUALIFIER_FINAL]]
            [DeclSpecs[*]::FuncSpec[@Spec=KTC_FUNCSPECIFIER_VIRTUAL]
            |Declarator::{AnyDeclarator/Declarator::}FuncDeclarator/CVQualifiers[*]::CVQualifier[@Spec=KTC_CVQUALIFIER_OVERRIDE]
            ]
        ]
    ]
    [Declarator::{AnyDeclarator/Declarator::}FuncDeclarator [$0:=getName()] ]


- prompt: Find all instances where a binary arithmetic operator and a bitwise operator does not return a "prvalue". This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:


//FuncDeclarator [not isCLanguage()]
    [ parent::{AnyDeclarator/parent::}* /FuncBody::FuncBody ]
    [ Declarator::NameDeclarator/Name::OpFunc
        [ @Op=KTC_OPCODE_ADD | @Op=KTC_OPCODE_SUB | @Op=KTC_OPCODE_MUL
        | @Op=KTC_OPCODE_DIV | @Op=KTC_OPCODE_MOD | @Op=KTC_OPCODE_LOGOR
        | @Op=KTC_OPCODE_LOGAND | @Op=KTC_OPCODE_BITOR | @Op=KTC_OPCODE_BITXOR
        | @Op=KTC_OPCODE_BITAND | @Op=KTC_OPCODE_MULASSIGN | @Op=KTC_OPCODE_DIVASSIGN
        | @Op=KTC_OPCODE_MODASSIGN | @Op=KTC_OPCODE_ADDASSIGN | @Op=KTC_OPCODE_SUBASSIGN
        | @Op=KTC_OPCODE_ASLASSIGN | @Op=KTC_OPCODE_ASRASSIGN |@Op=KTC_OPCODE_ANDASSIGN
        | @Op=KTC_OPCODE_XORASSIGN | @Op=KTC_OPCODE_ORASSIGN | @Op=KTC_OPCODE_ASL | @Op=KTC_OPCODE_ASR
        | @Op=KTC_OPCODE_BITNOT
        ]
    ]
    [ not parent::* [name()='FuncDef' | name()='MemberFunc'] | parent::FuncDef/DeclSpecs[*]::CVQualifier ]
    [ Params[0]::DeclOrStmt / DeclSpecs[0]::TypeName
        [ not getLanguageType().isDerivedFrom('std::basic_ostream') ]
        [ not getLanguageType().isDerivedFrom('std::basic_istream') ]
        [ not getLanguageType().isDerivedFrom('basic_ostream') ]
        [ not getLanguageType().isDerivedFrom('basic_istream') ]
        [ getLanguageType().getTypeName()!= 'ostream']
        [ getLanguageType().getTypeName()!= 'istream']
    ]


- prompt: Find all instances where a project having sized or unsized version of operator "delete" globally defined, does not define both sized and unsized versions. This KAST expression should only check programs written in C++ language and not in C language.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

//TranslationUnit [not isCLanguage()] /Decls[*]::FuncDef/Declarator::FuncDeclarator
    [Declarator::NameDeclarator/Name::OpFunc [@Op=KTC_OPCODE_DELETE] ]
    [Params[1]::Null]
    [not ancestor::TranslationUnit/Decls[*]::FuncDef/Declarator::FuncDeclarator
        [Declarator::NameDeclarator/Name::OpFunc [@Op=KTC_OPCODE_DELETE] ]
        [Params[1]::Decl]
    ]
    [$0:='unsized'][$1:='sized']

-->pattern 2 :

//TranslationUnit [not isCLanguage()] /Decls[*]::FuncDef/Declarator::FuncDeclarator
    [Declarator::NameDeclarator/Name::OpFunc [@Op=KTC_OPCODE_DELETE] ]
    [Params[1]::Decl]
    [not ancestor::TranslationUnit/Decls[*]::FuncDef/Declarator::FuncDeclarator
        [Declarator::NameDeclarator/Name::OpFunc [@Op=KTC_OPCODE_DELETE] ]
        [Params[1]::Null]
    ]
    [$0:='sized'][$1:='unsized']


- prompt: Find all instances where a non-type specifier is not placed before a type specifier in a declaration. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

//NameDeclarator [not isCLanguage()]
    [parent::{AnyDeclarator/parent::}* [name()='Decl' | name()='MemberDecl' | name()='FuncDef']
        [DeclSpecs[*]::* [name()='TypeName' | name()='BuiltinType' | name()='AutoType']
            [$pos:=getPositionInList()] [$this:=this()] [$0:=pretty()]
            [parent::* /DeclSpecs[*]::* [getPositionInList()>$pos] [this()!=$this] [pretty()!='const'] [pretty()!='volatile']]
        ]
    ]


- prompt: Find all instances where a class, structure, or enumeration is declared in the definition of its type. This KAST expression should only check programs written in C++ language and not in C language.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

//Decl [not isCLanguage()] [Declarators::NameDeclarator | Declarators[*]::InitializedDeclarator]
    [DeclSpecs[*]::EnumType [isDefinition()] | DeclSpecs[*]::ClassType [isDefinition()]]

-->pattern 2 :

//MemberDecl [not isCLanguage()] [Declarators::NameDeclarator | Declarators[*]::InitializedDeclarator]
    [DeclSpecs[*]::EnumType [isDefinition()] | DeclSpecs[*]::ClassType [isDefinition()]]


- prompt: Find all instances where enumeration underlying base type is not explicitly defined. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

        //EnumType [not isCLanguage()] [Base::Null]


- prompt: Find all instances where enumerations is not declared as scoped enum classes. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

//EnumType [not isCLanguage()]
    [@Tag=KTC_ENUMTAG_ENUM] [parent::Decl [parent::TranslationUnit | parent::NamespaceDecl] ]
    [$m1:=getName().replace('^#.*$', '')] [$0:=$m1.replace('^$', '<Unnamed>')]


- prompt: Find all instances where the asm declaration is used. This KAST expression should only check programs written in C++ language and not in C language.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

        //CallExpr [not isCLanguage()] [Func::IdExpr/Name::Name [pretty()='asm']]

-->pattern 2 :

        //AsmDef [not isCLanguage()]


- prompt: Find all instances where user defined suffixes of the user defined literal operators does not start with underscore followed by one or more letters. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

        //SuffixFunc [not isCLanguage()] [not getName().matches('_[a-zA-Z]+$')] [$0:=getName()]


- prompt: Find all instances where unions are used. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

//ClassType [not isCLanguage()] [@Tag=KTC_CLASSTAG_UNION]
    [MemberDecls[0]::MemberDecl [not parent::ClassType
        [Name::Null]
        [parent::MemberDecl/parent::ClassType/MemberDecls[*]::MemberDecl/DeclSpecs[*]::EnumType]
    ]]


- prompt: Find all instances where virtual functions is introduced in a final class. This KAST expression should only check programs written in C++ language and not in C language.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

//MemberFunc [not isCLanguage()] [isVirtual()] [parent::ClassType[@Final=KTC_FINAL_CLASS_FINAL]]
    [Declarator::{AnyDeclarator/Declarator::}FuncDeclarator [not CVQualifiers[*]::CVQualifier [@Spec=KTC_CVQUALIFIER_FINAL]] [$0:=getName()] ]

-->pattern 2 :

//MemberDecl [DeclSpecs[*]::FuncSpec [@Spec=KTC_FUNCSPECIFIER_VIRTUAL] ] [parent::ClassType[@Final=KTC_FINAL_CLASS_FINAL]]
    [Declarators[*]::{AnyDeclarator/Declarator::}FuncDeclarator [not CVQualifiers[*]::CVQualifier [@Spec=KTC_CVQUALIFIER_FINAL] ] [$m:=getName()] ]


- prompt: Find all instances where friend declarations is used. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

//FuncSpec [not isCLanguage()] [@Spec=KTC_FUNCSPECIFIER_FRIEND]
    [parent::* /Declarator::{AnyDeclarator/Declarator::}FuncDeclarator
        [not Declarator::NameDeclarator/Name::OpFunc
            [@Op=KTC_OPCODE_EQ | @Op=KTC_OPCODE_NE
            |@Op=KTC_OPCODE_LT | @Op=KTC_OPCODE_GT
            |@Op=KTC_OPCODE_LE | @Op=KTC_OPCODE_GE
            ]
        ]
    |parent::* /Declarators[*]::{AnyDeclarator/Declarator::}FuncDeclarator
        [not Declarator::NameDeclarator/Name::OpFunc
            [@Op=KTC_OPCODE_EQ | @Op=KTC_OPCODE_NE
            |@Op=KTC_OPCODE_LT | @Op=KTC_OPCODE_GT
            |@Op=KTC_OPCODE_LE | @Op=KTC_OPCODE_GE
            ]
        ]
    ]


- prompt: Find all instances where both NSDMI and a non-static member initializer in a constructor is used in the same type. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

//MemberDecl [not isCLanguage()]
    [Declarators[*]::InitializedDeclarator/Declarator::NameDeclarator [not isStatic()] [$var:=getName()] ]
    [parent::ClassType/MemberDecls[*]::MemberFunc
        [Declarator::FuncDeclarator [isConstructor()] [not isCopyConstructor()] ]
        [FuncBody::FuncBody/CtorInit::CtorInitializer/descendant::MemberInitializer/Name::Name ]
    |parent::ClassType [$class:=getName()]
        [MemberDecls[*]::MemberDecl/Declarators[*]::FuncDeclarator [isConstructor()] [not isCopyConstructor()]  ]
        [ancestor::TranslationUnit/descendant::FuncDef
            [Declarator::FuncDeclarator [isConstructor()] [not isCopyConstructor()] [Declarator::NameDeclarator [getName()=$class]] ]
            [FuncBody::FuncBody/CtorInit::CtorInitializer/descendant::MemberInitializer/Name::Name ]
        ]
    ]
    [$0:=$var]


- prompt: Find all instances where all constructors that are callable with a single argument of fundamental type is not declared "explicit". This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

//FuncDeclarator [not isCLanguage()] [isConstructor()] [not isExplicit()]
    [parent::* /parent::ClassType [@Tag=KTC_CLASSTAG_CLASS]]
    [not Params[1]::Decl]
    [Params[0]::Decl/DeclSpecs[*]::BuiltinType
    |Params[0]::Decl/DeclSpecs[*]::TypeName [getInitialDefinedType().isBuiltinType()]]


- prompt: Find all instances where the std::auto_ptr type is used. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

//TypeName [not isCLanguage()]
    [Name::{QualifiedName[Qualifier::NameSpec[getName()='std']]/Name::}TemplateName/Name::Name[getName()='auto_ptr'] ]


- prompt: Find all instances where move constructor initializes its class members and base classes using copy semantics. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

//MemberInitializer [not isCLanguage()]
    [parent::CtorInitializer/parent::FuncBody/parent::MemberFunc
        [Declarator::FuncDeclarator/Params[0]::Decl/Declarators[*]::PtrDeclarator [@Spec=KTC_POINTEROPERATOR_RVALUE] ]
    ]
    [not Args[0]::CallExpr/Func::IdExpr [getName()='move'] ]
    [not Args[0]::InitializerExpr/Init::InitClause/Inits[*]::CopyInitializer/Expr::CallExpr/Func::IdExpr [getName()='move'] ]
    [not Name::Name [getTypeName()='nullptr_t']]
    [Name::Name [$type:=getDefinedType()] [$0:=getName()]]
    [not $type.isIntegral()]
    [not $type.isFloatPoint()]
    [not $type.isPointer()]


- prompt: Find all instances where an assignment operator does not return a reference to "this". This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

//FuncDeclarator [not isCLanguage()] [isOpFunc()]
    [Declarator::NameDeclarator/Name::{QualifiedName/Name::}OpFunc
        [@Op=KTC_OPCODE_ASSIGN
        |@Op=KTC_OPCODE_ADDASSIGN
        |@Op=KTC_OPCODE_SUBASSIGN
        |@Op=KTC_OPCODE_DIVASSIGN
        |@Op=KTC_OPCODE_MODASSIGN
        |@Op=KTC_OPCODE_ANDASSIGN
        |@Op=KTC_OPCODE_ORASSIGN
        |@Op=KTC_OPCODE_XORASSIGN
        |@Op=KTC_OPCODE_ASLASSIGN
        |@Op=KTC_OPCODE_ASRASSIGN
        |@Op=KTC_OPCODE_MULASSIGN
        ]
    ]
    [parent::{PtrDeclarator/parent::}MemberDecl/parent::ClassType
    |parent::{PtrDeclarator/parent::}MemberFunc/parent::ClassType]
    [not parent::PtrDeclarator [@Spec=KTC_POINTEROPERATOR_REFERENCE]
    |parent::{PtrDeclarator/parent::}* /DeclSpecs[*]::CVQualifier
    ]


- prompt: Find all instances where string literals are assigned to non-constant pointers. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

//InitializedDeclarator [not isCLanguage()] [Init::CopyInitializer/Expr::StringLiteralExpr]
        [not Declarator::ArrayDeclarator] [not parent::Decl/DeclSpecs[*]::CVQualifier [@Spec=KTC_CVQUALIFIER_CONST] ]
        [parent::Decl
                [DeclSpecs[*]::BuiltinType [@Spec=KTC_BUILTINTYPE_CHAR]
                |DeclSpecs[*]::TypeName [getUnderlyingType().getName().ends-with('char')] [not isConst()]
                |DeclSpecs[*]::TypeName [getPointedType().getUnderlyingType().getName().ends-with('char')] [not getPointedType().isConst()]
                ]
        ]


- prompt: Find all instances where a relational operator does not return a boolean value. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

//ReturnStmt [not isCLanguage()]
    [not Expr::BoolLiteralExpr]
    [not Expr::{ParensExpr/Expr::}UnaryExpr [@Op=KTC_OPCODE_LOGNOT] ]
    [not Expr::{ParensExpr/Expr::}CallExpr [getReturnType().isBoolean()] ]
    [not Expr::{ParensExpr/Expr::}BinaryExpr
            [@Op=KTC_OPCODE_EQ | @Op=KTC_OPCODE_NE
            |@Op=KTC_OPCODE_LT | @Op=KTC_OPCODE_GT
            |@Op=KTC_OPCODE_LE | @Op=KTC_OPCODE_GE
            |@Op=KTC_OPCODE_LOGAND | @Op=KTC_OPCODE_LOGOR
            ]
    ]

    [ancestor::FuncBody/parent::* /Declarator::{AnyDeclarator/Declarator::}FuncDeclarator
        [Declarator::NameDeclarator/Name::{QualifiedName/Name::}OpFunc
            [@Op=KTC_OPCODE_EQ | @Op=KTC_OPCODE_NE
            |@Op=KTC_OPCODE_LT | @Op=KTC_OPCODE_GT
            |@Op=KTC_OPCODE_LE | @Op=KTC_OPCODE_GE
            ]
        ]
    ]


- prompt: Find all instances where user-defined conversion operators is used. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

        //ConvFunc [not isCLanguage()] [ConversionType::TypeId [$0:=pretty()] ]


- prompt: Find all instances where overload of comparison operators is defined as a member function. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

//FuncDeclarator [not isCLanguage()] [isClassMember()] [not isFriend()]
    [Declarator::NameDeclarator/Name::OpFunc
        [@Op=KTC_OPCODE_EQ | @Op=KTC_OPCODE_NE
        |@Op=KTC_OPCODE_LT | @Op=KTC_OPCODE_GT
        |@Op=KTC_OPCODE_LE | @Op=KTC_OPCODE_GE
        ]
    ]


- prompt: Find all instances where comparison operators is not noexcept. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

//FuncDeclarator [not isCLanguage()] [not isClassMember() | isFriend()] [not Throw::DenyThrowSpec]
    [Declarator::NameDeclarator/Name::OpFunc
        [@Op=KTC_OPCODE_EQ | @Op=KTC_OPCODE_NE
        |@Op=KTC_OPCODE_LT | @Op=KTC_OPCODE_GT
        |@Op=KTC_OPCODE_LE | @Op=KTC_OPCODE_GE
        ]
    ]


- prompt: Find all instances where a const char pointer to a non-const char pointer argument is passed.


-This is the pattern for the above prompt:

                   //CallExpr [$func := getSemanticInfo()]
                      [  Args[*]::StringLiteralExpr
                           [$paramLit := getFormalParameter($func,getPositionInList())]
                           [$paramLitType := getLanguageType($paramLit)]
                           [$paramLitType.isPointer()] [ not $paramLitType.getPointedType().isConst()]
                       |
                         Args[*]::IdExpr [isPointer()][$ptr := getPointedType()][$ptr.isConst()][$charType := $ptr.getUnderlyingType().getTypeName()]
                                                            [$charType = 'char' | isPointerTypeWChar_t()]
                           [$param := getFormalParameter($func,getPositionInList())]
                           [$paramType := getLanguageType($param)]
                           [$paramType.isPointer()] [ not $paramType.getPointedType().isConst()]
                      ]
                      [$0 := $func.getName()]


- prompt: Find all instances where global identifier is declared but is not used in current translation unit. This KAST expression should only check programs written in C language and not in C++ language.


-This is the pattern for the above prompt:

                    //Decl [isCLanguage()] [not isIncluded()] [parent::TranslationUnit]
                      [Declarators[*]::{AnyDeclarator/Declarator::}AnyDeclarator/Name::Name [not isStatic()] [isExtern()] [$this:=this()] ]
                      [parent::TranslationUnit [not descendant::IdExpr/Name::Name [this().getSemanticInfo()=$this.getSemanticInfo()] ] ]
                      [$0:=$this.getName()]


- prompt: Find all instances where functions, that can spuriously wake up in a loop, are not wrapped. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

                    //CallExpr [not isCLanguage()] [Func::MemberExpr[Expr::IdExpr[getTypeName()='condition_variable' | getTypeName()='condition_variable&']][Name::Name[@Id='wait'|@Id='wait_for'|@Id='wait_until'][$0:=@Id]]][not ancestor::WhileStmt][not Args[1]::LambdaExpr]


- prompt: Find all instances where allocation and deallocation functions are not overloaded as a pair in the same scope. This KAST expression should only check programs written in C++ language and not in C language.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                    // FuncDef [not isCLanguage()] [Declarator::PtrDeclarator / Declarator::FuncDeclarator / Declarator::NameDeclarator / Name::OpFunc [@Op = KTC_OPCODE_NEW]
                                                                                                                                [$0 := 'new']
                                                                                                                                [$1 := 'delete']
                            ]
                            [not (parent::* / Decls[*]::FuncDef [Declarator::FuncDeclarator / Declarator::NameDeclarator / Name::OpFunc [@Op=KTC_OPCODE_DELETE] ])]

-->pattern 2 :

                    // FuncDef [not isCLanguage()] [Declarator::FuncDeclarator / Declarator::NameDeclarator / Name::OpFunc [@Op = KTC_OPCODE_DELETE]
                                                                                                    [$0:='delete']
                                                                                                    [$1:='new']
                            ]
                            [not (parent::*/Decls[*]::FuncDef[Declarator::PtrDeclarator/Declarator::FuncDeclarator/Declarator::NameDeclarator/Name::OpFunc[@Op=KTC_OPCODE_NEW]])]

-->pattern 3 :

                    // MemberFunc [not isCLanguage()] [Declarator::PtrDeclarator / Declarator::FuncDeclarator / Declarator::NameDeclarator / Name::OpFunc[@Op = KTC_OPCODE_NEW]
                                                                                                                                    [$0:='new']
                                                                                                                                    [$1:='delete']
                                ]
                                [not (parent::*/MemberDecls[*]::MemberFunc[Declarator::FuncDeclarator/Declarator::NameDeclarator/Name::OpFunc[@Op=KTC_OPCODE_DELETE]])]

-->pattern 4 :

                    // MemberFunc [not isCLanguage()] [Declarator::FuncDeclarator / Declarator::NameDeclarator / Name::OpFunc [@Op = KTC_OPCODE_DELETE]
                                                                                                        [$0 := 'delete']
                                                                                                        [$1 := 'new']
                                ]
                                [not (parent::* / MemberDecls[*]::MemberFunc [Declarator::PtrDeclarator / Declarator::FuncDeclarator / Declarator::NameDeclarator / Name::OpFunc [@Op = KTC_OPCODE_NEW] ])]


- prompt: Find all instances where threads are used that can be canceled asynchronously.


-This is the pattern for the above prompt:

                    //CallExpr [getName() = 'pthread_setcanceltype'] [Args[0]::* [getIntValue() = 1]] [ancestor::FuncDef [$0 := getName()]]



- prompt: Find all instances where a volatile object is accessed through a nonvolatile pointer.


-This is the pattern for the above prompt:

                   //BinaryExpr   [@Op = KTC_OPCODE_ASSIGN]
                       [ Left::IdExpr [ isPointer() ]
                          [ $ptTypeL := getPointedType() ] [not $ptTypeL.getPointedType().isPointer()]
                          [ not $ptTypeL.isVolatile() ] [$0 := getName()]
                       ]
                      [ Right::AnyExpr/descendant::IdExpr [ not isPointer() ] [ isVolatile() ] [ $1 := getName() ]
                      ]


- prompt: Find all instances where wrap functions are present that can spuriously wake up in a loop. This KAST expression should only check programs written in C language and not in C++ language.


-This is the pattern for the above prompt:

                    // CallExpr [isCLanguage()]
                                [$name := getName()]
                                [$name = 'cnd_wait' | $name = 'cnd_timedwait' | $name = 'wait' | $name = 'wait_for' | $name = 'wait_until']
                                [not (ancestor::WhileStmt [not (Cond::LiteralExpr | Cond::BoolLiteralExpr)] |
                                      ancestor::DoStmt [not (Cond::LiteralExpr | Cond::BoolLiteralExpr)] |
                                      ancestor::ForStmt [not (Cond::LiteralExpr | Cond::BoolLiteralExpr)]
                                     )]
                                [$0 := $name]


- prompt: Find all instances where a nonstandard-layout type object is passed across execution boundaries. This KAST expression should only check programs written in C++ language and not in C language.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                  //LinkageSpec [not isCLanguage()] [@String != 'c++']  /Decls[*]::Decl/descendant::FuncDeclarator/Declarator::NameDeclarator[SaveNameNode()]
                          [$0 := ''][$1 := '']

-->pattern 2 :

                  //CallExpr [not isCLanguage()] [isCrossBoundaryLinkage()] [$notSLOname := getNonStandardLayoutObjectPassed()] [$notSLOname != '']
                             [$0 := getSemanticInfo().getName()] [$1 := $notSLOname]


- prompt: Find all instances where a reference to a non-volatile pointer is assigned to a volatile pointer-to-pointer.


-This is the pattern for the above prompt:

                   //BinaryExpr   [@Op = KTC_OPCODE_ASSIGN]
                       [ Left::IdExpr [ isPointer() ] [ $ptTypeL := getPointedType() ] [$ptTypeL2 := $ptTypeL.getPointedType()]
                          [ isVolatile() | $ptTypeL.getPointedType().isVolatile() |  $ptTypeL2.getPointedType().isVolatile() ] [$0 := getName()]
                       ]
                       [ Right::AnyExpr/descendant::IdExpr [ isPointer() ] [ $ptTypeR := getPointedType() ] [ not $ptTypeR.isVolatile() ] [ not $ptTypeR.getPointedType().isVolatile() ] [$1 := getName()]
                       ]


- prompt: Find all instances where non-standard extended enum type specifier is used. This KAST expression should only check programs written in C language and not in C++ language.


-This is the pattern for the above prompt:

                    //EnumType [isCLanguage()]
                      [parent::Decl
                        [DeclSpecs[*]::TypeAdjective [@Spec=KTC_ADJECTIVE_SHORT | @Spec=KTC_ADJECTIVE_LONG]
                        |DeclSpecs[*]::BuiltinType [@Spec=KTC_BUILTINTYPE_CHAR]
                        |DeclSpecs[*]::TypeName
                          [getUnderlyingType().getTypeName()!='int']
                          [getUnderlyingType().getTypeName()!='signed int']
                          [getUnderlyingType().getTypeName()!='unsigned int']
                        ]
                        [DeclSpecs[*]::AnyTypeName [$0:=pretty()] ]
                      ]


- prompt: Find all instances where '__typeof__' is used. This KAST expression should only check programs written in C language and not in C++ language.


-This is the pattern for the above prompt:

                    //TypeOfExpr [isCLanguage()]


- prompt: Find all instances where syntactically ambiguous declarations are written. This KAST expression should only check programs written in C++ language and not in C language.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                    // Decl [not isCLanguage()]
                            [DeclSpecs[*]::TypeName]
                            [Declarators[*]::ParensDeclarator]
                            [not (parent::FuncDeclarator)]

-->pattern 2 :

                    // Decl [not isCLanguage()]
                            [DeclSpecs[*]::TypeName]
                            [Declarators[*]::FuncDeclarator]


- prompt: Find all instances where replacement dynamic storage management requirements for 'new' is not honored. This KAST expression should only check programs written in C++ language and not in C language.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                    //FuncDef [not isCLanguage()]
                                 [  Declarator::PtrDeclarator/Declarator::FuncDeclarator
                                    [  Declarator::NameDeclarator/Name::OpFunc [@Op = KTC_OPCODE_NEW | @Op = KTC_OPCODE_NEW_ARRAY]]
                                    [  Throw::Null |
                                       Throw::DenyThrowSpec/Expr::BoolLiteralExpr [@Value = KTC_BOOLVALUE_FALSE] |
                                       Throw::DenyThrowSpec/Expr::BinaryExpr |
                                       Throw::ExceptionSpec
                                    ]
                                 ]
                              [FuncBody::FuncBody/Stmt::CompoundStmt
                               [not  descendant::ThrowExpr/Expr::TypeConvExpr/Type::TypeName/Name::QualifiedName
                                      [Qualifier::NameSpec [getName() = 'std']]
                                      [Name::UnqualifiedName [getName() = 'bad_alloc']]
                               ]
                              ]

-->pattern 2 :

                    //MemberFunc [not isCLanguage()]
                                 [  Declarator::PtrDeclarator/Declarator::FuncDeclarator
                                    [  Declarator::NameDeclarator/Name::OpFunc [@Op = KTC_OPCODE_NEW | @Op = KTC_OPCODE_NEW_ARRAY]]
                                    [  Throw::Null |
                                       Throw::DenyThrowSpec/Expr::BoolLiteralExpr [@Value = KTC_BOOLVALUE_FALSE] |
                                       Throw::DenyThrowSpec/Expr::BinaryExpr |
                                       Throw::ExceptionSpec
                                    ]
                                 ]
                              [FuncBody::FuncBody/Stmt::CompoundStmt
                               [not  descendant::ThrowExpr/Expr::TypeConvExpr/Type::TypeName/Name::QualifiedName
                                      [Qualifier::NameSpec [getName() = 'std']]
                                      [Name::UnqualifiedName [getName() = 'bad_alloc']]
                               ]
                              ]


- prompt: Find all instances where a volatile object is passed to a function through a nonvolatile pointer.


-This is the pattern for the above prompt:

                   //CallExpr [$func := getSemanticInfo()]/Args[*]::UnaryExpr   [@Op = KTC_OPCODE_ADDRESS]
                      [ isPointer() ] [ $ptType := getPointedType() ] [not $ptType.isPointer()] [ $ptType.isVolatile() ] [Expr::* [$1 := getName()]]
                      [$param := getFormalParameter($func,getPositionInList())][$paramType := getLanguageType($param)]
                      [$paramType.isPointer()] [not $paramType.getPointedType().isVolatile()] [$0 := $param.getName()]


- prompt: Find all instances where pseudorandom number generators are not properly seed.


-This is the pattern for the above prompt:

                    // CallExpr [getName() = 'random']
                                [not (ancestor::CompoundStmt/Stmts[*]::ExprStmt/Expr::CallExpr [getName() = 'srandom'])]


- prompt: Find all instances where a const char pointer to a non-const char pointer is assigned. This KAST expression should only check programs written in C language and not in C++ language.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                   //Decl [Declarators[*]::InitializedDeclarator/Declarator::PtrDeclarator [ not getPointedType().isConst()] [$0 := getName()] ]
                          [Declarators[*]::InitializedDeclarator/Init::CopyInitializer
                             [Expr::StringLiteralExpr | Expr::IdExpr [isPointer()][getPointedType().isConst()] | Expr::CallExpr [isPointer()][getPointedType().isConst()]]]
                          [DeclSpecs[*]::BuiltinType [@Spec = KTC_BUILTINTYPE_CHAR] | DeclSpecs[*]::TypeName [getUnderlyingType().getTypeName() = 'char' | isTypeWChar_t()] ]

-->pattern 2 :

                   //ExprStmt/Expr::BinaryExpr [  Left::IdExpr [isPointer()]
                                                            [$ptr := getPointedType()][not $ptr.isConst()]
                                                            [$charType := $ptr.getUnderlyingType().getTypeName()]
                                                            [$charType = 'char' | isPointerTypeWChar_t()] [$0 := getName()]
                                               ]
                                               [  Right::StringLiteralExpr |
                                                  Right::IdExpr [isPointer()][getPointedType().isConst()] |
                                                  Right::CallExpr [isPointer()][getPointedType().isConst()] |
                                                  Right::CallExpr [isCLanguage()][getName().matches('strchr|strrchr|strpbrk|strstr|wcspbrk|wcschr|wcsrchr|wcsstr')][Args[0]::IdExpr [isPointer()][getPointedType().isConst()]] |
                                                  Right::CallExpr [isCLanguage()][getName().matches('strerror|strerror_l|strerror_r|_wcserror')]
                                               ]


- prompt: Find all instances where replacement dynamic storage management requirements for 'delete' is not honored. This KAST expression should only check programs written in C++ language and not in C language.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                    //FuncDef [not isCLanguage()]
                                 [  Declarator::FuncDeclarator
                                    [  Declarator::NameDeclarator/Name::OpFunc [@Op = KTC_OPCODE_DELETE | @Op = KTC_OPCODE_DELETE_ARRAY]]
                                    [  Throw::Null |
                                        Throw::DenyThrowSpec/Expr::BoolLiteralExpr [@Value = KTC_BOOLVALUE_FALSE] |
                                       Throw::DenyThrowSpec/Expr::BinaryExpr |
                                       Throw::ExceptionSpec/TypeIds[*]::TypeId
                                    ]
                                 ]

-->pattern 2 :

                    //MemberFunc [not isCLanguage()]
                                 [  Declarator::FuncDeclarator
                                    [  Declarator::NameDeclarator/Name::OpFunc [@Op = KTC_OPCODE_DELETE | @Op = KTC_OPCODE_DELETE_ARRAY]]
                                    [  Throw::Null |
                                        Throw::DenyThrowSpec/Expr::BoolLiteralExpr [@Value = KTC_BOOLVALUE_FALSE] |
                                       Throw::DenyThrowSpec/Expr::BinaryExpr |
                                       Throw::ExceptionSpec/TypeIds[*]::TypeId
                                    ]
                                 ]


- prompt: Find all instances where enumeration literal constant is not of type int. This KAST expression should only check programs written in C language and not in C++ language.


-This is the pattern for the above prompt:

                    //Enumerator [isCLanguage()]
                        [Expr::LiteralExpr [getIntValue()>32767]
                        |Expr::UnaryExpr[@Op=KTC_OPCODE_MINUS]/Expr::LiteralExpr [getIntValue()>32768]
                        ]
                        [$0:=Expr::AnyExpr.pretty().replace(' ','')]


- prompt: Find all instances where copy operations mutates the source object. This KAST expression should only check programs written in C++ language and not in C language.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                    //MemberFunc  [not isCLanguage()]
                                  [isCopyConstructor() | isAssignmentOperator()]
                                  [$p1 := getFormalParameter(getSemanticInfo(),0)][not $p1.getLanguageType().isRvalueReference()][$p1name := $p1.getName()]
                                  /FuncBody::FuncBody/Stmt::CompoundStmt/descendant::BinaryExpr/Left::MemberExpr [Expr::IdExpr [$p1name = getName()]][$0 := getName()]

-->pattern 2 :

                    //FuncDeclarator [not isCLanguage()]
                                     [isCopyConstructor() | isAssignmentOperator()]
                                     [$signature := pretty()] [not $signature.contains('&&')]
                                     [Params[*]::Decl/Declarators[*]::PtrDeclarator/Declarator::NameDeclarator [$other := getName()]]/ancestor::MemberFunc/descendant::BinaryExpr/Left::MemberExpr/Expr::IdExpr [getName() = $other][$0 := $other]


- prompt: Find all instances where a reference type is qualified with const or volatile. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

                    // PtrDeclarator [not isCLanguage()] [@Spec=KTC_POINTEROPERATOR_REFERENCE] [$0 := getName()] / CVQualifiers[*]::CVQualifier [@Spec = KTC_CVQUALIFIER_CONST | @Spec = KTC_CVQUALIFIER_VOLATILE]


- prompt: Find all instances where binary constant is used.


-This is the pattern for the above prompt:

                    //LiteralExpr [pretty().matches('^0[bB]\\d+')] [$0:=pretty()]


- prompt: Find all instances where octal constant is used.


-This is the pattern for the above prompt:

                    //LiteralExpr [pretty().matches('^0\\d+')] [$0:=pretty()]


- prompt: Find all instances where definition of an anonymous struct object is present. This KAST expression should only check programs written in C language and not in C++ language.


-This is the pattern for the above prompt:

                    //Decl[Declarators::Null][isCLanguage()]/DeclSpecs[*]::ClassType [@Tag=KTC_CLASSTAG_STRUCT] [getName().matches('^#.*#$')]


- prompt: Find all instances where the standard namespaces are modified. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

                    // NamespaceDecl [not isCLanguage()] [$name := getName()] [$name = 'std' | $name = 'posix']
                                            [descendant::Decl]
                                            [$0 := $name]


- prompt: Find all instances where wrap functions are present that can spuriously fail up in a loop.


-This is the pattern for the above prompt:

                    // CallExpr [$name := getName()]
                                [$name = '__atomic_compare_exchange' | $name = '_Atomic_compare_exchange_weak_1' | $name = 'atomic_compare_exchange_weak_explicit']
                                [not (ancestor::WhileStmt [not (Cond::LiteralExpr | Cond::BoolLiteralExpr)] |
                                      ancestor::DoStmt [not (Cond::LiteralExpr | Cond::BoolLiteralExpr)] |
                                      ancestor::ForStmt [not (Cond::LiteralExpr | Cond::BoolLiteralExpr)]
                                     )]
                                [$0 := $name]


- prompt: Find all instances where an array is deleted through a pointer of the incorrect type.


-This is the pattern for the above prompt:

                    // Decl [$ptrType := DeclSpecs[*]::TypeName]
                            [Declarators[*]::InitializedDeclarator/Init::CopyInitializer/Expr::NewExpr/Type::TypeId [$resType := DeclSpecs[*]::TypeName]
                                                                                                                    [Declarator::ArrayDeclarator]
                            ]
                            [$resType.isDerivedFrom($ptrType.getTypeName())]
                            [$ptrName := getName(Declarators[*]::InitializedDeclarator/Declarator::PtrDeclarator/Declarator::NameDeclarator)]
                            [ancestor::FuncBody/descendant::DeleteExpr/Expr::IdExpr [getName() = $ptrName]]
                            [$0 := $ptrName]


- prompt: Find all instances where return statement is present in a function declared [[noreturn]].


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                    //FuncDef[DeclSpecs[*]::AttributeDeclSpec/AttributeSpec::AttributeSpec/Attributes[*]::Attribute[@Name=KTC_ATTRIBUTE_NORETURN]]/FuncBody::FuncBody/Stmt::CompoundStmt/Stmts[*]::ExprStmt[not Expr::CallExpr/Func::IdExpr[getName()='exit']][not next-sibling]

-->pattern 2 :

                    //ReturnStmt[ancestor::FuncDef[DeclSpecs[*]::AttributeDeclSpec/AttributeSpec::AttributeSpec/Attributes[*]::Attribute[@Name=KTC_ATTRIBUTE_NORETURN]]]

-->pattern 3 :

                    //FuncDef[DeclSpecs[*]::AttributeDeclSpec/AttributeSpec::AttributeSpec/Attributes[*]::Attribute[@Name=KTC_ATTRIBUTE_NORETURN]]/FuncBody::FuncBody/Stmt::CompoundStmt/Stmts[*]::IfStmt[not next-sibling][Else::{IfStmt/Else::}Null]

-->pattern 4 :

                    //FuncDef[DeclSpecs[*]::AttributeDeclSpec/AttributeSpec::AttributeSpec/Attributes[*]::Attribute[@Name=KTC_ATTRIBUTE_NORETURN]]/FuncBody::FuncBody/Stmt::CompoundStmt/Stmts[*]::IfStmt[not next-sibling]/Then::*[not descendant::ThrowExpr][not descendant::CallExpr/Func::IdExpr[getName()='exit']]

-->pattern 5 :

                    //FuncDef[DeclSpecs[*]::AttributeDeclSpec/AttributeSpec::AttributeSpec/Attributes[*]::Attribute[@Name=KTC_ATTRIBUTE_NORETURN]]/FuncBody::FuncBody/Stmt::CompoundStmt/Stmts[*]::IfStmt[not next-sibling]/Else::{IfStmt/Else::}*[not descendant::ThrowExpr][not descendant::CallExpr/Func::IdExpr[getName()='exit']]


- prompt: Find all instances where a pointer to an incomplete type is deleted.


-This is the pattern for the above prompt:

                    // DeleteExpr/descendant::IdExpr [$type := getPointedType()]
                                                    [$ptrName := getName()]
                                                    [$line := getNodeLine()]
                                                    [not ($type.isBuiltinType())]
                                                    [not (ancestor::TranslationUnit/descendant::Decl [getNodeLine() < $line] /DeclSpecs[*]::ClassType [isDefinition()] /Name::Name [@Id = $type.getTypeName()] ) ]
                                                    [$0 := $ptrName]
                                                    [$1 := $line]


- prompt: Find all instances where the program is terminated abruptly.


-This is the pattern for the above prompt:

                    // CallExpr / Func::IdExpr [$name := getName()]
                                            [$name = '_Exit' | $name = 'abort' | $name = 'quick_exit']
                                            [$0 := $name]


- prompt: Find all instances where meaningful symbolic constants are not used to represent literal array size values. This KAST expression should only check programs written in C language and not in C++ language.


-This is the pattern for the above prompt:

                    //ArrayDeclarator/Size::LiteralExpr [isCLanguage()]
                      [not isFromMacro()]
                      [getIntValue()!=0]
                      [getIntValue()!=1]
                      [$0:=pretty()]


- prompt: Find all instances where a string is converted to a number.


-This is the pattern for the above prompt:

                    // BinaryExpr[Left::{BinaryExpr/Left::}IdExpr[getName()='cin']][@Op=KTC_OPCODE_ASR][Right::IdExpr[isIntegral()|isFloatPoint()][$0:=getName()]][not ancestor::TryStmt][not ancestor::ExprStmt/next-sibling::IfStmt/Cond::{*/descendant::}CallExpr/Func::MemberExpr[Expr::IdExpr[getName()='cin']][Name::Name[getName()='fail' | getName()='good' | getName()='bad']]]


- prompt: Find all instances where thread safety and liveness is not preserved when using condition variables. This KAST expression should only check programs written in C language and not in C++ language.


-This is the pattern for the above prompt:

                    // CallExpr [isCLanguage()] [getName() = 'cnd_signal'] [not (Args[*]::UnaryExpr/Expr::IndexExpr)]


- prompt: Find all instances where meaningful symbolic constants are not used to represent literal bit-field values. This KAST expression should only check programs written in C language and not in C++ language.


-This is the pattern for the above prompt:

                    //BitFieldDeclarator/Bits::LiteralExpr [isCLanguage()]
                      [not isFromMacro()]
                      [getIntValue()!=1]
                      [$0:=pretty()]


- prompt: Find all instances where constructor member initializers are not written in the canonical order. This KAST expression should only check programs written in C++ language and not in C language.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                    //MemberFunc[not isCLanguage()][FuncBody::FuncBody/CtorInit::CtorInitializer[MemberInitializers::MemberInitializer[Name::Name[$firstName:=getName()][$0:=$firstName]]/next-sibling::MemberInitializer[Name::Name[$secondName:=getName()][$1:=$secondName]]]][parent::ClassType/MemberDecls[*]::MemberDecl[Declarators[*]::{InitializedDeclarator/Declarator::}NameDeclarator[$declFirstName:=getName()][$declFirstName=$firstName]][not next-sibling::MemberDecl | next-sibling::MemberDecl/Declarators[*]::{InitializedDeclarator/Declarator::}NameDeclarator[$declSecondName:=getName()][$declSecondName!=$secondName]]]

-->pattern 2 :

                    //MemberFunc[not isCLanguage()][FuncBody::FuncBody/CtorInit::CtorInitializer/MemberInitializers::MemberInitializer[Name::Name[$firstName:=getName()][$0:=$firstName][$firstType:=isClassMember()]]/next-sibling::MemberInitializer[Name::Name[$secondName:=getName()][$1:=$secondName][$secondType:=isClassMember()]]][$firstType=$secondType][parent::ClassType/BaseSpecs[*]::BaseSpec[Name::NameSpec[$specFirstName:=getName()][$specFirstName=$firstName]][not next-sibling::BaseSpec | next-sibling::BaseSpec/Name::NameSpec[$specSecondName:=getName()][not $specSecondName=$secondName]]]


- prompt: Find all instances where pointer-to-member operators are used to access nonexistent members. This KAST expression should only check programs written in C++ language and not in C language.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                    //SpecialCastExpr[not isCLanguage()][Type::TypeId/Declarator::FuncDeclarator/Declarator::ParensDeclarator/Declarator::PtrDeclarator/NameSpec::NameSpec[$tName:=getName()][$0:=$tName]][Expr::UnaryExpr/Expr::IdExpr/Name::QualifiedName/Name::Name[$mName:=getName()][$1:=$mName]][ancestor::TranslationUnit/descendant::ClassType[Name::Name[getName()=$tName]][not MemberDecls[*]::MemberFunc | MemberDecls[*]::MemberFunc/Declarator::FuncDeclarator[Declarator::NameDeclarator[getName()!=$mName]]]]

-->pattern 2 :

                    //Decl/Declarators[*]::FuncDeclarator[not isCLanguage()][Declarator::ParensDeclarator/Declarator::PtrDeclarator/NameSpec::NameSpec[$0:=getName()][$1:='nullptr']]

-->pattern 3 :

                    //InitializedDeclarator[not isCLanguage()][Declarator::FuncDeclarator[Declarator::ParensDeclarator/Declarator::PtrDeclarator/NameSpec::NameSpec[$0:=getName()]]][Init::CopyInitializer[(Expr::IdExpr[getName()='nullptr'][$1:=getName()])| Expr::LiteralExpr[@Value=0][$1:='0']]]


- prompt: Find all instances where special member functions and overloaded operators to C Standard Library functions are not used. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

                    //CallExpr [not isCLanguage()] / Func::IdExpr[$fName:=getName()][$0:=$fName][$fName='memset'| $fName='memcpy'| $fName='memmove' | $fName='strcpy' | $fName='memcmp' | $fName='strcmp']


- prompt: Find all instances where a mutex is destroyed while it is locked. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

                    //TypeConvExpr [not isCLanguage()] [Type::TypeName[getName()='thread']][Args[*]::{*/Expr::}IdExpr[getTypeName()='mutex'][not isGlobal()][$0:=getName()][$line1:=getNodeLine()]][parent::BinaryExpr/Left::{IndexExpr/Expr::}IdExpr[$thrName:=getName()]][not (ancestor::FuncDef/descendant::CallExpr/Func::MemberExpr[Expr::{IndexExpr/Expr::}IdExpr[getName()=$thrName]][Name::Name[getName()='join'][$line2:=getNodeLine()][$line1 < $line2]])]


- prompt: Find all instances where thread safety and liveness are not preserved when using condition variables. This KAST expression should only check programs written in C++ language and not in C language.


-This is the pattern for the above prompt:

                    //CallExpr [not isCLanguage()] /Func::MemberExpr[Expr::IdExpr[getTypeName()='condition_variable' | getTypeName()='condition_variable&']][Name::Name[@Id='notify_one'][$0:=@Id]]


- prompt: Find all instances where '@ address' is used. This KAST expression should only check programs written in C language and not in C++ language.


-This is the pattern for the above prompt:

                    //Decl [isCLanguage()] [Declarators::AnyDeclarator [isVariable()] ] [pretty().matches('@\\s+\\(?\\s*0x\\w+\\s*\\)?\\s*;$')]


- prompt: Find all instances where string range formatter is used. This KAST expression should only check programs written in C language and not in C++ language.


-This is the pattern for the above prompt:

                    //CallExpr [isCLanguage()] [Args[0]::StringLiteralExpr [@Value.matches('%\\[[a-zA-Z]-[a-zA-Z]\\]')] ]


- prompt: Find all instances where invalid data is passed to the asctime() function.


-This is the pattern for the above prompt:

                    // CallExpr [getName() = 'asctime']


- prompt: Find all instances where std::rand() is used for generating pseudorandom numbers.


-This is the pattern for the above prompt:

                    // CallExpr / Func::IdExpr [getName() = 'rand']
                                            [not (Name::QualifiedName) | Name::QualifiedName/Qualifier::NameSpec/Name::Name [@Id = 'std']]


- prompt: Find all instances where a signal handler is not a plain old function. This KAST expression should only check programs written in C++ language and not in C language.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                    //CallExpr[Func::IdExpr[getName()='signal']][not isCLanguage()][Args[1]::IdExpr[$handler:=getName()][$0:=$handler]][not (ancestor::TranslationUnit/descendant::LinkageSpec/descendant::FuncDeclarator/Declarator::NameDeclarator[getName()=$handler])]

-->pattern 2 :

                    //CallExpr[Func::IdExpr[getName()='signal']][not isCLanguage()][Args[1]::IdExpr[$handler:=getName()]]/ancestor::TranslationUnit/descendant::LinkageSpec/descendant::FuncDeclarator/Declarator::NameDeclarator[getName()=$handler]/ancestor::FuncDef/FuncBody::FuncBody/descendant::CallExpr[$callName:=getName()][$0:=$callName][ancestor::TranslationUnit/Decls[*]::Decl/Declarators[*]::FuncDeclarator[getName()=$callName]/descendant::DenyThrowSpec]


- prompt: Find all instances where T2OLE or OLE2CT is called within a loop.


-This is the pattern for the above prompt:

          // CallExpr [Func::IdExpr [getName() = 'AtlA2WHelper']]
                      /descendant::CallExpr [Func::IdExpr [getName() = '_alloca']]
                      [Args[*]::BinaryExpr/Left::IdExpr [getName() = '_convert']]
                      [ancestor::ForStmt | ancestor::WhileStmt | ancestor::DoStmt]


- prompt: Find all instances where string literal or casted CString is passed to COM function expecting BSTR parameter.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

          // CallExpr [Args[*]::StringLiteralExpr [$paramPos := getPositionInList()]]
            [Func::MemberExpr [$funcName := getName()]]
            [ancestor::TranslationUnit/descendant::FuncDeclarator [getName() = $funcName]
                                                                  [Params[*]::Decl [DeclSpecs[*]::TypeName [getName() = 'BSTR']]
                                                                                   [getPositionInList() = $paramPos]
                                                                  ]
            ]

-->pattern 2 :

          // CallExpr [Args[*]::CastExpr [getTypeName() = 'LPOLESTR']
                               [$paramPos := getPositionInList()]]
            [Func::MemberExpr [$funcName := getName()]]
            [ancestor::TranslationUnit/descendant::FuncDeclarator [getName() = $funcName]
                                                                  [Params[*]::Decl [DeclSpecs[*]::TypeName [getName() = 'BSTR']]
                                                                                   [getPositionInList() = $paramPos]
                                                                  ]
            ]


- prompt: Find all instances where T2OLE or OLE2CT is called within a return statement.


-This is the pattern for the above prompt:

          //ReturnStmt [descendant::CallExpr [Func::IdExpr [getName() = '_alloca']]
                                             [Args[*]::BinaryExpr/Left::IdExpr [getName() = '_convert']]
                       ]


- prompt: Find all instances of incorrect or missing InitInstance override for class derived from CWinApp.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

        // FuncDef [Declarator/descendant::QualifiedName [Qualifier::NameSpec [$className := getName()]]
                                                 [Name::Name [getName() = 'InitInstance']]
                                                 [ancestor::TranslationUnit/descendant::ClassType [getName() = $className]
                                                                                                  [getLanguageType().isDerivedFrom('CWinApp')]
                                                 ]
           ]
           [FuncBody::FuncBody [descendant::CallExpr [$firstCall := getNodeLine()]]
                               [ not (descendant::CallExpr [Func::IdExpr [getName() = 'AfxSetAmbientActCtx']]
                                                           [(Args[0]::LiteralExpr [@Value = 0]) |
                                                            (Args[0]::BoolLiteralExpr [@Value = KTC_BOOLVALUE_FALSE])
                                                           ]
                                                           [not (getNodeLine() > $firstCall)]
                                      )
                                      |
                                     (descendant::BinaryExpr [ getOperationCode() = KTC_OPCODE_ASSIGN]
                                                             [Left::MemberExpr [Expr::CallExpr/Func::IdExpr [getName() = 'AfxGetModuleState']]
                                                                               [Name::QualifiedName/Name::Name [getName() = 'm_bSetAmbientActCtx']]
                                                             ]
                                                             [(Right::LiteralExpr [@Value = 0]) |
                                                              (Right::BoolLiteralExpr [@Value = KTC_BOOLVALUE_FALSE])
                                                             ]
                                                             [not (getNodeLine() > $firstCall)]
                                     )
                                ]
            ]

-->pattern 2 :

          // ClassType [getLanguageType().isDerivedFrom('CWinApp')]
             [not (descendant::NameDeclarator [getName() = 'InitInstance'])]


- prompt: Find all instances where loop iterator variables are externally declared.


-This is the pattern for the above prompt:

          // ForStmt [not (Init::Decl | Init::ExprStmt/Expr::Null)]


- prompt: Find all instances where destructors are not declared as virtual.


-This is the pattern for the above prompt:

          // ClassType [BaseSpecs[*]::BaseSpec]
                       /MemberDecls[*]::MemberDecl [Declarators[*]::FuncDeclarator/Declarator::NameDeclarator [isDestructor()]
                                                                                                              [not (isVirtual())]
                                                   ]


- prompt: Find all instances where cString is calling CString.Format() on itself.


-This is the pattern for the above prompt:

          // CallExpr [Func::MemberExpr/Expr::IdExpr/Name::Name
                          [$objName :=  @Id]
                          [getTypeName() = 'CString']
                      ]
                      [Func::MemberExpr/Name::Name[@Id = 'Format']]
                      [Args[*]::AnyExpr/descendant-or-self::IdExpr/Name::Name[@Id = $objName]]


- prompt: Find all instances where hard-coded loop is used for array index.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

          // ForStmt [Init::Decl/Declarators[*]::InitializedDeclarator [$indexName := getName()]
                                                                       [Init::CopyInitializer/Expr::LiteralExpr]
                     ]
                     /Cond::BinaryExpr [Left::IdExpr [getName() = $indexName]]
                                       [Right::LiteralExpr [not (comesFromMacro())]]

-->pattern 2 :

          // ForStmt/Cond::BinaryExpr [Left::IdExpr [$indexName := getName()]]
                                      [Right::LiteralExpr [comesFromMacro()] [$sizeVal := getIntValue()]]
                                      [parent::ForStmt/Stmt::DeclOrStmts/descendant-or-self::IndexExpr [Expr::IdExpr [isArray()] [$arrayName := getName()]]
                                                                                                       [Index::IdExpr [getName() = $indexName]]
                                      ]
                                     [ancestor::FuncBody/descendant::ArrayDeclarator [getName() = $arrayName]
                                                                                      [not (Size::LiteralExpr [getIntValue() = $sizeVal])]
                                      ]

-->pattern 3 :

          // ForStmt/Cond::BinaryExpr [Left::IdExpr [$indexName := getName()]]
                                      [Right::IdExpr [isConstant()]
                                                     [$sizeName := getName()]
                                      ]
                                      [parent::ForStmt/Stmt::DeclOrStmts/descendant-or-self::IndexExpr [Expr::IdExpr [isArray()] [$arrayName := getName()]]
                                                                                                       [Index::IdExpr [getName() = $indexName]]
                                      ]
                                      [ancestor::FuncBody/descendant::ArrayDeclarator [getName() = $arrayName]
                                                                                      [not (Size::IdExpr [getName() = $sizeName])]
                                      ]

-->pattern 4 :

          // ForStmt/Cond::BinaryExpr [Left::IdExpr [$indexName := getName()]]
                                      [Right::IdExpr]
                                      [parent::ForStmt/Stmt::DeclOrStmts/descendant-or-self::CallExpr [Func::MemberExpr/Expr::IdExpr [(getTypeName().starts-with('vector')) |
                                                                                                                                      (getTypeName().starts-with('CArray'))]
                                                                                                      ]
                                                                                                      [Args[*]::IdExpr [getName() = $indexName]]
                                      ]


- prompt: Find all instances where the public, protected, and private sections of a class is not declared in the order - 'public , protected and private'.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

//AccessSpecification [@Access = KTC_ACCESSSPECIFIER_PRIVATE]
    [following-sibling[*]::AccessSpecification
        [@Access = KTC_ACCESSSPECIFIER_PUBLIC | @Access = KTC_ACCESSSPECIFIER_PROTECTED]
    ]
    [$0:='Private'] [$1:='public or protected']

-->pattern 2 :

//AccessSpecification [@Access = KTC_ACCESSSPECIFIER_PROTECTED]
    [following-sibling[*]::AccessSpecification [@Access = KTC_ACCESSSPECIFIER_PUBLIC] ]
    [$0:='Protected'] [$1:='public']


- prompt: Find all instances where assumptions are made for the initialization order of non-local static objects, in separate translation units.


-This is the pattern for the above prompt:

//IdExpr [isVariable()] [isExtern()] [isGlobal()]
    [parent::{AnyExpr/parent::}CopyInitializer/parent::InitializedDeclarator [isStatic()] [isGlobal()]
    |parent::MemberInitializer
    |ancestor::MemberFunc [isConstructor()]
    ]
    [$0:=getName()]
- prompt: Find all instances where arrays are treated polymorphically.


-This is the pattern for the above prompt:

//IdExpr [parent::{AnyExpr/parent::}CallExpr [$arg_count:=getNumberOfActualParams()] [$call_name:=getName()] ] [isArray()]
    [$ArrayElementType:=getArrayElementType()] [$ArrayElementType.isClass()] [$ArrayElementType.isDerived()]
    [$pos:=getPositionInList()]
    [$sema:=parent::{AnyExpr/parent::}CallExpr.getSemanticInfo()] [$param_sema:=getFormalParameter($sema,$pos)]
    [ancestor::TranslationUnit/descendant::FuncDeclarator
        [getNumberOfFormalParams()=$arg_count]
        [Params[*]::Decl[getPositionInList()=$pos]/Declarators[*]::{AnyDeclarator/Declarator::}NameDeclarator [getSemanticInfo()=$param_sema] [$base_type:=getTypeName()] ]
        [parent::* /FuncBody::FuncBody
            [descendant::UnaryExpr
                [Expr::IdExpr [getSemanticInfo()=$param_sema] ]
                [@Op=KTC_OPCODE_POSTINC | @Op=KTC_OPCODE_POSTDEC | @Op=KTC_OPCODE_PREINC | @Op=KTC_OPCODE_PREDEC]
            |descendant::IndexExpr/Expr::IdExpr [getSemanticInfo()=$param_sema] ]
        ]
    ]
    [$0:=getName()] [$1:=getTypeName()] [$2:=$base_type] [$3:=$call_name]


- prompt: Find all instances of pointers to pointers.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

//Decl/Declarators[*]::PtrDeclarator[@Spec=KTC_POINTEROPERATOR_POINTER]
    /Declarator::PtrDeclarator[@Spec=KTC_POINTEROPERATOR_POINTER]
    /Declarator::{AnyDeclarator/Name::}Name [$0:=getName()]

-->pattern 2 :

//InitializedDeclarator/Declarator::PtrDeclarator[@Spec=KTC_POINTEROPERATOR_POINTER]
    /Declarator::PtrDeclarator[@Spec=KTC_POINTEROPERATOR_POINTER]
    /Declarator::{AnyDeclarator/Name::}Name [$0:=getName()]


- prompt: Find all instances where the definition of a member function contains default arguments that produce a signature identical to that of the implicitly-declared copy constructor.


-This is the pattern for the above prompt:

//FuncDeclarator [isCopyConstructor()] [getNumberOfFormalParams()>1]


- prompt: Find all instances where two opposite operators (such as == and !=), are either not defined or one is not defined in terms of the other.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

//ClassType/MemberDecls[*]::AnyMemberDecl
    [Declarator::FuncDeclarator[isOpFunc()]/Declarator::NameDeclarator/Name::OpFunc[@Op=KTC_OPCODE_EQ]
    |Declarators[*]::FuncDeclarator[isOpFunc()]/Declarator::NameDeclarator/Name::OpFunc[@Op=KTC_OPCODE_EQ]
    ]
    [not parent::ClassType/MemberDecls[*]::MemberFunc [isOpFunc()]
        [Declarator::FuncDeclarator/Declarator::NameDeclarator/Name::OpFunc [@Op=KTC_OPCODE_NE] ]
    ]
    [not parent::ClassType/MemberDecls[*]::MemberDecl/Declarators[*]::FuncDeclarator [isOpFunc()]
        [Declarator::NameDeclarator/Name::OpFunc [@Op=KTC_OPCODE_NE]]
    ]
    [$0:='=='] [$1:='!=']

-->pattern 2 :

//ClassType/MemberDecls[*]::AnyMemberDecl
    [Declarator::FuncDeclarator[isOpFunc()]/Declarator::NameDeclarator/Name::OpFunc[@Op=KTC_OPCODE_NE]
    |Declarators[*]::FuncDeclarator[isOpFunc()]/Declarator::NameDeclarator/Name::OpFunc[@Op=KTC_OPCODE_NE]
    ]
    [not parent::ClassType/MemberDecls[*]::MemberFunc [isOpFunc()]
        [Declarator::FuncDeclarator/Declarator::NameDeclarator/Name::OpFunc [@Op=KTC_OPCODE_EQ] ]
    ]
    [not parent::ClassType/MemberDecls[*]::MemberDecl/Declarators[*]::FuncDeclarator [isOpFunc()]
        [Declarator::NameDeclarator/Name::OpFunc [@Op=KTC_OPCODE_EQ]]
    ]
    [$0:='!='] [$1:='==']


- prompt: Find all instances where all the members of a structure (or class) are either not named or not only accessed via their names.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

//ClassType
    [Name::Null]
    [parent::MemberDecl
    [not DeclSpecs[*]::FuncSpec [@Spec=KTC_FUNCSPECIFIER_FRIEND] ]
        [parent::ClassType [isClassType() | isStructType()] ]
        [Declarators::Null]
    ]

-->pattern 2 :

//MemberDecl/Declarators::AnyDeclarator [Declarator::Null]
    [not Bits::LiteralExpr [@Value=0] ] [not Bits::IdExpr [getIntValue()=0] ]


- prompt: Find all instances where hierarchies are not based on abstract classes.


-This is the pattern for the above prompt:

//BaseSpec[parent::ClassType[isClassType()][$0:=getName()]]/Name::NameSpec [not isAbstract()] [$1:=getName()]


- prompt: Find all instances where an inherited nonvirtual function is redefined in a derived class.


-This is the pattern for the above prompt:

//FuncDeclarator [isClassMember()] [isDefinition()] [not isVirtual()] [getOverridenMethod()]
    [getReturnType() = getOverridenMethod().getReturnType()]
    [$0:=getName()] [$1:=getOverridenMethod().getParent().getName()]


- prompt: Find all instances where a typedef is not used to simplify program syntax when declaring function pointers.


-This is the pattern for the above prompt:

//FuncDeclarator/Declarator::ParensDeclarator [not isTypedef()]


- prompt: Labels are allowed only in switch cases. Find all instances where labels are used in other places.


-This is the pattern for the above prompt:

//LabeledStmt/Label::Label


- prompt: Find all instances where (wsclen()+1*sizeof(wchar_t)) is not used when allocating memory with malloc for wchar_t buffers.


-This is the pattern for the above prompt:

                   //CallExpr [getName() = 'malloc']
                              [parent::CastExpr/Type::TypeId [getTypeName() ='wchar_t*'] ]
                              [Args[0]::AnyExpr/descendant::CallExpr [getName() = 'wsclen']]
                              [not ((Args[0]::BinaryExpr [@Op = KTC_OPCODE_MUL]
                              [descendant::ParensExpr/Expr::BinaryExpr [@Op = KTC_OPCODE_ADD]
                              [Right::CallExpr [getName() = 'wsclen']] [Left::LiteralExpr [@Value = 1]]]
                              [descendant::SizeOfExpr/Type::TypeId [getTypeName() ='wchar_t']]
                              ) |(Args[0]::BinaryExpr [@Op = KTC_OPCODE_MUL]
                              [descendant::ParensExpr/Expr::BinaryExpr [@Op = KTC_OPCODE_ADD]
                              [Left::CallExpr [getName() = 'wsclen']] [Right::LiteralExpr [@Value = 1]]]
                              [descendant::SizeOfExpr/Type::TypeId [getTypeName() ='wchar_t']]))]


- prompt: Find all instances where sizeof() is not called when allocating memory with malloc.


-This is the pattern for the above prompt:

                   //CallExpr [getName() = 'malloc']
                              [not (Args[0]::SizeOfExpr)]
                              [not (descendant::SizeOfExpr)]


- prompt: Find all instances where getlogin is used in multithreaded applications.


-This is the pattern for the above prompt:

                   //CallExpr [getName()='getlogin']


- prompt: Find all instances where initialized public static field is not marked as final.


-This is the pattern for the above prompt:

                   //MemberDecl [Declarators[*]::InitializedDeclarator[$0:=getName()]/descendant::Name
                                [isPublic()] [isStatic()] [not (isConst())] ]


- prompt: Find all instances where a pointer is passed to a local variable in the putenv().


-This is the pattern for the above prompt:

                   //CallExpr [getName()='putenv'] [Args[0]::AnyExpr [not (isGlobal())]
                              [not (isClassMember())] [not (isStatic())] [$0:=getName()] ]


- prompt: Find all instances where function is re-entered during initialization of static objects.


-This is the pattern for the above prompt:

                   //InitializedDeclarator [not (isGlobal())] [isStatic()] [Init::* /descendant::CallExpr]
                        [ancestor::FuncBody/parent::*
                        [name()='FuncDef' | name()='MemberFunc'] [$funcName:=getName()] ]
                        [Init::* /descendant::CallExpr [getName()=$funcName] ]
                        [$0:=getName()] [$1:=$funcName]


- prompt: Find all instances where realloc() function is used.


-This is the pattern for the above prompt:

                   //CallExpr [getName()='realloc']


- prompt: Find all instances where critical private member data is directly writable by a public method.


-This is the pattern for the above prompt:

                   //MemberFunc [isPublic()] [$methodName := getName()]
                                /FuncBody::FuncBody/Stmt::CompoundStmt [Stmts[1]::Null]
                                /Stmts[0]::ExprStmt/Expr::BinaryExpr [@Op = KTC_OPCODE_ASSIGN]
                                [Left::MemberExpr |  Left::IdExpr]
                                /Left::AnyExpr  [isPrivate()] [$name := getName()]
                                [ $name = 'username'
                                | $name = 'm_username'
                                | $name = 'm_password'
                                | $name = 'password'
                                | $name = 'passwd'
                                | $name = 'm_passwd'
                                | $name = 'dateOfBirth'
                                | $name = 'm_dateOfBirth' ]
                                [ $0 := $methodName ] [$1 := $name]
- prompt: Find all instances where a class defines a copy constructor, but no assignment operator.


-This is the pattern for the above prompt:

                                    // ClassType
                                       [ MemberDecls[*]::MemberDecl
                                           / Declarators[*]::AnyDeclarator [ isCopyConstructor() ]
                                        | MemberDecls[*]::MemberFunc
                                           / Declarator::AnyDeclarator [ isCopyConstructor() ] ]
                                       [ not MemberDecls[*]::MemberDecl
                                           / Declarators[*]::AnyDeclarator [ isAssignmentOperator() ] ]
                                       [ not MemberDecls[*]::MemberFunc
                                           / Declarator::AnyDeclarator [ isAssignmentOperator() ] ]
                                       [ $0 := getName() ]


- prompt: Find all instances where function argument passed by value is too large.


-This is the pattern for the above prompt:

                    // FuncDeclarator  [ ancestor::FuncDef | ancestor::MemberFunc ]
                                       [ $1 := getName() ]
                                       / Params[*]::Decl [ Declarators[*]::AnyDeclarator [ $type := getInitialDefinedType() ]
                                                                                         [ not $type.isArray() ]
                                                                                         [ not $type.isPointer() ]
                                                                                         [ not $type.isReference() ]
                                                                                         [ $type.getTypeSize() > 128 ]
                                                                                         [ $0 := getName() ] ]


- prompt: Find all instances where incorrect call to BSTR reallocating function is being made.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                    // CallExpr [ getName() = 'SysReAllocString' | getName() = 'SysReAllocStringLen' ]
                                [ $0 := getName() ]
                                [ not Args[0]::* [ isPointerToBSTR() ] ]

-->pattern 2 :

                    // CallExpr [ getName() = 'SysReAllocString' | getName() = 'SysReAllocStringLen' ]
                                [ $0 := getName() ]
                                [ Args[1]::* [ getTypeName() = 'BSTR' |
                                               getTypeName() = 'CComBSTR' ] ]


- prompt: Find all instances where illegal comparison of BSTR values is being performed.


-This is the pattern for the above prompt:

                  // BinaryExpr [ @Op = KTC_OPCODE_LT |
                                  @Op = KTC_OPCODE_GT |
                                  @Op = KTC_OPCODE_LE |
                                  @Op = KTC_OPCODE_GE ]
                  [ Left.getTypeName() = 'BSTR' |
                  Right.getTypeName() = 'BSTR' ]


- prompt: Find all instances where c style type cast is being performed to BSTR.


-This is the pattern for the above prompt:

                     // CastExpr [ getTypeName() = 'BSTR' ]
                                 [ not Expr.isBSTRCompatible() ]


- prompt: Find all instances where type-casting is being performed between a pointer to object type and a pointer to a different object type.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                    // CastExpr
                               [ $toType := Type::TypeId]
                               [ $fromExpression := Expr::AnyExpr]
                               [ $toType._MISRA_isObjectPointer() ]
                               [ $fromExpression._MISRA_isObjectPointer() | $fromExpression.isArray() ]
                               [ $firstType := getInitialDefinedType($toType) ]
                               [ $secondType := getInitialDefinedType($fromExpression) ]
                               [ $firstType != $secondType ]
                               [ $firstPointedType := $firstType.getPointedType().getInitialDefinedType() ]
                               [ $firstPointedTypeName := getTypeName($firstPointedType)]
                               [ $firstPointedTypeName != 'char' ]
                               [ $firstPointedTypeName != 'signed char' ]
                               [ $firstPointedTypeName != 'unsigned char' ]
                               [ $0 := getQualifiedTypeName($toType) ]
                               [ $1 := getQualifiedTypeName($fromExpression) ]

-->pattern 2 :

                    // CastExpr
                               [ $toType := Type::TypeId]
                               [ $fromExpression := Expr::AnyExpr]
                               [ $toType._MISRA_isObjectPointer() ]
                               [ $fromExpression._MISRA_isObjectPointer() | $fromExpression.isArray() ]
                               [ $firstType := getInitialDefinedType($toType) ]
                               [ $secondType := getInitialDefinedType($fromExpression) ]
                               [ $firstType = $secondType ]
                               [ $firstPointedType := $firstType.getPointedType().getInitialDefinedType() ]
                               [ $secondPointedType := $secondType.getPointedType().getInitialDefinedType() ]
                               [ $firstPointedTypeName := getTypeName($firstPointedType)]
                               [ $firstPointedTypeName != 'char' ]
                               [ $firstPointedTypeName != 'signed char' ]
                               [ $firstPointedTypeName != 'unsigned char' ]
                               [ $firstPointedType.getPointedType().isVolatile() != $secondPointedType.getPointedType().isVolatile()
                               | $firstPointedType.getPointedType().isConst() != $secondPointedType.getPointedType().isConst()
                               | $firstPointedType.getPointedType().getPointedType().isVolatile() != $secondPointedType.getPointedType().getPointedType().isVolatile()
                               | $firstPointedType.getPointedType().getPointedType().isConst() != $secondPointedType.getPointedType().getPointedType().isConst() ]
                               [ $0 := getQualifiedTypeName($toType) ]
                               [ $1 := getQualifiedTypeName($fromExpression) ]


- prompt: Find all instances where function address is used instead of a call to this function.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                      // IdExpr [ isFunction() ]
                                [ parent::AnyExpr [ not isOverloaded() ]
                                                  [ $opcode := getOperationCode() ]
                                                  [ $opcode != KTC_OPCODE_NONE ]
                                                  [ $opcode != KTC_OPCODE_COMMA ]
                                                  [ $opcode != KTC_OPCODE_EQ ]
                                                  [ $opcode != KTC_OPCODE_NE ]
                                                  [ $opcode != KTC_OPCODE_CAST ]
                                                  [ $opcode != KTC_OPCODE_ADDRESS ]
                                                  [ $opcode != KTC_OPCODE_ROUND_BRACKETS ]
                                                  [ $opcode != KTC_OPCODE_COND ]
                                                  [ $opcode != KTC_OPCODE_ASSIGN ] |
                                  parent::IfStmt |
                                  parent::DoStmt |
                                  parent::ForStmt |
                                  parent::WhileStmt |
                                  parent::SwitchStmt ]
                                [ $0 := getName() ]

-->pattern 2 :

                      // MemberExpr [ isFunction() ]
                                    [ parent::AnyExpr [ not isOverloaded() ]
                                                      [ $opcode := getOperationCode() ]
                                                      [ $opcode != KTC_OPCODE_NONE ]
                                                      [ $opcode != KTC_OPCODE_COMMA ]
                                                      [ $opcode != KTC_OPCODE_EQ ]
                                                      [ $opcode != KTC_OPCODE_NE ]
                                                      [ $opcode != KTC_OPCODE_CAST ]
                                                      [ $opcode != KTC_OPCODE_ADDRESS ]
                                                      [ $opcode != KTC_OPCODE_ROUND_BRACKETS ]
                                                      [ $opcode != KTC_OPCODE_COND ]
                                                      [ $opcode != KTC_OPCODE_ASSIGN ] |
                                      parent::IfStmt |
                                      parent::DoStmt |
                                      parent::ForStmt |
                                      parent::WhileStmt |
                                      parent::SwitchStmt ]
                                    [ $0 := Name.getName() ]

-->pattern 3 :

                      // ConditionalExpr / Cond::IdExpr [ isFunction() ]
                                                        [ $0 := getName() ]

-->pattern 4 :

                      // ConditionalExpr / Cond::MemberExpr [ isFunction() ]
                                                            [ $0 := Name.getName() ]


- prompt: Find all instances where an expression is type casted to a type of a potentially incompatible size.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                    // CastExpr [ Type::TypeId [ $cptype := getInitialDefinedType().getPointedType() ]
                                               [ $cptype.getInitialDefinedType().isIntegral() ]
                                               [ $basetype := $cptype.getBaseIntegralTypeName() ] ]
                                [ Expr::AnyExpr [ $optype := getInitialDefinedType().getPointedType() ]
                                                [ $optype.getInitialDefinedType().isIntegral() ]
                                                [ $basetype != $optype.getBaseIntegralTypeName() ] ]

-->pattern 2 :

                    // CastExpr [ Type::TypeId [ getInitialDefinedType().getPointedType().getInitialDefinedType().isIntegral() ] ]
                                [ Expr::AnyExpr [ $base_type := getInitialDefinedType() ]
                                                [ $base_type.isPointer() ]
                                                [ not $base_type.getPointedType().getInitialDefinedType().isBuiltinType() ] ]

-->pattern 3 :

                    // CastExpr [ Type::TypeId  [ $base_type := getInitialDefinedType() ]
                                                [ $base_type.isPointer() ]
                                                [ not $base_type.getPointedType().getInitialDefinedType().isBuiltinType() ] ]
                                [ Expr::AnyExpr [ getInitialDefinedType().getPointedType().getInitialDefinedType().isIntegral() ] ]


- prompt: Find all instances where bSTR variable is initialized with a non-BSTR value.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                    // InitializedDeclarator [ Declarator::NameDeclarator [ getTypeName() = 'BSTR' ]
                                                                          [ $0 := getName() ] ]
                                             / Init::CopyInitializer [ not Expr::LiteralExpr [ getIntValue() = 0 ] ]
                                                                     [ not Expr.isBSTRCompatible() ]

-->pattern 2 :

                    // InitializedDeclarator [ Declarator::NameDeclarator [ getTypeName() = 'BSTR' ]
                                                                          [ $0 := getName() ] ]
                                             / Init::CopyInitializer [ Expr.isPointerToChar() |
                                                                       Expr::* [ isPointerToWChar() ]
                                                                               [ assembleString().length() != 0 ] ]


- prompt: Find all instances where used API is unsafe for window operations.


-This is the pattern for the above prompt:

                // CallExpr/Func::IdExpr
                   [ getName() = 'ChangeWindowMessageFilter' ]
                   [ $0 := 'ChangeWindowMessageFilter' ] [ $1 := 'ChangeWindowMessageFilterEx' ]


- prompt: Find all instances where c++ style type cast is being performed to BSTR.


-This is the pattern for the above prompt:

                    // SpecialCastExpr [ getTypeName() = 'BSTR' ]
                                       [ not Expr.isBSTRCompatible() ]


- prompt: Find all instances where illegal equality comparison of BSTR values is being performed.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                    // BinaryExpr [ @Op = KTC_OPCODE_EQ | @Op = KTC_OPCODE_NE ]
                                  [ Left::* [ getTypeName() = 'BSTR' ] ]
                                  [ not Right::LiteralExpr [ getIntValue() = 0 ] ]
                                  [ not Right.isBSTRCompatible() ]

-->pattern 2 :

                    // BinaryExpr [ @Op = KTC_OPCODE_EQ | @Op = KTC_OPCODE_NE ]
                                  [ Right::* [ getTypeName() = 'BSTR' ] ]
                                  [ not Left::LiteralExpr [ getIntValue() = 0 ] ]
                                  [ not Left.isBSTRCompatible() ]


- prompt: Find all instances where bitwise operation is being performed between operands of different size.


-This is the pattern for the above prompt:

                    // BinaryExpr [ @Op = KTC_OPCODE_ANDASSIGN
                                  | @Op = KTC_OPCODE_XORASSIGN
                                  | @Op = KTC_OPCODE_ORASSIGN
                                  ]
                                  [ not Right:: { ParensExpr / Expr:: } LiteralExpr ]
                                  [ Right.getTypeSize() > 0 ]
                                  [$leftSize := Left.getTypeSize()]
                                  [not Right::AnyExpr[$leftSize <= 8][getTypeName() = 'bool' | getTypeName() = '_Bool']]
                                  [ $leftSize > Right.getTypeSize() ]


- prompt: Find all instances where bSTR variable is assigned a non-BSTR value.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                    // BinaryExpr [ @Op = KTC_OPCODE_ASSIGN ]
                                  [ Left::* [ getTypeName() = 'BSTR' ] ]
                                  [ not Right::LiteralExpr [ getIntValue() = 0 ] ]
                                                  [ not Right.isBSTRCompatible() ]

-->pattern 2 :

                    // BinaryExpr [ @Op = KTC_OPCODE_ASSIGN ]
                                  [ Left::* [ getTypeName() = 'BSTR' ] ]
                                  [ Right.isPointerToChar() |
                                                    Right::* [ isPointerToWChar() ]
                                                             [ assembleString().length() != 0 ] ]


- prompt: Find all instances where unsigned value is compared against 0 within a macro.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                                    // BinaryExpr [ @Op = KTC_OPCODE_LT ]
                                                  [ comesFromMacro() ]
                                                  [ Left.isUnsigned() ]
                                                  [ Right.getIntValue() = 0 ]

-->pattern 2 :

                                    // BinaryExpr [ @Op = KTC_OPCODE_GT ]
                                                  [ comesFromMacro() ]
                                                  [ Right.isUnsigned() ]
                                                  [ Left.getIntValue() = 0 ]


- prompt: Find all instances where used API is unsafe like 'sprintf'.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'sprintfW' ]
                   [ $0 := 'sprintfW' ] [ $1 := 'sprintf_s' ]

-->pattern 2 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'sprintfA' ]
                   [ $0 := 'sprintfA' ] [ $1 := 'sprintf_s' ]

-->pattern 3 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'wsprintf' ]
                   [ $0 := 'wsprintf' ] [ $1 := 'sprintf_s' ]

-->pattern 4 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'wsprintfW' ]
                   [ $0 := 'wsprintfW' ] [ $1 := 'sprintf_s' ]

-->pattern 5 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'wsprintfA' ]
                   [ $0 := 'wsprintfA' ] [ $1 := 'sprintf_s' ]

-->pattern 6 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'sprintf' ]
                   [ $0 := 'sprintf' ] [ $1 := 'sprintf_s' ]

-->pattern 7 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'swprintf' ]
                   [ $0 := 'swprintf' ] [ $1 := 'swprintf_s' ]

-->pattern 8 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_stprintf' ]
                   [ $0 := '_stprintf' ] [ $1 := '_stprintf_s' ]

-->pattern 9 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'wvsprintf' ]
                   [ $0 := 'wvsprintf' ] [ $1 := 'StringCbVPrintf' ]

-->pattern 10 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'wvsprintfA' ]
                   [ $0 := 'wvsprintfA' ] [ $1 := 'StringCbVPrintfA' ]

-->pattern 11 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'wvsprintfW' ]
                   [ $0 := 'wvsprintfW' ] [ $1 := 'StringCbVPrintfW' ]

-->pattern 12 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'vsprintf' ]
                   [ $0 := 'vsprintf' ] [ $1 := 'vsprintf_s' ]

-->pattern 13 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_vstprintf' ]
                   [ $0 := '_vstprintf' ] [ $1 := '_vstprintf_s' ]

-->pattern 14 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'vswprintf' ]
                   [ $0 := 'vswprintf' ] [ $1 := 'vswprintf_s' ]


- prompt: Find all instances where illegal arithmetic operations with BSTR values is being performed.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                    // BinaryExpr [ @Op = KTC_OPCODE_ADDASSIGN | @Op = KTC_OPCODE_SUBASSIGN ]
                                  [ Left.getTypeName() = 'BSTR' ]

-->pattern 2 :

                    // BinaryExpr [ @Op = KTC_OPCODE_ASSIGN ]
                                  [ Left.getTypeName() = 'BSTR' ]
                                  [ Right::BinaryExpr [ @Op = KTC_OPCODE_ADD |
                                                        @Op = KTC_OPCODE_ADDASSIGN |
                                                        @Op = KTC_OPCODE_SUB |
                                                        @Op = KTC_OPCODE_SUBASSIGN ]
                                                      [ Left.getTypeName() = 'BSTR' |
                                                        Right.getTypeName() = 'BSTR' ] ]

-->pattern 3 :

                    // UnaryExpr [ @Op = KTC_OPCODE_PREINC |
                                   @Op = KTC_OPCODE_PREDEC |
                                   @Op = KTC_OPCODE_POSTINC |
                                   @Op = KTC_OPCODE_POSTDEC ]
                                 [ Expr.getTypeName() = 'BSTR' ]


- prompt: Find all instances where incorrect call to BSTR allocating function is being made.


-This is the pattern for the above prompt:

                    // CallExpr [ getName() = 'SysAllocString' | getName() = 'SysAllocStringLen' ]
                                [ $0 := getName() ]
                                [ Args[0]::* [ getTypeName() = 'BSTR' |
                                               getTypeName() = 'CComBSTR' ] ]


- prompt: Find all instances where a parameter gets hidden by local variable.


-This is the pattern for the above prompt:

                      // Decl [ Declarators[*]::AnyDeclarator [ $local := getName() ] ]
                              [ not ancestor::FuncDeclarator ]
                              [ ancestor::FuncBody
                                   [ parent::FuncDef / Declarator:: { AnyDeclarator / Declarator:: } FuncDeclarator / Params[*]::Decl /
                                        Declarators[*]::AnyDeclarator [ getName() = $local ]  |
                                     parent::MemberFunc / Declarator:: { AnyDeclarator / Declarator:: }  FuncDeclarator / Params[*]::Decl /
                                        Declarators[*]::AnyDeclarator [ getName() = $local ]
                                   ]
                                   [ $0 := parent.getName() ]
                                   [ $body := this() ] ]
                              [ not ancestor::ClassType / ancestor::FuncBody [ this() = $body ] ]
                              [ $1 := $local ]


- prompt: Find all instances where memory manipulation routine is applied to a non-POD object.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                    // CallExpr [ getName() = 'memset'
                                | getName() = 'bzero'
                                | getName() = 'memcpy'
                                | getName() = 'memccpy'
                                | getName() = 'mempcpy'
                                | getName() = '_memccpy'
                                | getName() = 'memcpy_s'
                                | getName() = 'memmove'
                                | getName() = 'memmove_s'
                                ]
                                [ getPointedType(Args[0]::*) ]
                                [ not getPointedType(Args[0]::*).isPODType() ]
                                [ $0 := getName() ]

-->pattern 2 :

                    // CallExpr [ getName() = 'bcopy' ]
                                [ getPointedType(Args[1]::*) ]
                                [ not getPointedType(Args[1]::*).isPODType() ]
                                [ $0 := getName() ]


- prompt: Find all instances where used API is unsafe for numeric conversion.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_itoa' ]
                   [ $0 := '_itoa' ] [ $1 := '_itoa_s' ]

-->pattern 2 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_itow' ]
                   [ $0 := '_itow' ] [ $1 := '_itow_s' ]

-->pattern 3 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_i64toa' ]
                   [ $0 := '_i64toa' ] [ $1 := '_i64toa_s' ]

-->pattern 4 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_i64tow' ]
                   [ $0 := '_i64tow' ] [ $1 := '_i64tow_s' ]

-->pattern 5 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_ui64toa' ]
                   [ $0 := '_ui64toa' ] [ $1 := '_ui64toa_s' ]

-->pattern 6 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_ui64tot' ]
                   [ $0 := '_ui64tot' ] [ $1 := '_ui64tot_s' ]

-->pattern 7 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_ui64tow' ]
                   [ $0 := '_ui64tow' ] [ $1 := '_ui64tow_s' ]

-->pattern 8 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_ultoa' ]
                   [ $0 := '_ultoa' ] [ $1 := '_ultoa_s' ]

-->pattern 9 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_ultot' ]
                   [ $0 := '_ultot' ] [ $1 := '_ultot_s' ]

-->pattern 10 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_ultow' ]
                   [ $0 := '_ultow' ] [ $1 := '_ultow_s' ]


- prompt: Find all instances where the 'then' and 'else' branches of a ternary operator are same.


-This is the pattern for the above prompt:

                    // ConditionalExpr [not Then.isFromMacro()] [not Else.isFromMacro()]
                                       [ $then := Then.pretty() ] [ $else := Else.pretty() ]
                                       [ $then = $else ] [ $then != ''] [ $then != ' ']


- prompt: Find all instances where length of non-BSTR string is being fetched using BSTR-related functions.


-This is the pattern for the above prompt:

                    // CallExpr [ getName() = 'SysStringLen' | getName() = 'SysStringByteLen' ]
                                [ $0 := getName() ]
                                [ Args[0]::* [ $name := getTypeName() ]
                                             [ $name != 'BSTR' ]
                                             [ $name != 'CComBSTR' ]
                                             [ $name != 'bstr_t' ]
                                             [ $name != '_bstr_t' ] ]


- prompt: Find all instances where there exists bad return type of main.


-This is the pattern for the above prompt:

                      // FuncDef [ getName() = 'main' ]
                                 [ not isClassMember() ]
                                 [ getReturnType().getInitialDefinedType().getTypeName() != 'int' ]


- prompt: Find all instances where incorrect call to BSTR freeing function is being made.


-This is the pattern for the above prompt:

                    // CallExpr [ getName() = 'SysFreeString' ]
                                [ Args[0]::* [ $name := getTypeName() ]
                                             [ $name != 'BSTR' ] ]


- prompt: Find all instances where used API can cause unsafe buffer copy operation.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'strcpy' ]
                   [ $0 := 'strcpy' ] [ $1 := 'strcpy_s' ]

-->pattern 2 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'strcpyA' ]
                   [ $0 := 'strcpyA' ] [ $1 := 'strcpy_s' ]

-->pattern 3 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'strcpyW' ]
                   [ $0 := 'strcpyW' ] [ $1 := 'strcpy_s' ]

-->pattern 4 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'wcscpy' ]
                   [ $0 := 'wcscpy' ] [ $1 := 'wcscpy_s' ]

-->pattern 5 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_tcscpy' ]
                   [ $0 := '_tcscpy' ] [ $1 := '_tcscpy_s' ]

-->pattern 6 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_mbscpy' ]
                   [ $0 := '_mbscpy' ] [ $1 := '_mbscpy_s' ]

-->pattern 7 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'StrCpy' ]
                   [ $0 := 'StrCpy' ] [ $1 := 'StringCchCopy' ]

-->pattern 8 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'StrCpyA' ]
                   [ $0 := 'StrCpyA' ] [ $1 := 'StringCchCopyA' ]

-->pattern 9 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'StrCpyW' ]
                   [ $0 := 'StrCpyW' ] [ $1 := 'StringCchCopyW' ]

-->pattern 10 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'lstrcpy' ]
                   [ $0 := 'lstrcpy' ] [ $1 := 'StringCchCopy' ]

-->pattern 11 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'lstrcpyA' ]
                   [ $0 := 'lstrcpyA' ] [ $1 := 'StringCchCopyA' ]

-->pattern 12 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'lstrcpyW' ]
                   [ $0 := 'lstrcpyW' ] [ $1 := 'StringCchCopyW' ]

-->pattern 13 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_tccpy' ]
                   [ $0 := '_tccpy' ] [ $1 := '_tccpy_s' ]

-->pattern 14 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_mbccpy' ]
                   [ $0 := '_mbccpy' ] [ $1 := '_mbccpy_s' ]

-->pattern 15 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_ftcscpy' ]
                   [ $0 := '_ftcscpy' ] [ $1 := '_tcscpy_s' ]

-->pattern 16 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'strncpy' ]
                   [ $0 := 'strncpy' ] [ $1 := 'strncpy_s' ]

-->pattern 17 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'wcsncpy' ]
                   [ $0 := 'wcsncpy' ] [ $1 := 'wcsncpy_s' ]

-->pattern 18 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_tcsncpy' ]
                   [ $0 := '_tcsncpy' ] [ $1 := '_tcsncpy_s' ]

-->pattern 19 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_mbsncpy' ]
                   [ $0 := '_mbsncpy' ] [ $1 := '_mbsncpy_s' ]

-->pattern 20 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_mbsnbcpy' ]
                   [ $0 := '_mbsnbcpy' ] [ $1 := '_mbsnbcpy_s' ]

-->pattern 21 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'StrCpyN' ]
                   [ $0 := 'StrCpyN' ] [ $1 := 'StringCchCopyN' ]

-->pattern 22 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'StrCpyNA' ]
                   [ $0 := 'StrCpyNA' ] [ $1 := 'StringCchCopyNA' ]

-->pattern 23 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'StrCpyNW' ]
                   [ $0 := 'StrCpyNW' ] [ $1 := 'StringCchCopyNW' ]

-->pattern 24 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'StrNCpy' ]
                   [ $0 := 'StrNCpy' ] [ $1 := 'StringCchCopyN' ]

-->pattern 25 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'StrNCpyA' ]
                   [ $0 := 'StrNCpyA' ] [ $1 := 'StringCchCopyNA' ]

-->pattern 26 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'StrNCpyW' ]
                   [ $0 := 'StrNCpyW' ] [ $1 := 'StringCchCopyNW' ]

-->pattern 27 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'strcpynA' ]
                   [ $0 := 'strcpynA' ] [ $1 := 'StringCchCopyNA' ]

-->pattern 28 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'lstrcpyn' ]
                   [ $0 := 'lstrcpyn' ] [ $1 := 'StringCchCopyN' ]

-->pattern 29 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'lstrcpynA' ]
                   [ $0 := 'lstrcpynA' ] [ $1 := 'StringCchCopyNA' ]

-->pattern 30 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'lstrcpynW' ]
                   [ $0 := 'lstrcpynW' ] [ $1 := 'StringCchCopyNW' ]

-->pattern 31 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'memcpy' ]
                   [ $0 := 'memcpy' ] [ $1 := 'memcpy_s' ]

-->pattern 32 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'RtlCopyMemory' ]
                   [ $0 := 'RtlCopyMemory' ] [ $1 := 'memcpy_s' ]

-->pattern 33 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'CopyMemory' ]
                   [ $0 := 'CopyMemory' ] [ $1 := 'memcpy_s' ]

-->pattern 34 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'wmemcpy' ]
                   [ $0 := 'wmemcpy' ] [ $1 := 'wmemcpy_s' ]


- prompt: Find all instances where a 'char' expression compared with EOF constant.


-This is the pattern for the above prompt:

                      // BinaryExpr [ @Op = KTC_OPCODE_EQ | @Op = KTC_OPCODE_NE ]
                                    [ Left.getBaseIntegralTypeName() = 'char' ]
                                    [ Right:: { ParensExpr / Expr:: } AnyExpr [ pretty() = 'EOF' ] ]


- prompt: Find all instances where va_arg is called with an argument of the incorrect type.


-This is the pattern for the above prompt:

                    // CastExpr
                                [ Expr::CallExpr [ Func.getName() = '__kw_va_arg'
                                                 | Func.getName() = '__builtin_va_arg' ]
                                ]
                                [ Type::TypeId [ $typename := getInitialDefinedType().getTypeName() ]
                                               [ $typename = 'float'
                                               | $typename = 'char'
                                               | $typename = 'signed char'
                                               | $typename = 'unsigned char'
                                               | $typename = 'short int'
                                               | $typename = 'unsigned short int' ]
                                               [ $0 :=$typename ]
                                ]


- prompt: Find all instances where used API is unsafe for stream reading.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'gets' ]
                   [ $0 := 'gets' ] [ $1 := 'gets_s' ]

-->pattern 2 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_getts' ]
                   [ $0 := '_getts' ] [ $1 := '_getts_s' ]

-->pattern 3 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_getws' ]
                   [ $0 := '_getws' ] [ $1 := '_getws_s' ]


- prompt: Find all instances where used API can cause unsafe string concatenation operation.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'strcat' ]
                   [ $0 := 'strcat' ] [ $1 := 'strcat_s' ]

-->pattern 2 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'strcatA' ]
                   [ $0 := 'strcatA' ] [ $1 := 'strcat_s' ]

-->pattern 3 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'strcatW' ]
                   [ $0 := 'strcatW' ] [ $1 := 'strcat_s' ]

-->pattern 4 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'wcscat' ]
                   [ $0 := 'wcscat' ] [ $1 := 'wcscat_s' ]

-->pattern 5 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_tcscat' ]
                   [ $0 := '_tcscat' ] [ $1 := '_tcscat_s' ]

-->pattern 6 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_mbscat' ]
                   [ $0 := '_mbscat' ] [ $1 := '_mbscat_s' ]

-->pattern 7 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'StrCat' ]
                   [ $0 := 'StrCat' ] [ $1 := 'StringCchCat' ]

-->pattern 8 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'StrCatA' ]
                   [ $0 := 'StrCatA' ] [ $1 := 'StringCchCatA' ]

-->pattern 9 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'StrCatW' ]
                   [ $0 := 'StrCatW' ] [ $1 := 'StringCchCatW' ]

-->pattern 10 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'lstrcat' ]
                   [ $0 := 'lstrcat' ] [ $1 := 'StringCchCat' ]

-->pattern 11 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'lstrcatA' ]
                   [ $0 := 'lstrcatA' ] [ $1 := 'StringCchCatA' ]

-->pattern 12 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'lstrcatW' ]
                   [ $0 := 'lstrcatW' ] [ $1 := 'StringCchCatW' ]

-->pattern 13 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'StrCatBuff' ]
                   [ $0 := 'StrCatBuff' ] [ $1 := 'StringCchCat' ]

-->pattern 14 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'StrCatBuffA' ]
                   [ $0 := 'StrCatBuffA' ] [ $1 := 'StringCchCatA' ]

-->pattern 15 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'StrCatBuffW' ]
                   [ $0 := 'StrCatBuffW' ] [ $1 := 'StringCchCatW' ]

-->pattern 16 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'StrCatChainW' ]
                   [ $0 := 'StrCatChainW' ] [ $1 := 'StringCbCatEx' ]

-->pattern 17 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'strncat' ]
                   [ $0 := 'strncat' ] [ $1 := 'strncat_s' ]

-->pattern 18 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'wcsncat' ]
                   [ $0 := 'wcsncat' ] [ $1 := 'wcsncat_s' ]

-->pattern 19 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_tcsncat' ]
                   [ $0 := '_tcsncat' ] [ $1 := '_tcsncat_s' ]

-->pattern 20 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_mbsncat' ]
                   [ $0 := '_mbsncat' ] [ $1 := '_mbsncat_s' ]

-->pattern 21 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_mbsnbcat' ]
                   [ $0 := '_mbsnbcat' ] [ $1 := '_mbsnbcat_s' ]

-->pattern 22 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'StrCatN' ]
                   [ $0 := 'StrCatN' ] [ $1 := 'StringCchCatN' ]

-->pattern 23 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'StrCatNA' ]
                   [ $0 := 'StrCatNA' ] [ $1 := 'StringCchCatNA' ]

-->pattern 24 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'StrCatNW' ]
                   [ $0 := 'StrCatNW' ] [ $1 := 'StringCchCatNW' ]

-->pattern 25 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'StrNCat' ]
                   [ $0 := 'StrNCat' ] [ $1 := 'StringCchCatN' ]

-->pattern 26 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'StrNCatA' ]
                   [ $0 := 'StrNCatA' ] [ $1 := 'StringCchCatNA' ]

-->pattern 27 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'StrNCatW' ]
                   [ $0 := 'StrNCatW' ] [ $1 := 'StringCchCatNW' ]

-->pattern 28 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'lstrncat' ]
                   [ $0 := 'lstrncat' ] [ $1 := 'StringCchCatN' ]

-->pattern 29 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'lstrcatnA' ]
                   [ $0 := 'lstrcatnA' ] [ $1 := 'StringCchCatNA' ]

-->pattern 30 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'lstrcatnW' ]
                   [ $0 := 'lstrcatnW' ] [ $1 := 'StringCchCatNW' ]

-->pattern 31 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'lstrcatn' ]
                   [ $0 := 'lstrcatn' ] [ $1 := 'StringCchCatN' ]


- prompt: Find all instances where used API is unsafe like 'IsBad-type' function.


-This is the pattern for the above prompt:

                // CallExpr/Func::IdExpr
                        [ $name := getName() ]
                        [ $name = 'IsBadWritePtr'
                        | $name = 'IsBadHugeWritePtr'
                        | $name = 'IsBadReadPtr'
                        | $name = 'IsBadHugeReadPtr'
                        | $name = 'IsBadCodePtr'
                        | $name = 'IsBadStringPtr' ]
                        [ $0 := getName() ]


- prompt: Find all instances where used API is unsafe 'sprintf' function.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'wnsprintf' ]
                   [ $0 := 'wnsprintf' ] [ $1 := 'StringCchPrintf' ]

-->pattern 2 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'wnsprintfA' ]
                   [ $0 := 'wnsprintfA' ] [ $1 := 'StringCchPrintfA' ]

-->pattern 3 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'wnsprintfW' ]
                   [ $0 := 'wnsprintfW' ] [ $1 := 'StringCchPrintfW' ]

-->pattern 4 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_snwprintf' ]
                   [ $0 := '_snwprintf' ] [ $1 := '_snwprintf_s' ]

-->pattern 5 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'snprintf' ]
                   [ $0 := 'snprintf' ] [ $1 := '_snprintf_s' ]

-->pattern 6 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'sntprintf' ]
                   [ $0 := 'sntprintf' ] [ $1 := '_sntprintf_s' ]

-->pattern 7 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_vsnprintf' ]
                   [ $0 := '_vsnprintf' ] [ $1 := '_vsnprintf_s' ]

-->pattern 8 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'vsnprintf' ]
                   [ $0 := 'vsnprintf' ] [ $1 := 'vsnprintf_s' ]

-->pattern 9 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_vsnwprintf' ]
                   [ $0 := '_vsnwprintf' ] [ $1 := '_vsnwprintf_s' ]

-->pattern 10 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_vsntprintf' ]
                   [ $0 := '_vsntprintf' ] [ $1 := '_vsntprintf_s' ]

-->pattern 11 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'wvnsprintf' ]
                   [ $0 := 'wvnsprintf' ] [ $1 := 'StringCchVPrintf' ]

-->pattern 12 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'wvnsprintfA' ]
                   [ $0 := 'wvnsprintfA' ] [ $1 := 'StringCchVPrintfA' ]

-->pattern 13 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'wvnsprintfW' ]
                   [ $0 := 'wvnsprintfW' ] [ $1 := 'StringCchVPrintfW' ]

-->pattern 14 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_snprintf' ]
                   [ $0 := '_snprintf' ] [ $1 := '_snprintf_s' ]

-->pattern 15 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_sntprintf' ]
                   [ $0 := '_sntprintf' ] [ $1 := '_sntprintf_s' ]


- prompt: Find all instances where an incompatible type is used with a network macro such as 'ntohl'.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                    //CallExpr [ getName() = 'htons' | getName() = 'ntohs' ]
                               [ Args[0]::AnyExpr [ getTypeSize() != 2 ] ]

-->pattern 2 :

                    //CallExpr [ getName() = 'htonl' | getName() = 'ntohl' ]
                               [ Args[0]::AnyExpr [ getTypeSize() != 4 ] ]


- prompt: Find all instances where used API is unsafe for string tokenization.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'strtok' ]
                   [ $0 := 'strtok' ] [ $1 := 'strtok_s' ]

-->pattern 2 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_tcstok' ]
                   [ $0 := '_tcstok' ] [ $1 := '_tcstok_s' ]

-->pattern 3 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'wcstok' ]
                   [ $0 := 'wcstok' ] [ $1 := 'wcstok_s' ]

-->pattern 4 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_mbstok' ]
                   [ $0 := '_mbstok' ] [ $1 := '_mbstok_s' ]


- prompt: Find all instances where 'Gdo' controlling expression is constant.


-This is the pattern for the above prompt:

                      // DoStmt [ not comesFromMacro() ]
                                [ not Cond::LiteralExpr [ @Value=1 | @Value=0 ] ]
                                [ not Cond::BoolLiteralExpr [ @Value=KTC_BOOLVALUE_TRUE | @Value=KTC_BOOLVALUE_FALSE ] ]
                                / Cond::* [ isConstant() ]
                                          [ $pretty_cond := pretty() ]
                                          [ $pretty_cond != 'TRUE' ] [ $pretty_cond != 'True' ] [ $pretty_cond != 'true' ]
                                          [ $pretty_cond != 'FALSE' ] [ $pretty_cond != 'False' ] [ $pretty_cond != 'false' ]
                                          [ not descendant-or-self::SizeOfExpr ]
                                          [ not descendant-or-self::UnaryExpr [ @Op = KTC_OPCODE_SIZEOF ] ]


- prompt: Find all instances where there exists potential process injection vector.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                    // CallExpr
                       [ $name := getName() ]
                       [ $name = 'CreateProcessA'
                       | $name = 'CreateProcessW'
                       | $name = 'WinExecA'
                       | $name = 'WinExecW'
                       | $name = 'LoadModuleA'
                       | $name = 'LoadModuleW'
                       | $name = '_execlp'
                       | $name = '_wexeclp'
                       | $name = '_execlpe'
                       | $name = '_wexeclpe'
                       | $name = '_execvp'
                       | $name = '_wexecvp'
                       | $name = '_execvpe'
                       | $name = '_wexecvpe' ]
                       [ Args[0]::StringLiteralExpr
                         [ not @Value.starts-with('\\\\') ]
                         [ not @Value.contains(':\\') ] ]

-->pattern 2 :

                    // CallExpr
                       [ getName() = 'CreateProcessA' | getName() = 'CreateProcessW' ]
                       [ Args[0]::AnyExpr
                         [ getIntValue() = 0 ] ]
                       [ Args[1]::StringLiteralExpr
                         [ not @Value.starts-with('\\\\') ]
                         [ not @Value.contains(':\\') ] ]

-->pattern 3 :

                    // CallExpr
                       [ $name := getName() ]
                       [ $name = '_spawnlp'
                       | $name = '_wspawnlp'
                       | $name = '_spawnvp'
                       | $name = '_wspawnvp'
                       | $name = '_spawnlpe'
                       | $name = '_wspawnlpe'
                       | $name = '_spawnvpe'
                       | $name = '_wspawnvpe' ]
                       [ Args[1]::StringLiteralExpr
                         [ not @Value.starts-with('\\\\') ]
                         [ not @Value.contains(':\\') ] ]

-->pattern 4 :

                    // CallExpr
                       [ getName() = 'ShellExecuteA' | getName() = 'ShellExecuteW' ]
                       [ Args[2]::StringLiteralExpr
                         [ not @Value.starts-with('\\\\') ]
                         [ not @Value.contains(':\\') ] ]
                       [ Args[4]::AnyExpr
                         [ getIntValue() = 0 ] ]

-->pattern 5 :

                    // CallExpr
                       [ getName() = 'ShellExecuteA' | getName() ='ShellExecuteW' ]
                       [ Args[2]::StringLiteralExpr
                         [ not @Value.starts-with('\\\\') ]
                         [ not @Value.contains(':\\') ] ]
                       [ Args[4]::StringLiteralExpr
                         [ not @Value.starts-with('\\\\') ]
                         [ not @Value.contains(':\\') ]]


- prompt: Find all instances where used API is unsafe for path name manipulation.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'makepath' ]
                   [ $0 := 'makepath' ] [ $1 := 'makepath_s' ]

-->pattern 2 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_tmakepath' ]
                   [ $0 := '_tmakepath' ] [ $1 := '_tmakepath_s' ]

-->pattern 3 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_makepath' ]
                   [ $0 := '_makepath' ] [ $1 := '_makepath_s' ]

-->pattern 4 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_wmakepath' ]
                   [ $0 := '_wmakepath' ] [ $1 := '_wmakepath_s' ]

-->pattern 5 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_splitpath' ]
                   [ $0 := '_splitpath' ] [ $1 := '_splitpath_s' ]

-->pattern 6 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_tsplitpath' ]
                   [ $0 := '_tsplitpath' ] [ $1 := '_tsplitpath_s' ]

-->pattern 7 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_wsplitpath' ]
                   [ $0 := '_wsplitpath' ] [ $1 := '_wsplitpath_s' ]


- prompt: Find all instances where used API unsafe like 'scanf' function.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'scanf' ]
                   [ $0 := 'scanf' ] [ $1 := 'scanf_s' ]

-->pattern 2 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'wscanf' ]
                   [ $0 := 'wscanf' ] [ $1 := 'wscanf_s' ]

-->pattern 3 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_tscanf' ]
                   [ $0 := '_tscanf' ] [ $1 := '_tscanf_s' ]

-->pattern 4 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'sscanf' ]
                   [ $0 := 'sscanf' ] [ $1 := 'sscanf_s' ]

-->pattern 5 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'swscanf' ]
                   [ $0 := 'swscanf' ] [ $1 := 'swscanf_s' ]

-->pattern 6 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_stscanf' ]
                   [ $0 := '_stscanf' ] [ $1 := '_stscanf_s' ]

-->pattern 7 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'snscanf' ]
                   [ $0 := 'snscanf' ] [ $1 := 'snscanf_s' ]

-->pattern 8 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'snwscanf' ]
                   [ $0 := 'snwscanf' ] [ $1 := '_snwscanf_s' ]

-->pattern 9 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_sntscanf' ]
                   [ $0 := '_sntscanf' ] [ $1 := '_sntscanf_s' ]


- prompt: Find all instances where anachronistic 'implicit int' is used. This KAST expression should only check programs written in C language and not in C++ language.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                      // FuncDef [ isCLanguage() ]
                                 [ not DeclSpecs[*]::AnyTypeOf ]
                                 [ not DeclSpecs[*]::ReservedTypeSpec ]
                                 [ not DeclSpecs[*]::ClassType ]
                                 [ not DeclSpecs[*]::EnumType ]
                                 [ not DeclSpecs[*]::TypeName ]
                                 [ not DeclSpecs[*]::AutoType ]
                                 [ not Declarator.isConstructor() ]
                                 [ not Declarator.isDestructor() ]
                                 [ not Declarator.isConvFunc() ]

-->pattern 2 :

                      // Decl [ isCLanguage() ]
                              [ not Declarators::Null ]
                              [ not DeclSpecs[*]::AnyTypeOf ]
                              [ not DeclSpecs[*]::ReservedTypeSpec ]
                              [ not DeclSpecs[*]::ClassType ]
                              [ not DeclSpecs[*]::EnumType ]
                              [ not DeclSpecs[*]::TypeName ]
                              [ not DeclSpecs[*]::AutoType ]

-->pattern 3 :

                      // MemberDecl [ isCLanguage() ]
                                    [ not Declarators::Null ]
                                    [ not DeclSpecs[*]::AnyTypeOf ]
                                    [ not DeclSpecs[*]::ReservedTypeSpec ]
                                    [ not DeclSpecs[*]::ClassType ]
                                    [ not DeclSpecs[*]::EnumType ]
                                    [ not DeclSpecs[*]::TypeName ]
                                    [ not DeclSpecs[*]::AutoType ]
                                    [ not Declarators[*]::AnyDeclarator [ isConstructor()
                                                                        | isDestructor()
                                                                        | isConvFunc() ]
                                    ]


- prompt: Find all instances where used API is unsafe for OEM character page conversion.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'CharToOem' ]
                   [ $0 := 'CharToOem' ] [ $1 := 'WideCharToMultiByte' ]

-->pattern 2 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'CharToOemA' ]
                   [ $0 := 'CharToOemA' ] [ $1 := 'WideCharToMultiByte' ]

-->pattern 3 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'CharToOemW' ]
                   [ $0 := 'CharToOemW' ] [ $1 := 'WideCharToMultiByte' ]

-->pattern 4 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'OemToChar' ]
                   [ $0 := 'OemToChar' ] [ $1 := 'WideCharToMultiByte' ]

-->pattern 5 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'OemToCharA' ]
                   [ $0 := 'OemToCharA' ] [ $1 := 'WideCharToMultiByte' ]

-->pattern 6 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'OemToCharW' ]
                   [ $0 := 'OemToCharW' ] [ $1 := 'WideCharToMultiByte' ]

-->pattern 7 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'CharToOemBuffA' ]
                   [ $0 := 'CharToOemBuffA' ] [ $1 := 'WideCharToMultiByte' ]

-->pattern 8 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'CharToOemBuffW' ]
                   [ $0 := 'CharToOemBuffW' ] [ $1 := 'WideCharToMultiByte' ]


- prompt: Find all instances where used API is unsafe for stack allocation operations.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'alloca' ]
                   [ $0 := 'alloca' ] [ $1 := 'SafeAllocA' ]

-->pattern 2 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_alloca' ]
                   [ $0 := '_alloca' ] [ $1 := 'SafeAllocA' ]


- prompt: Find all instances where used API is unsafe for string length operation.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'strlen' ]
                   [ $0 := 'strlen' ] [ $1 := 'strnlen_s' ]

-->pattern 2 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'wcslen' ]
                   [ $0 := 'wcslen' ] [ $1 := 'wcslen_s' ]

-->pattern 3 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_mbslen' ]
                   [ $0 := '_mbslen' ] [ $1 := '_mbslen_s' ]

-->pattern 4 :

                // CallExpr/Func::IdExpr
                   [ getName() = '_mbstrlen' ]
                   [ $0 := '_mbstrlen' ] [ $1 := '_mbslen_s' ]

-->pattern 5 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'StrLen' ]
                   [ $0 := 'StrLen' ] [ $1 := 'StringCchLength' ]

-->pattern 6 :

                // CallExpr/Func::IdExpr
                   [ getName() = 'lstrlen' ]
                   [ $0 := 'lstrlen' ] [ $1 := 'StringCchLength' ]


- prompt: Find all instances where boolean expressions are used directly as bitwise operator arguments.


-This is the pattern for the above prompt:

                    // BinaryExpr [@Op = KTC_OPCODE_BITAND | @Op = KTC_OPCODE_BITOR | @Op = KTC_OPCODE_BITXOR]
                                  [not Left.isFromMacro()] [not Right.isFromMacro()]
                                  [ Left.isBoolean() | Right.isBoolean() ]



- prompt: Find all instances where 'Gwhile' controlling expression is constant.


-This is the pattern for the above prompt:

                      // WhileStmt [ not comesFromMacro() ]
                                   [ not Cond::LiteralExpr [ @Value=1 ] ]
                                   [ not Cond::BoolLiteralExpr [ @Value=KTC_BOOLVALUE_TRUE ] ]
                                   / Cond::* [ isConstant() ]
                                             [ $pretty_cond := pretty() ]
                                             [ $pretty_cond != 'TRUE' ]
                                             [ $pretty_cond != 'True' ]
                                             [ $pretty_cond != 'true' ]
                                             [ not descendant-or-self::SizeOfExpr ]
                                             [ not descendant-or-self::UnaryExpr [ @Op = KTC_OPCODE_SIZEOF ] ]


- prompt: Find all instances where there exists potential DLL-preload hijack vector.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                    // CallExpr
                       [ $name := getName() ]
                       [ $name = 'LoadLibraryA'
                       | $name = 'LoadLibraryW'
                       | $name = 'LoadLibraryExA'
                       | $name = 'LoadLibraryExW' ]
                       [ Args[0]::StringLiteralExpr
                         [ not @Value.contains('\\') ]
                         [ not @Value.isKnownLibrary() ] ]

-->pattern 2 :

                    // CallExpr
                       [ $name := getName() ]
                       [ $name = 'LoadLibraryA'
                       | $name = 'LoadLibraryW'
                       | $name = 'LoadLibraryExA'
                       | $name = 'LoadLibraryExW' ]
                       [ Args[0]::AnyExpr
                         [ getIntValue() = 0 ] ]


- prompt: Find all instances where SearchPath is used to find DLLs.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                    // CallExpr
                       [ getName() = 'SearchPathA' | getName() = 'SearchPathW' ]
                       [ Args[1]::StringLiteralExpr
                         [ @Value.ends-with-nocase('.dll') ] ]

-->pattern 2 :

                    // CallExpr
                       [ getName() = 'SearchPathA' | getName() = 'SearchPathW' ]
                       [ Args[2]::StringLiteralExpr
                         [ @Value.ends-with-nocase('.dll') ] ]


- prompt: Find all instances where 'Gpacked' attribute is ignored in typedef.


-This is the pattern for the above prompt:

                      // Decl [ DeclSpecs[*]::ClassType [ MemberDecls::Null ] ]
                              [ DeclSpecs[*]::StorageClass [ @Spec = KTC_STORAGECLASS_TYPEDEF ] ]
                              [ DeclSpecs[*]::AttributeDeclSpec /
                                   AttributeSpec::AttributeSpec /
                                       Attributes[*]::Attribute [ @Name = KTC_ATTRIBUTE_PACKED ] ]


- prompt: Find all instances where implicit conversion is used in an arithmetic operation.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                    // Decl
                       [DeclSpecs[*]::BuiltinType [@Spec=KTC_BUILTINTYPE_FLOAT | @Spec=KTC_BUILTINTYPE_DOUBLE]]
                       [Declarators[*]::InitializedDeclarator/Init::CopyInitializer/Expr:: {ParensExpr / Expr::}  BinaryExpr
                           [not isFloatPoint()]
                           [@Op = KTC_OPCODE_DIV | @Op = KTC_OPCODE_MUL]
                           [Left.getInitialDefinedType().isIntegral()]
                           [Right.getInitialDefinedType().isIntegral()]
                       ]

-->pattern 2 :

                    // BinaryExpr
                       [ @Op = KTC_OPCODE_ASSIGN
                       | @Op = KTC_OPCODE_ADDASSIGN
                       | @Op = KTC_OPCODE_SUBASSIGN
                       | @Op = KTC_OPCODE_DIVASSIGN
                       | @Op = KTC_OPCODE_MULASSIGN]
                       [getInitialDefinedType().getTypeName() = 'float'
                       |
                       getInitialDefinedType().getTypeName() = 'double'][not isOverloaded()]
                       [   (Left:: {ParensExpr/Expr::} BinaryExpr
                           [@Op = KTC_OPCODE_DIV | @Op = KTC_OPCODE_MUL]
                           [Left.getInitialDefinedType().isIntegral()]
                           [Right.getInitialDefinedType().isIntegral()])
                       |
                           (Right:: {ParensExpr/Expr::} BinaryExpr
                           [@Op = KTC_OPCODE_DIV | @Op = KTC_OPCODE_MUL]
                           [Left.getInitialDefinedType().isIntegral()]
                           [Right.getInitialDefinedType().isIntegral()])
                       ]


- prompt: Find all instances where exception object passed by value is too large.


-This is the pattern for the above prompt:

                    // Handler / Exception::Exception [ Declarator::AnyDeclarator
                                                          [ $type := getInitialDefinedType() ]
                                                          [ not $type.isArray() ]
                                                          [ not $type.isPointer() ]
                                                          [ not $type.isReference() ]
                                                          [ $type.getTypeSize() > 64 ]
                                                          [ $0 := getName() ]
                                                      ]


- prompt: Find all instances where an unsigned value is compared against 0.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                                    // BinaryExpr [ @Op = KTC_OPCODE_LT ]
                                                  [ not comesFromMacro() ]
                                                  [ Left.isUnsigned() ]
                                                  [ Right.getIntValue() = 0 ]

-->pattern 2 :

                                    // BinaryExpr [ @Op = KTC_OPCODE_GT ]
                                                  [ not comesFromMacro() ]
                                                  [ Right.isUnsigned() ]
                                                  [ Left.getIntValue() = 0 ]


- prompt: Find all instances where 'Gswitch' selector expression is constant.


-This is the pattern for the above prompt:

                      // SwitchStmt [ not comesFromMacro() ]
                                    / Cond::* [ isConstant() ]
                                              [ not descendant-or-self::SizeOfExpr ]
                                              [ not descendant-or-self::UnaryExpr [ @Op = KTC_OPCODE_SIZEOF ] ]


- prompt: Find all instances where delete expression is used for an object of a class with virtual methods and no virtual destructor.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                                   // DeleteExpr [ $pointed := Expr.getPointedType() ]
                                                 [ $pointed.hasVirtualMethods() ]
                                                 [ $method := getSemanticInfo(ancestor::FuncDef) ]
                                                 [ $method.getParent() != $pointed |
                                                   not $method.isVirtual() ]
                                                 [ $destructor := $pointed.getDestructor() ]
                                                 [ $destructor.isPublic() ]
                                                 [ not $destructor.isVirtual() ]
                                                 [ $0 := $pointed.getName() ]

-->pattern 2 :

                                   // DeleteExpr [ $pointed := Expr.getPointedType() ]
                                                 [ $pointed.hasVirtualMethods() ]
                                                 [ $method := getSemanticInfo(ancestor::MemberFunc) ]
                                                 [ $method.getParent() != $pointed |
                                                   not $method.isVirtual() ]
                                                 [ $destructor := $pointed.getDestructor() ]
                                                 [ $destructor.isPublic() ]
                                                 [ not $destructor.isVirtual() ]
                                                 [ $0 := $pointed.getName() ]


- prompt: Find all instances where unsigned value is compared against 0.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                                    // BinaryExpr [ @Op = KTC_OPCODE_GE ]
                                                  [ not comesFromMacro() ]
                                                  [ Left.isUnsigned() ]
                                                  [ Right.getIntValue() = 0 ]

-->pattern 2 :

                                    // BinaryExpr [ @Op = KTC_OPCODE_LE ]
                                                  [ not comesFromMacro() ]
                                                  [ Right.isUnsigned() ]
                                                  [ Left.getIntValue() = 0 ]


- prompt: Find all instances where an unsigned value is compared against 0 within a macro.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                                    // BinaryExpr [ @Op = KTC_OPCODE_GE ]
                                                  [ comesFromMacro() ]
                                                  [ Left.isUnsigned() ]
                                                  [ Right.getIntValue() = 0 ]

-->pattern 2 :

                                    // BinaryExpr [ @Op = KTC_OPCODE_LE ]
                                                  [ comesFromMacro() ]
                                                  [ Right.isUnsigned() ]
                                                  [ Left.getIntValue() = 0 ]


- prompt: Find all instances where a 'bool' type is assigned a value larger than 1 byte.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                    // BinaryExpr [ @Op = KTC_OPCODE_ASSIGN ]
                                  [ Left::AnyExpr [ isBoolean() ] ]
                                  [ Right::AnyExpr [ $value := getIntValue() ]
                                                   [ $value < 0 | $value > 127 ] ]

-->pattern 2 :

                    // BinaryExpr [ @Op = KTC_OPCODE_ASSIGN ]
                                  [ Left::AnyExpr [ isBoolean() ] ]
                                  [ not Right::AnyExpr [ $hidden := getIntValue() ] ]
                                  [ Right::AnyExpr [ getTypeSize() > 1 ] ]


- prompt: Find all instances where a boolean is incremented or decremented.


-This is the pattern for the above prompt:

                       // UnaryExpr [ @Op = KTC_OPCODE_PREINC |
                                      @Op = KTC_OPCODE_POSTINC |
                                      @Op = KTC_OPCODE_PREDEC |
                                      @Op = KTC_OPCODE_POSTDEC ]
                                    [ Expr.getTypeName() = 'bool' ]


- prompt: Find all instances where a variable is assigned to self.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                                    // BinaryExpr [ @Op = KTC_OPCODE_ASSIGN ]
                                                  [ isSameExpression(Left, Right) ]
                                                  [ $0 := Right.pretty() ]

-->pattern 2 :

                                    // MemberInitializer [ Name.isVariable() ]
                                                         [ isSameExpression(Name, Args[0]::*) ]
                                                         [ $0 := Name.getName() ]

-->pattern 3 :

                                    // InitializedDeclarator [ isVariable() ]
                                                             [ $info := getSemanticInfo() ]
                                                             [ Init::CopyInitializer [ Expr.getSemanticInfo() = $info ] ]
                                                             [ $0 := $info.getName() ]


- prompt: Find all instances where mismatch of 'const' qualifiers exists.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                    // MemberDecl / Declarators[0]::AnyDeclarator [ $isconst := isConst() ]
                                                                  [ $rettype := getReturnType() ]
                                                                  [ $rettype != 0 ]
                                                                  [ $ovrd := getOverridenMethod() ]
                                                                  [ $ovrd != 0 ]
                                                                  [ $ovrd.isVirtual() ]
                                                                  [ $rettype = $ovrd.getReturnType() ]
                                                                  [ $ovrd.isConst() != $isconst ]
                                                                  [ $0 := $ovrd.getName() ]

-->pattern 2 :

                    // MemberFunc [ $isconst := isConst() ]
                                  [ $rettype := getReturnType() ]
                                  [ $rettype != 0 ]
                                  [ $ovrd := getOverridenMethod() ]
                                  [ $ovrd != 0 ]
                                  [ $ovrd.isVirtual() ]
                                  [ $rettype = $ovrd.getReturnType() ]
                                  [ $ovrd.isConst() != $isconst ]
                                  [ $0 := $ovrd.getName() ]


- prompt: Find all instances where function address is directly compared against 0.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                                    // BinaryExpr [ @Op=KTC_OPCODE_EQ | @Op=KTC_OPCODE_NE ]
                                                  [ Left.isFunction() ]
                                                  [ not Left.isFromMacroArg() ]
                                                  [ not Left.isWeak() ]
                                                  [ Right.getIntValue() = 0 ]

-->pattern 2 :

                                    // BinaryExpr [ @Op=KTC_OPCODE_EQ | @Op=KTC_OPCODE_NE ]
                                                  [ Right.isFunction() ]
                                                  [ not Right.isFromMacroArg() ]
                                                  [ not Right.isWeak() ]
                                                  [ Left.getIntValue() = 0 ]


- prompt: Find all instances where class has virtual functions inherited from a base class, but its destructor is not virtual and not empty.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                                   // FuncDef [ isDestructor() ]
                                              [ isPublic() ]
                                              [ not isVirtual() ]
                                              [ FuncBody::FuncBody / Stmt::CompoundStmt / Stmts[*]::* ]
                                              [ $class := getParent() ]
                                              [ $class.hasInheritedVirtualMethods() ]
                                              [ $0 := $class.getName() ]

-->pattern 2 :

                                   // MemberFunc [ isDestructor() ]
                                                 [ isPublic() ]
                                                 [ not isVirtual() ]
                                                 [ FuncBody::FuncBody / Stmt::CompoundStmt / Stmts[*]::* ]
                                                 [ $class := getParent() ]
                                                 [ $class.hasInheritedVirtualMethods() ]
                                                 [ $0 := $class.getName() ]


- prompt: Find all instances where delete expression is used with an object of type pointer to void.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                // DeleteExpr [ not starts-with(pretty(), 'delete [') ] / Expr::IdExpr
                    [ $typeName := getTypeName(getInitialDefinedType(getPointedType())) ]
                    [ $typeName = 'void' ]
                    [ $0 := getName() ] [ $1 := 'void' ] [ $2 := 'delete' ]

-->pattern 2 :

                // DeleteExpr [ starts-with(pretty(), 'delete [') ] / Expr::IdExpr
                    [ $typeName := getTypeName(getInitialDefinedType(getPointedType())) ]
                    [ $typeName = 'void' | $typeName = 'void*' ]
                    [ $0 := getName() ] [ $1 := $typeName ] [ $2 := 'delete []' ]


- prompt: Find all instances where there exists empty label statement.


-This is the pattern for the above prompt:

                      // LabeledStmt [ Stmt::Null ]


- prompt: Find all instances where the typedef name is missing.


-This is the pattern for the above prompt:

                       // Decl [ DeclSpecs[*]::StorageClass [ @Spec = KTC_STORAGECLASS_TYPEDEF ] ]
                               [ Declarators::Null ]



- prompt: Find all instances where controlling condition in conditional expression is constant.


-This is the pattern for the above prompt:

                      // ConditionalExpr [ not comesFromMacro() ]
                                         / Cond::* [ isConstant() ]
                                                   [ not descendant-or-self::SizeOfExpr ]
                                                   [ not descendant-or-self::UnaryExpr [ @Op = KTC_OPCODE_SIZEOF ] ]


- prompt: Find all instances where one bit field is signed.


-This is the pattern for the above prompt:

                      // MemberDecl [ Declarators[*]::BitFieldDeclarator [ Bits::LiteralExpr [ getIntValue() = 1 ] ]
                                                                         [ $0 := getName() ]
                                                                         [ Declarator::AnyDeclarator.isSigned() ] ]


- prompt: Find all instances where 'Ginline' used with non-function.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                      // Decl [ DeclSpecs[*]::FuncSpec [ @Spec = KTC_FUNCSPECIFIER_INLINE ] ]
                              [ not Declarators[*]::AnyDeclarator [ isFunction() |
                                                                    isFunctionTemplate() |
                                                                    isFunctionInstantiation() |
                                                                    isFunctionSpecialization()] ]

-->pattern 2 :

                     // MemberDecl [ DeclSpecs[*]::FuncSpec [ @Spec = KTC_FUNCSPECIFIER_INLINE ] ]
                                   [ not Declarators[*]::AnyDeclarator [ isFunction() |
                                                                         isFunctionTemplate() |
                                                                         isFunctionInstantiation() |
                                                                         isFunctionSpecialization() ] ]


- prompt: Find all instances where 'Gif' controlling expression is constant.


-This is the pattern for the above prompt:

                      // IfStmt [ not comesFromMacro() ]
                                / Cond::* [ isConstant() ]
                                          [ not descendant-or-self::SizeOfExpr ]
                                          [ not descendant-or-self::UnaryExpr [ @Op = KTC_OPCODE_SIZEOF ] ]


- prompt: Find all instances where bad pointer arithmetic is being performed.


-This is the pattern for the above prompt:

                      // BinaryExpr [ @Op = KTC_OPCODE_ADD |
                                      @Op = KTC_OPCODE_ADDASSIGN |
                                      @Op = KTC_OPCODE_SUB |
                                      @Op = KTC_OPCODE_SUBASSIGN
                                    ]
                                    [ $ltype := Left.getLanguageType().getInitialDefinedType() ]
                                    [ $ltype.isPointer() ]
                                    [ $pltype := $ltype.getPointedType().getInitialDefinedType() ]
                                    [ $pltype.getTypeName() != 'void' ]
                                    [ $pltype.getTypeName() != 'char' ]
                                    [ Right::SizeOfExpr [ $sotype := Type.getSemanticInfo().getInitialDefinedType() ]
                                                        [ $sotype.isPointer() | $sotype = $pltype ]
                                    ]
                                    [ $0 := Left.pretty() ]


- prompt: Find all instances where 'memset'-like function is called for 'sizeof' applied to a pointer.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                      // CallExpr  [ $name := getName() ]
                                   [ $name = 'memset' | $name = 'wmemset' ]
                                   [ $dst := getLanguageType(Args[0]::*) ]
                                   / Args[2]::UnaryExpr [ $sized := getLanguageType(Expr::*) ]
                                                        [ @Op = KTC_OPCODE_SIZEOF ]
                                                        [ $sized.isPointer() | $sized.isArray() ]
                                                        [ $sized.isPointer() | not $sized.getArraySizeSema() ]
                                                        [ $dst = $sized ]
                                                        [ $0 := $name ]

-->pattern 2 :

                      // CallExpr  [ $name := getName() ]
                                   [ $name = 'memset' | $name = 'wmemset' ]
                                   [ $dst := getLanguageType(Args[0]::*) ]
                                   / Args[2]::SizeOfExpr [ $sized := getLanguageType(Type::*) ]
                                                         [ $sized.isPointer() ]
                                                         [ $dst = $sized ]
                                                         [ $0 := $name ]

-->pattern 3 :

                      // CallExpr [ $name := getName() ]
                                  [ $name = 'bzero' ]
                                  [ $dst := getLanguageType(Args[0]::*) ]
                                  / Args[1]::UnaryExpr [ $sized := getLanguageType(Expr::*) ]
                                                       [ @Op = KTC_OPCODE_SIZEOF ]
                                                       [ $sized.isPointer() | $sized.isArray() ]
                                                       [ $sized.isPointer() | not $sized.getArraySizeSema() ]
                                                       [ $dst = $sized ]
                                                       [ $0 := $name ]

-->pattern 4 :

                      // CallExpr [ $name := getName() ]
                                  [ $name = 'bzero' ]
                                  [ $dst := getLanguageType(Args[0]::*) ]
                                  / Args[1]::SizeOfExpr [ $sized := getLanguageType(Type::*) ]
                                                        [ $sized.isPointer() ]
                                                        [ $dst = $sized ]
                                                        [ $0 := $name ]


- prompt: Find all instances where c-style type casting of pointer to object with virtual methods to pointer to its derived class is being performed.


-This is the pattern for the above prompt:

                      // CastExpr [ $from := Expr.getLanguageType().getInitialDefinedType() ]
                                  [ $from.isPointer() ]
                                  [ $to := Type.getLanguageType().getInitialDefinedType() ]
                                  [ $to.isPointer() ]
                                  [ $from_type := $from.getPointedType().getInitialDefinedType() ]
                                  [ $to_type := $to.getPointedType().getInitialDefinedType() ]
                                  [ isDerivedFrom($to_type, $from_type) ]
                                  [ $from_type.hasVirtualMethods() ]
                                  [ $0 := $from_type.getTypeName() ]


- prompt: Find all instances where a void function returns value.


-Following patterns together produces the solution for the above prompt. Each pattern solves a particular case:
-->pattern 1 :

                    //ReturnStmt [parent::{AnyStmt/parent::}AnyFuncBody/parent::FuncDef
                                    [getReturnType().getInitialDefinedType().getTypeName()='void']]
                                 [Expr::AnyExpr [getDefinedType().getTypeName()!='void']]

-->pattern 2 :

                    //ReturnStmt [parent::{AnyStmt/parent::}AnyFuncBody/parent::MemberFunc
                                    [getReturnType().getInitialDefinedType().getTypeName()='void']]
                                 [Expr::AnyExpr [getDefinedType().getTypeName()!='void']]

-->pattern 3 :

                   //ReturnStmt [parent::{AnyStmt/parent::}AnyFuncBody/parent::FuncDef
                                    [isConstructor()|isDestructor()]]
                                [Expr::AnyExpr [getDefinedType().getTypeName()!='void']]

-->pattern 4 :

                   //ReturnStmt [parent::{AnyStmt/parent::}AnyFuncBody/parent::MemberFunc
                                    [isConstructor()|isDestructor()]]
                                [Expr::AnyExpr [getDefinedType().getTypeName()!='void']]

To help you improve here are some example of prompts, your previous incorrect answers, why they were wrong and what you should have returned:

Prompt: Find functions that are not inline whose body is only composed of a `ReturnStmt`
Incorrect answer: //FuncDef[not isInline()][FuncBody::CompoundStmt/Stmts::ReturnStmt]
Comment: In this case the FuncBody’s type is a FuncBody and it’s child Stmt is a CompoundStmt.
Correct answer: //FuncDef[not isInline()][FuncBody::FuncBody/Stmt::CompoundStmt/Stmts[0]::ReturnStmt]

Prompt: Find functions, that are declared in a namespace.
Incorrect answer: //NamespaceDecl/Decls[*]::FuncDef
Comment: When the prompt asks for function declarations instead of function definition, then you should find 'FuncDeclarator' instead of 'FuncDef'.
Correct answer: //FuncDeclarator [ancestor::NamespaceDecl] 

Prompt: Find functions, that are declared in an anonymous namespace.
Incorrect answer: //FuncDeclarator[ancestor::NamespaceDecl[Name::Null]]
Comment: NamespaceDecl doesn’t have any child named 'Name', but it has an attribute named '@Id'. You should use it.
Correct answer: //FuncDeclarator[ancestor::NamespaceDecl[@Id='']]

Prompt: Find functions that only have one return statement.
Incorrect answer: //FuncDef[count(//ReturnStmt) = 1]
Comment: KAST doesn’t have a `count` function. Also, `//` cannot be used except at the beginning of the expression. It should have used descendant:: instead of `//`. There isn’t really an easy way to do this in KAST, you have to select a `ReturnStmt` and check that there isn’t another `ReturnStmt` in the `body`.
Correct answer: //FuncDef[$return1 := descendant::ReturnStmt][$return1][not descendant::ReturnStmt[this() != $return1]]

Prompt: Find all classes whose name does not start with uppercase letter
Incorrect answer: //ClassType[not starts-from-capital(Name::AnyNames/Name::Name/@Id)]
Comment: Functions cannot take selectors as parameter, it has to be saved to a variable first. Also, attributes cannot be selected, but their value can be saved to a variable.
Correct answer: //ClassType[Name::Name[$className := @Id]][not starts-from-capital($className)]

Prompt: Find function names whose name does not start with a capital letter
Incorrect answer: //FuncDef[Declarator::FuncDeclarator/Declarator::AnyNonPtrDeclarator/Name[$name := @Id]][not starts-from-capital($name)]
Comment: When selecingt a child, always specify its name and type.
Correct answer: //FuncDef[Declarator::FuncDeclarator/Declarator::AnyNonPtrDeclarator/Name::Name[$name := @Id]][not starts-from-capital($name)]
Replace instances of " and " in your answer with "][". Replace instances of "[Op" in your answer with "[@Op".
Replace instances of " or " in your answer with "|".

Prompt: Find inline functions that are within a namespace named `Foo`.
Incorrect answer: //FuncDef[isInline()][ancestor::NamespaceDecl[Name::Name[@Id='Foo']]]
Comment: 'NamespaceDecl' does not have a child named "Name", but it has a parameter called "Id". So the [@Id='Foo'] predicate should be directly applied on NamespaceDecl.
Correct answer: //FuncDef[isInline()][ancestor::NamespaceDecl[@Id='Foo']]

Prompt: Find switch statements that have no `default` case.
Incorrect answer: //SwitchStmt[Stmt::CompoundStmt/Stmts[descendant::DefaultLabel::Null]]
Comment: Here step expression is not needed. You can directly write the expression for "switch statements, where there is no descendant of type 'DefaultLabel'". Also, [descendant::DefaultLabel::Null] is wrong. Use "Null" to check if something is empty. Here we are checking if default label is "present or not". So we need to use "not axis_specification::node_type" in the predicate.
Correct answer: //SwitchStmt[not descendant::DefaultLabel]

Prompt: Find 'typedef's that do not define anything.
Incorrect answer: //StorageClass[@Spec=KTC_STORAGECLASS_TYPEDEF][Declarators::Null]
Comment: Here you have applied the second predicate [Declarators::Null] on //StorageClass, which is invalid. Instead we should find all the decl, where StorageClass[@Spec=KTC_STORAGECLASS_TYPEDEF] is present and no declarators are available.
Correct answer: //Decl[DeclSpecs[*]::StorageClass[@Spec=KTC_STORAGECLASS_TYPEDEF]][Declarators::Null]


Prompt: Find all static global variables.
Incorrect answer: //Decl[Declarators[*]::AnyDeclarator/DeclSpecs[*]::StorageClass[@Spec=KTC_STORAGECLASS_STATIC]][parent::TranslationUnit]
Comment: Declarators[*] does not have any child named StorageClass of type DeclSpecs[*]. Decl itself is the parent of DeclSpecs[*]::StorageClass.
Correct answer: //Decl[DeclSpecs[*]::StorageClass[@Spec=KTC_STORAGECLASS_STATIC]][parent::TranslationUnit]

Prompt: Find function names that do not contain only lowercase characters.
Incorrect answer: //FuncDef[Declarator::FuncDeclarator/Declarator::AnyNonPtrDeclarator/Name::Name[$name := @Id]][not $name.matches('^[a-z]+$')]
Comment: When the prompt says "do not contain only lowercase characters" we have to find instances where "it contains atleast one instance of upper case character". The returned prompt finds instances where "function names do not contain any lowercase characters". Also, instead of using step operation, you can use "getName()" function.
Correct answer: //FuncDef/Declarator::FuncDeclarator[$name := getName()][matches($name, '[A-Z]+')]

Prompt: Find cast expression used as lvalue.
Incorrect answer: //CastExpr[isLvalue()]
Comment: There is no function named "isLvalue()".
Correct answer: //BinaryExpr[@Op = KTC_OPCODE_ASSIGN][Left::CastExpr]

Prompt: Find functions that are not const qualified and whose body does not contain any function calls.
Incorrect answer: //FuncDeclarator[not isConst()][FuncBody::FuncBody/Stmt::CompoundStmt/Stmts[not descendant::CallExpr]]
Comment: 'Stmts' is not a concrete type. Its an abstract array type node. You can not apply a predicate on an abstract type. 
Correct answer: //FuncDef[not isConst()][FuncBody::FuncBody[not descendant::CallExpr]]

Prompt: Find classes with non-virtual destructor.
Incorrect answer: //ClassType[getDestructor()[not isVirtual()]]
Comment: getDestructor() returns semantic information of a destructor, but isVirtual() function can be called on a particualr AST node. That's why we need to call "isDestructor()" and "not isVirtual()" on MemberFunc. 
Correct answer: //ClassType[MemberDecls[*]::MemberFunc[isDestructor()][not isVirtual()]]


Prompt: Find non-empty clauses in switch statements that are not terminated with a break statement.
Incorrect answer: //SwitchStmt/Stmt::CompoundStmt/Stmts[*]::CompoundStmt[Stmts[*]::*] [not descendant::BreakStmt]
Comment: Stmts[*] has two types of children - "LabeledStmt" and "BreakStmt". We need to find a LabeledStmt, for which next-sibling is not BreakStmt. 
Correct answer: //SwitchStmt/Stmt::CompoundStmt/Stmts[*]::LabeledStmt[not next-sibling::BreakStmt]

Valid arithmetic operators are: +, -, /, *. Valid relational operators are: >, <, >=, <=, =, !=. Instead of something like f() = false, use not f(). There should not be any instances of [// in your answer. If there are, try again.

Use 'void' to represent void, not 0.

You can save intermediate results or values returned by functions to variables. Variable are prefixed by $ and can be assigned a value using :=. For example, the following expression would select all if statements where the output of pretty is the same for the Then and Else fields. Intermediate values should be stored into variables only when it has a use in the future. Otherwise do not store the result in a variable. For example: for the prompt "Find functions that are not const qualified." you can directly return //FuncDeclarator[not isConst()] instead of //FuncDeclarator[$isConst := isConst()][not $isConst]

//IfStmt[$t := Then::DeclOrStmts][$e := Else::DeclOrStmts][pretty($e) = pretty($t)]
This can also be used to store values returned by function calls. For example, the following expression would select all nodes of type FuncDeclarator and store the result of isAssignmentOperator() in variable $assignOp.

//FuncDeclarator[$assignOp := isAssignmentOperator()]
Note that to actually filter the FuncDeclarator nodes with the result of this function, we would need to evaluate it in a separate predicate, for example:

//FuncDeclarator[$assignOp := isAssignmentOperator()][$assignOp]
A predicate cannot be directly evaluated on an attribute. For example, the following expression is invalid:

//Name[@Id[length() > 10]]
Instead, the function should have been called on the attribute itself:

//Name[@Id.length() > 10]
If the child is an array, then you can use [*] to mean "any element in the array", or use a specific index like [0] to access the first element of the array.

The Null type can be used to indicate that a child is empty. For example, the following expressions selects if statements where the Else child has no nodes, meaning that only it's Then has a body.

//IfStmt [Else::Null]